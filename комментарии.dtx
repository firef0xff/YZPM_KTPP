
@@ClassConnector
Description
Интерфейс для передачи команды на загрузку детали в модуль

@@ClassConnector::Load@Obd *const
Description
Чистая виртуальная функция. Является интерфейсом для
возможности отослать команду на загрузку детали в модуль не
зависимо от типа модуля
Type Parameters
det :  Указатель на класс описания детали

@@collation
Description
Класс данных для IconsData, содержит набор переменных для
сопоставления данных расположения иконки в контейнере и в
базе

@@collation::Accept
Description
Индикатор разрешения на доступ к объекту для которого
используется иконка

@@collation::inbase
Description
Идентификатор иконки в базе данных

@@collation::InList
Description
Порядковый номер иконки в контейнере

@@collation::type
Description
Тип набора иконок

@@ComboRow
Description
Класс данных для выпадающего списка из модуля TStSelect.

@@ComboRow::~ComboRow
Description
Деструктор.
C++ Syntax
<code lang="c++">
ComboRow::~ComboRow(void){}
</code>

@@ComboRow::ComboRow@int &@String &@bool &
C++ Syntax
<code lang="c++">
    ComboRow::ComboRow(const int &amp;_StateID,const String &amp;_StateName,const bool &amp;_StateAccept)
{
StateID=_StateID;
StateName=_StateName;
StateAccept=_StateAccept;
}
</code>
Description
Конструктор. Заносит данные в класс, которые будут считыватся
через функции доступа.
Type Parameters
_StateID :      Идентификатор состояния
_StateName :    Название состояния
_StateAccept :  Индикатор доступа к состоянию

@@ComboRow::GetStateAccept
C++ Syntax
<code lang="c++">
bool     GetStateAccept(void){return StateAccept;};
</code>
Description
Inline функция доступа к данным. Возвращает индикатор доступа
к состоянию.

@@ComboRow::GetStateID
C++ Syntax
<code lang="c++">
int     GetStateID(void)    {return StateID;};
</code>
Description
Inline функция доступа. Возвращает индентификатор состояния.

@@ComboRow::GetStateName
C++ Syntax
<code lang="c++">
String  GetStateName(void)    {return StateName;};
</code>
Description
Inline функция доступа. Возвращает название состояния.

@@ComboRow::StateAccept
Description
Хранит индикатор доступности к состоянию

@@ComboRow::StateID
Description
Хранит идентификатор состояния

@@ComboRow::StateName
Description
Хранит название состояния

@@CRowData
Description
Класс данных для построения дерева в TCond.

@@CRowData::~CRowData
Description
Деструктор.
C++ Syntax
<code lang="c++">
CRowData::~CRowData(void)
{
count--;
}
</code>

@@CRowData::CRowData@bool &@int &@int &@int &@int &@String &@String &@String &@String &@bool &@bool &@bool &@bool &
Description
Конструктор. Принимает значения для всех переменных класса.
C++ Syntax
<code lang="c++">
CRowData::CRowData(const bool &amp;_MassAction,        const int &amp;_id,const int &amp;_CurrState,
            const int &amp;_NextState,            const int &amp;_PrevState,
            const String &amp;_text,            const String &amp;_CurrStateName,
            const String &amp;_NextStateName,    const String &amp;_PrevStateName,
            const bool &amp;_Accept,    const bool &amp;_Arhive,    const bool &amp;_NextAccept,
            const bool &amp;_PrevAccept):MassAction(_MassAction)
{
count++;

CurrState=_CurrState;
CurrStateName=_CurrStateName;
if (!MassAction)
    {
    id=_id;
    text=_text;
    }else{id=-1;text="";}
Accept=_Accept;
Arhive=_Arhive;
NextAccept=_NextAccept;
PrevAccept=_PrevAccept;
NextState=_NextState;
PrevState=_PrevState;
NextStateName=_NextStateName;
PrevStateName=_PrevStateName;
TurnCurrState();
}
</code>
Type Parameters
_MassAction :     Ссылка на индикатор массовых действий (как
                  правило действия над всем узлом)
_id :             Ссылка на идентификатор узла/детали в базе
_CurrState :      Ссылка на идентификатор текущего состояния
                  узла/детали
_NextState :      Ссылка на идентификатор следующего
                  возможного состояния узла/детали
_PrevState :      Ссылка на идентификатор возможного
                  предыдущего состояния узла/детали
_text :           Ссылка на текст, отображаемый пользователю
_CurrStateName :  Ссылка на название текущего состояния
                  узла/детали
_NextStateName :  Ссылка на название следующего возможного
                  состояния узла/детали
_PrevStateName :  Ссылка на название возможного предыдущего
                  состояния узла/детали
_Accept :         Ссылка на индикатор доступа к текущему
                  состоянию узла/детали
_Arhive :         Ссылка на индикатор архивности текущего
                  состояния узла/детали
_NextAccept :     Ссылка на индикатор доступа к следющему
                  возможному состоянию узла/детали
_PrevAccept :     Ссылка на индикатор доступа к возможному
                  предыдущему состоянию узла/детали

@@CRowData::Accept
Description
Индикатор доступа к текущему состоянию.

@@CRowData::GetArhive@const
Description
Inline функция доступа к данным. Возвращает индикатор
архивности текущего состояния.
C++ Syntax
<code lang="c++">
bool GetArhive(void) const{return Arhive;}
</code>

@@CRowData::GetCurrState@const
Description
Inline функция доступа к данным. Возвращает идентификатор
текущего состояния.
C++ Syntax
<code lang="c++">
int GetCurrState(void) const{return CurrState;}
</code>

@@CRowData::GetID
Description
Inline функция доступа к данным. Возвращает идентификатор
узла/детали у которо меняется состояние.
C++ Syntax
<code lang="c++">
int GetID(void){return id;};
</code>

@@CRowData::GetNextState@const
Description
Inline функция доступа к данным. Возвращает идентификатор
следующего состояния.
C++ Syntax
<code lang="c++">
int GetNextState(void) const{return NextState;}
</code>

@@CRowData::GetSelectedAccept@const
Description
Inline функция доступа к данным. Возвращает индикатор
архивности выбранного состояния.
C++ Syntax
<code lang="c++">
bool GetSelectedAccept() const{return SelectedAccept;}
</code>

@@CRowData::GetSelectedState@const
Description
Inline функция доступа к данным. Возвращает идентификатор
выбранного состояния.
C++ Syntax
<code lang="c++">
int GetSelectedState(void)  const{return SelectedState;}
</code>

@@CRowData::GetSelectedStateName@const
Description
Inline функция доступа к данным. Возвращает название
выбранного состояния.
C++ Syntax
<code lang="c++">
String GetSelectedStateName()  const{return SelectedStateName;}
</code>

@@CRowData::GetText
Description
Возвращает текст для отображения пользователю
C++ Syntax
<code lang="c++">
String     CRowData::GetText(void)
{
if (MassAction)
    {
    return CurrStateName;
    }else
    {
    return text;
    }
}
</code>

@@CRowData::SetNextState@int &@String &@bool &
Description
Функция переназанчает следующее возможное состояние


C++ Syntax
<code lang="c++">
void     CRowData::SetNextState(const int &amp;StateID,const String &amp;StateName,const bool &amp;StateAccept)
{
NextAccept=StateAccept;
NextStateName=StateName;
NextState=StateID;
}
</code>

Type Parameters
StateID :      Идентификатор состояния
StateName :    Название состояния
StateAccept :  Разрешение на доступ к состоянию

@@CRowData::SetPrevState@int &@String &@bool &
Description
Функция переназанчает предыдущее возможное состояние


C++ Syntax
<code lang="c++">
void     CRowData::SetPrevState(const int &amp;StateID,const String &amp;StateName,const bool &amp;StateAccept)
{
PrevAccept=StateAccept;
PrevStateName=StateName;
PrevState=StateID;
}
</code>

Type Parameters
StateID :      Идентификатор состояния
StateName :    Название состояния
StateAccept :  Разрешение на доступ к состоянию

@@CRowData::TurnCurrState
Description
Функция переключает выбранное состояние (SelectedState) в
позицию текущего состония (CurrState)
C++ Syntax
<code lang="c++">
bool     CRowData::TurnCurrState(void)
{
SelectedState=CurrState;
SelectedStateName=CurrStateName;
SelectedAccept=Accept;
return true;
}
</code>

@@CRowData::TurnNextState
Description
Функция переключает выбранное состояние (SelectedState) в
позицию следующего состония (NextState)


C++ Syntax
<code lang="c++">
bool     CRowData::TurnNextState(void)
{
if (NextState\>0)
    {
    SelectedState=NextState;
    SelectedStateName=NextStateName;
    SelectedAccept=NextAccept;
    }else
    {
    return false;
    }
return true;
}
</code>

@@CRowData::TurnPrevState
Description
Функция переключает выбранное состояние (SelectedState) в
позицию предыдущего состония (PrevState)


C++ Syntax
<code lang="c++">
bool     CRowData::TurnPrevState(void)
{
if (PrevState\>0)
    {
    SelectedState=PrevState;
    SelectedStateName=PrevStateName;
    SelectedAccept=PrevAccept;
    }else
    {
    return false;
    }
return true;
}
</code>

@@CRowData::Arhive
Description
Индикатор архивности состояния.

@@CRowData::count
Description
Счетчик количества существующих экземпляров класса.

@@CRowData::CurrState
Description
Идентификатор текущего состояния

@@CRowData::CurrStateName
Description
Название текущего состояния

@@CRowData::id
Description
Идентификатор узла/детали для которой меняется состояние
 
Note
В случае массовых действий этот индентификатор не участвует в
работе и инициализирован "-1"

@@CRowData::MassAction
Description
Ссылка на индикатор действий над группой узлов/деталей
(например над всеми входящими узлами и деталями)

@@CRowData::NextAccept
Description
Индикатор доступа к следующему возможному сосотоянию
узла/детали

@@CRowData::NextState
Description
Идентификатор следующго возможного сосотояния узла/детали

@@CRowData::NextStateName
Description
Название следующего возможного состояния узла/детали

@@CRowData::PrevAccept
Description
Индикатор доступа к возможному предыдущему сосотоянию
узла/детали

@@CRowData::PrevState
Description
Идентификатор возможного предыдущего сосотояния узла/детали

@@CRowData::PrevStateName
Description
Название возможного предыдущего состояния узла/детали

@@CRowData::text
Description
Текст отображаемый пользователю при MassAction=false

@@CRowData::SelectedAccept
Description
Индикатор доступа к выбранному состоянию узла/детали

@@CRowData::SelectedState
Description
Идентификатор выбранного состояния узла/детали.

@@CRowData::SelectedStateName
Description
Название выбранного состояния узла/детали

@@ClassConnector.h
Description
Интерфейс для отправки команды на загрузку узла/детали в
модуль программы
C++ Syntax
<code lang="c++">
\#ifndef ClassConnectorH
\#define ClassConnectorH
\#include "Obd.h"
class ClassConnector
{
public:
    virtual void Load (const Obd *const det)=0;
private:
};
\#endif
</code>

@@ClassConnector.cpp
Description
Интерфейс для отправки команды на загрузку узла/детали в
модуль программы
C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "ClassConnector.h"
\#pragma package(smart_init)
    /*ClassConnector::ClassConnector()
{

}
    ClassConnector::~ClassConnector()
{

}     */
</code>

@@collation.h
Description
Класс данных для IconsData
C++ Syntax
<code lang="c++">
\#ifndef collationH
\#define collationH

class collation
    {
    public:
    int inbase;
    int InList;
    bool Accept;
    int type;
    };
\#endif
</code>

@@collation.cpp
Description
Класс данных для IconsData
C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "collation.h"
\#pragma package(smart_init)
</code>

@@ComboRow.h
Description
Класс данных для выпадающего списка из модуля TStSelect.


C++ Syntax
<code lang="c++">
\#ifndef ComboRowH
\#define ComboRowH
\#include "Classes.hpp"
class ComboRow
{
public:
    ComboRow(const int &amp;_StateID,const String &amp;_StateName,const bool &amp;_StateAccept);
    ~ComboRow(void);
int     GetStateID(void)    {return StateID;};
String  GetStateName(void)    {return StateName;};
bool     GetStateAccept(void){return StateAccept;};
private:
int     StateID;
String     StateName;
bool     StateAccept;
};
\#endif
</code>

@@ComboRow.cpp
Description
Класс данных для выпадающего списка из модуля TStSelect.
C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "ComboRow.h"
\#pragma package(smart_init)
    ComboRow::ComboRow(const int &amp;_StateID,const String &amp;_StateName,const bool &amp;_StateAccept)
{
StateID=_StateID;
StateName=_StateName;
StateAccept=_StateAccept;
}
    ComboRow::~ComboRow(void)
{

}
</code>

@@CRowData.h
Description
Класс данных для построения дерева в TCond.
C++ Syntax
<code lang="c++">
\#ifndef CRowDataH
\#define CRowDataH
\#include \<Classes.hpp\>
class CRowData
    {
    public:
    CRowData(const bool &amp;_MassAction,        const int &amp;_id,const int &amp;_CurrState,
            const int &amp;_NextState,            const int &amp;_PrevState,
            const String &amp;_text,            const String &amp;_CurrStateName,
            const String &amp;_NextStateName,    const String &amp;_PrevStateName,
            const bool &amp;_Accept,      const bool &amp;_Arhive,    const bool &amp;_NextAccept,
            const bool &amp;_PrevAccept);

    ~CRowData(void);
    int GetCurrState(void)            const{return CurrState;}
    int GetNextState(void)            const{return NextState;}
    int GetSelectedState(void)        const{return SelectedState;}
    String GetSelectedStateName()     const{return SelectedStateName;}
    bool GetSelectedAccept()         const{return SelectedAccept;}
    bool GetArhive(void)            const{return Arhive;}
    bool TurnCurrState(void);
    bool TurnNextState(void);
    bool TurnPrevState(void);
    void SetNextState(const int &amp;StateID,const String &amp;StateName,const bool &amp;StateAccept);
    void SetPrevState(const int &amp;StateID,const String &amp;StateName,const bool &amp;StateAccept);
    String GetText(void);
    int GetID(void){return id;};
    private:

    int CurrState;
    int NextState;
    int PrevState;
    String CurrStateName;
    String NextStateName;
    String PrevStateName;

    bool Accept;
    bool Arhive;
    bool NextAccept;
    bool PrevAccept;

    static int count;

    const bool &amp;MassAction;
    int id;
    String text;
    int SelectedState;
    String SelectedStateName;
    bool SelectedAccept;
    };
int CRowData::count=0;

\#endif

</code>

@@CRowData.cpp
Description
Класс данных для построения дерева в TCond.
C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "CRowData.h"
\#pragma package(smart_init)
        CRowData::CRowData(const bool &amp;_MassAction,        const int &amp;_id,const int &amp;_CurrState,
            const int &amp;_NextState,            const int &amp;_PrevState,
            const String &amp;_text,            const String &amp;_CurrStateName,
            const String &amp;_NextStateName,    const String &amp;_PrevStateName,
            const bool &amp;_Accept,    const bool &amp;_Arhive,    const bool &amp;_NextAccept,
            const bool &amp;_PrevAccept):MassAction(_MassAction)
{
count++;

CurrState=_CurrState;
CurrStateName=_CurrStateName;
if (!MassAction)
    {
    id=_id;
    text=_text;
    }else{id=-1;text="";}
Accept=_Accept;
Arhive=_Arhive;
NextAccept=_NextAccept;
PrevAccept=_PrevAccept;
NextState=_NextState;
PrevState=_PrevState;
NextStateName=_NextStateName;
PrevStateName=_PrevStateName;
TurnCurrState();
}
        CRowData::~CRowData(void)
{
count--;
}
void     CRowData::SetNextState(const int &amp;StateID,const String &amp;StateName,const bool &amp;StateAccept)
{
NextAccept=StateAccept;
NextStateName=StateName;
NextState=StateID;
}
void     CRowData::SetPrevState(const int &amp;StateID,const String &amp;StateName,const bool &amp;StateAccept)
{
PrevAccept=StateAccept;
PrevStateName=StateName;
PrevState=StateID;
}
bool     CRowData::TurnCurrState(void)
{
SelectedState=CurrState;
SelectedStateName=CurrStateName;
SelectedAccept=Accept;
return true;
}
bool     CRowData::TurnNextState(void)
{
if (NextState\>0)
    {
    SelectedState=NextState;
    SelectedStateName=NextStateName;
    SelectedAccept=NextAccept;
    }else
    {
    return false;
    }
return true;
}
bool     CRowData::TurnPrevState(void)
{
if (PrevState\>0)
    {
    SelectedState=PrevState;
    SelectedStateName=PrevStateName;
    SelectedAccept=PrevAccept;
    }else
    {
    return false;
    }
return true;
}
String     CRowData::GetText(void)
{
if (MassAction)
    {
    return CurrStateName;
    }else
    {
    return text;
    }
}
</code>

@@FileRow::~FileRow
Description
Деструктор
C++ Syntax
<code lang="c++">
FileRow::~FileRow(void)
{
count--;
}
</code>

@@FileRow::FileRow@FileRow &
Description
Конструктор копировщик
C++ Syntax
<code lang="c++">
FileRow::FileRow(const FileRow &amp;r):Obd(r),LUser(r.LUser)
{
count++;
icoID=r.icoID;
FileName=r.FileName;
FilePath=r.FilePath;
Creator=r.Creator;
Updater=r.Updater;
Accept=r.Accept;
DateOfCreate=r.DateOfCreate;
DateOfUpdate=r.DateOfUpdate;
}
</code>

@@FileRow::FileRow@cSQL *@int &
Description
Конструктор
C++ Syntax
<code lang="c++">
FileRow::FileRow(cSQL *db,const int &amp;User):Obd(db),LUser(User)
{
count++;
init();
}
</code>

Type Parameters
db :    Указатель на класс для работы с базой данных
User :  Константная ссылка на переменную, содержащую
        идентификатор пользователя

@@FileRow::Accept
Description
Индикатор доступа пользователя к детали, которой пренадлежит
файл

@@FileRow::count
Description
Переменная - счетчик количества запущенных экземпляров класса

@@FileRow::Creator
Description
Перменная содержащая имя пользователя, впервые
присоеденившего файл к базе

@@FileRow::DateOfCreate
Description
Переменная содержащая дату первого присоединения файла к базе

@@FileRow::DateOfUpdate
Description
Переменная содержащая дату изменнения файла к базе

@@FileRow::FileName
Description
Переменная содержащая реальное название файла

@@FileRow::FilePath
Description
Переменная содержащая путь к файлу в хранилище

@@FileRow::icoID
Description
Идентификатор иконки файла из базы для отправки в IconsData и
получения самой иконки

@@FileRow::LUser
Description
Ссылка на идентификатор пользователя, вошедшего в программу

@@FileRow::Updater
Description
Преременная содержащая имя пользователя изменивщего файл в
базе.

@@FileRow::CanUse@const
Description
Виртуальная функция, определяющая может быть использован
текущий экземпляр класса или нет
C++ Syntax
<code lang="c++">
virtual bool CanUse(void) const
{
return (id\>0&amp;&amp;Get_Obd(false)!=""&amp;&amp;FilePath!="")?true:false;
};
</code>
Return Value List
True :   Класс имеет минимальный набор данных и может
         использоваться
False :  Класс не имеет минимального набора данных его
         использование не допустимо

@@FileRow::Count
Description
Функция возвращающая количество существующих экземпляров
класса
C++ Syntax
<code lang="c++">
int Count(void)const{return count;};
</code>

@@FileRow::Get_Accept@const
Description
Inline функция доступа. Возвращает индикатор доступа к детали
к которой прикреплен файл
C++ Syntax
<code lang="c++">
bool Get_Accept (void)const{return Accept;};
</code>

@@FileRow::Get_Creator@const
Description
Inline функция доступа. Возвращает Имя пользователя впервые
присоеденивщего файл к базе
C++ Syntax
<code lang="c++">
String Get_Creator(void) const{return Creator;};
</code>

@@FileRow::Get_DateOfUpdate@const
Description
Inline функция доступа. Возвращает дату последнего обновления
файла в базе
C++ Syntax
<code lang="c++">
TDateTime Get_DateOfUpdate    (void)const{return DateOfUpdate;};
</code>

@@FileRow::Get_DateOfCreate@const
Description
Inline функция доступа. Возвращает дату первого присоединения
файла к базе
C++ Syntax
<code lang="c++">
TDateTime Get_DateOfCreate (void)const{return DateOfCreate;};
</code>

@@FileRow::Get_FileName@const
Description
Inline функция доступа. Возвращает реальное имя файла
C++ Syntax
<code lang="c++">
String    Get_FileName(void)const{return FileName;};
</code>

@@FileRow::Get_FilePath@const
Description
Inline функция доступа. Возвращает расположение файла с
хранилище
C++ Syntax
<code lang="c++">
String    Get_FilePath(void)const{return FilePath;};
</code>

@@FileRow::Get_icoID@const
Description
Inline функция доступа. Возвращает идентификатор иконки файла
C++ Syntax
<code lang="c++">
int    Get_icoID (void)const{return icoID;};
</code>

@@FileRow::Get_Text@const
Description
Inline функция доступа. Возвращает текст отображаемый
пользователю.
C++ Syntax
<code lang="c++">
String  Get_Text  (void)const{return FileName+" - "+DateOfUpdate.DateString();};
</code>

@@FileRow::Get_Updater@const
Description
Inline функция доступа. Возвращает имя пользователя
сделавшего последнее изменение файла.
C++ Syntax
<code lang="c++">
String    Get_Updater    (void)const{return Updater;};
</code>

@@FileRow::init
Description
Функция инициализирующая переменные класса на значения по
умолчанию
C++ Syntax
<code lang="c++">
void     FileRow::init(void)
{
icoID=-1;
FileName="";
FilePath="";
Creator="";
Updater="";
Accept=false;
DateOfCreate=0;
DateOfUpdate=0;
}
</code>

@@FileRow::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code lang="c++">
bool ItTrueClassName (void)const
{
return TrueClassName()=="FileRow"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@FileRow::SetData@int &@int &@String &@String &@String &@int &@String &@String &@String &@String &@bool &@TDateTime &@TDateTime &
Description
Функция предназначенная для загрузки данных из вне.
Используется как основной источник данных для класса.
Основное использование в TSpTree::LoadFiles
C++ Syntax
<code lang="c++">
bool     FileRow::SetData    (//базовые
                        const int &amp;_id,        const int &amp;_SpRazd,
                        const String &amp;_Obd,    const String &amp;_Name,
                        const String &amp;_SpRazdName,
                        // свои
                        const int &amp;_icoID,        const String &amp;_FileName,    const String &amp;_FilePath,
                        const String &amp;_Creator,    const String &amp;_Updater,    const bool &amp;_Accept,
                        const TDateTime &amp;_DateOfCreate,    const TDateTime &amp;_DateOfUpdate
                        )
{
if (ItTrueClassName())
    {
    SetId(_id);
    SetObd(_Obd);
    SpRazd=_SpRazd;
    Name=_Name.Trim();
    SpRazdName=_SpRazdName.Trim();
    icoID=_icoID;
    FileName=_FileName.Trim();
    FilePath=_FilePath.Trim();
    Creator=_Creator.Trim();
    Updater=_Updater.Trim();
    Accept=_Accept;
    DateOfCreate=_DateOfCreate;
    DateOfUpdate=_DateOfUpdate;
    }
return CanUse();
}
</code>
Type Parameters
_id :            Идентификатор детали
_SpRazd :        Идентификатор раздела спецификации к которому
                 принадлежит деталь
_Obd :           Обозначение детали
_Name :          Наименование детали
_SpRazdName :    Название аздела спецификации к которому
                 принадлежит деталь
_icoID :         Идентификатор иконки файла
_FileName :      Имя файла (до присоединения к базе)
_FilePath :      Расположение файла в базе
_Creator :       Имя пользователя впервые присоединившего файл
                 к базе
_Updater :       Имя пользователя последнего обновившего файл
                 в базе
_Accept :        Индикатор доступа к детали
_DateOfCreate :  Дата прикрепления файла к базе
_DateOfUpdate :  Дата последнего обновления файла в базе

@@FileRow::SetId@int &
Description
Функция присоединия нового идентификатора детали к классу
C++ Syntax
<code lang="c++">
void SetId       (const int &amp;ID){id=ID;};
</code>
Type Parameters
ID :  Идентификатор узла/детали

@@FileRow::SetObd@String &
Description
Функция определяющая обозначение детали в двух форматах V_Obd
и G_Obd.
C++ Syntax
<code lang="c++">
void FileRow::SetObd (const String &amp;r)
{
V_Obd=GostToVin(r);
G_Obd=VinToGost(r);
}
</code>
Type Parameters
r :  Обозначение в произвольном виде
Note
  * V_Obd &#45; Обозначение по системе обозначений АСУ
  * G_Obd &#45; Обозначение по Госту (или исходное)

@@FileRow::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code lang="c++">
String TrueClassName (void)const{return "FileRow";};
</code>

@@FileRow::UpdateVal
Description
Функция для обновления данных класса из базы.
C++ Syntax
<code lang="c++">
bool     FileRow::UpdateVal (void)
{
String sql="call constructions.UpdateFileInfo('"+String(id)+"','"+FileName+"','"+String(LUser)+"')";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
        //базовые
    SetId(rez-\>FieldByName("id")-\>Value);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SetObd(rez-\>FieldByName("obd")-\>Value);
    Name=rez-\>FieldByName("namd")-\>Value;
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    // свои
    icoID=rez-\>FieldByName("icoID")-\>Value;
    FileName=rez-\>FieldByName("FileName")-\>Value;
    FilePath=rez-\>FieldByName("FilePath")-\>Value;
    Creator=rez-\>FieldByName("Creator")-\>Value;
    Updater=rez-\>FieldByName("Updater")-\>Value;
    Accept=rez-\>FieldByName("Accept")-\>Value;
    if (!rez-\>FieldByName("DateOfCreate")-\>Value.IsNull()){DateOfCreate=rez-\>FieldByName("DateOfCreate")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("DateOfUpdate")-\>Value.IsNull()){DateOfUpdate=rez-\>FieldByName("DateOfUpdate")-\>Value.operator TDateTime();}
    delete rez;
    }else
    {
    init();
    Obd::init();
    delete rez;
    }
return CanUse();
}
</code>

@@FileRow::=@FileRow &
Description
Оператор присвоения.
C++ Syntax
<code lang="c++">
FileRow &amp;     FileRow::operator =(const FileRow &amp;r)
{
if (this==&amp;r) {return *this;}
//базовые
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
// свои
icoID=r.icoID;
FileName=r.FileName;
FilePath=r.FilePath;
Creator=r.Creator;
Updater=r.Updater;
Accept=r.Accept;
DateOfCreate=r.DateOfCreate;
DateOfUpdate=r.DateOfUpdate;
return *this;
}
</code>

Type Parameters
r :  Ссылка на другой экземпляр класса

@@FileRow::!=@FileRow &@const
Description
Оператор сравнения (проверка на неравенство)
C++ Syntax
<code lang="c++">
bool     FileRow::operator !=(const FileRow &amp;r)
{
if (this==&amp;r) {return false;}
if (
    //базовые
    id!=r.id&amp;&amp;
    SpRazd!=r.SpRazd&amp;&amp;
    G_Obd!=r.G_Obd&amp;&amp;
    V_Obd!=r.V_Obd&amp;&amp;
    Name!=r.Name&amp;&amp;
    SpRazdName!=r.SpRazdName&amp;&amp;
    // свои
    icoID!=r.icoID&amp;&amp;
    FileName!=r.FileName&amp;&amp;
    FilePath!=r.FilePath&amp;&amp;
    Creator!=r.Creator&amp;&amp;
    Updater!=r.Updater&amp;&amp;
    Accept!=r.Accept&amp;&amp;
    DateOfCreate!=r.DateOfCreate&amp;&amp;
    DateOfUpdate!=r.DateOfUpdate
    ){return true;}else{return false;}
}
</code>
Type Parameters
r :  Ссылка на другой экземпляр класса
Return Value List
True :   Данные в классах не равны
False :  Данные в классах равны

@@FileRow::==@FileRow &@const
Description
Оператор сравнения (проверка на равенство)
C++ Syntax
<code lang="c++">
bool     FileRow::operator ==(const FileRow &amp;r)
{
if (this==&amp;r) {return true;}
if (
    //базовые
    id!=r.id&amp;&amp;
    SpRazd!=r.SpRazd&amp;&amp;
    G_Obd!=r.G_Obd&amp;&amp;
    V_Obd!=r.V_Obd&amp;&amp;
    Name!=r.Name&amp;&amp;
    SpRazdName!=r.SpRazdName&amp;&amp;
    // свои
    icoID!=r.icoID&amp;&amp;
    FileName!=r.FileName&amp;&amp;
    FilePath!=r.FilePath&amp;&amp;
    Creator!=r.Creator&amp;&amp;
    Updater!=r.Updater&amp;&amp;
    Accept!=r.Accept&amp;&amp;
    DateOfCreate!=r.DateOfCreate&amp;&amp;
    DateOfUpdate!=r.DateOfUpdate
    ){return false;}else{return true;}
}
</code>

Type Parameters
r :  Ссылка на другой экземпляр класса

Return Value List
True :   Данные в классах равны
False :  Данные в классах не равны

@@FileRow
Класс данных, содержащий информацию о файлах прикрепленных к
деталям.

@@FileRow.h
Description
Класс данных для хранения информации о файлах прикрепленных к
детали
C++ Syntax
<code lang="c++">
\#ifndef FileRowH
\#define FileRowH

\#include "Obd.h"

class FileRow:public Obd
    {
    public:

    FileRow(cSQL *db,const int &amp;User);
    FileRow(const FileRow &amp;);
    ~FileRow(void);
    bool UpdateVal (void);

    bool ItTrueClassName (void)const{return TrueClassName()=="FileRow"?true:false;}
    String TrueClassName (void)const{return "FileRow";};
    virtual bool CanUse    (void)        const{return (id\>0&amp;&amp;Get_Obd(false)!=""&amp;&amp;FilePath!="")?true:false;};

    int    Get_icoID        (void)const{return icoID;};
    String     Get_Text     (void)const{return FileName+" - "+DateOfUpdate.DateString();};
    String    Get_FileName(void)const{return FileName;};
    String    Get_FilePath(void)const{return FilePath;};
    String    Get_Creator    (void)const{return Creator;};
    String    Get_Updater    (void)const{return Updater;};
    bool Get_Accept        (void)const{return Accept;};
    TDateTime Get_DateOfCreate    (void)const{return DateOfCreate;};
    TDateTime Get_DateOfUpdate    (void)const{return DateOfUpdate;};


    bool SetData     (//базовые
                        const int &amp;_id,        const int &amp;_SpRazd,
                        const String &amp;_Obd,    const String &amp;_Name,
                        const String &amp;_SpRazdName,
                        // свои
                        const int &amp;_icoID,        const String &amp;_FileName,    const String &amp;_FilePath,
                        const String &amp;_Creator,    const String &amp;_Updater,    const bool &amp;_Accept,
                        const TDateTime &amp;_DateOfCreate,    const TDateTime &amp;_DateOfUpdate);

    FileRow &amp; operator =    (const FileRow &amp;r);

    bool   operator ==(const FileRow &amp;r)const;
    bool   operator !=(const FileRow &amp;r)const;

    int Count(void)const{return count;};

    protected:

    int icoID;
    const int &amp;LUser;
    String FileName;
    String FilePath;
    String Creator;
    String Updater;
    bool Accept;
    TDateTime DateOfCreate;
    TDateTime DateOfUpdate;

    void init(void);
    void SetObd        (const String &amp;r);
    void SetId       (const int &amp;ID){id=ID;};
    private:

    static int  count;
    };
int     FileRow::count=0;
\#endif
</code>

@@FileRow.cpp
Description
Класс данных для хранения информации о файлах прикрепленных к
детали


C++ Syntax
<code lang="c++">



\#pragma hdrstop

\#include "FileRow.h"
\#pragma package(smart_init)



        FileRow::FileRow(cSQL *db,const int &amp;User):Obd(db),LUser(User)
{
count++;
init();
}
        FileRow::FileRow(const FileRow &amp;r):Obd(r),LUser(r.LUser)
{
count++;
icoID=r.icoID;
FileName=r.FileName;
FilePath=r.FilePath;
Creator=r.Creator;
Updater=r.Updater;
Accept=r.Accept;
DateOfCreate=r.DateOfCreate;
DateOfUpdate=r.DateOfUpdate;
}
        FileRow::~FileRow(void)
{
count--;
}
void     FileRow::init(void)
{
    //переменные
icoID=-1;
FileName="";
FilePath="";
Creator="";
Updater="";
Accept=false;
DateOfCreate=0;
DateOfUpdate=0;
}
bool     FileRow::UpdateVal (void)
{
String sql="call UpdateFileInfo('"+String(id)+"','"+FileName+"','"+String(LUser)+"')";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
        //базовые
    SetId(rez-\>FieldByName("id")-\>Value);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SetObd(rez-\>FieldByName("obd")-\>Value);
    Name=rez-\>FieldByName("namd")-\>Value;
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    // свои
    icoID=rez-\>FieldByName("icoID")-\>Value;
    FileName=rez-\>FieldByName("FileName")-\>Value;
    FilePath=rez-\>FieldByName("FilePath")-\>Value;
    Creator=rez-\>FieldByName("Creator")-\>Value;
    Updater=rez-\>FieldByName("Updater")-\>Value;
    Accept=rez-\>FieldByName("Accept")-\>Value;
    if (!rez-\>FieldByName("DateOfCreate")-\>Value.IsNull()){DateOfCreate=rez-\>FieldByName("DateOfCreate")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("DateOfUpdate")-\>Value.IsNull()){DateOfUpdate=rez-\>FieldByName("DateOfUpdate")-\>Value.operator TDateTime();}
    delete rez;
    }else
    {
    init();
    Obd::init();
    delete rez;
    }
return CanUse();
}
bool     FileRow::SetData    (//базовые
                        const int &amp;_id,        const int &amp;_SpRazd,
                        const String &amp;_Obd,    const String &amp;_Name,
                        const String &amp;_SpRazdName,
                        // свои
                        const int &amp;_icoID,        const String &amp;_FileName,    const String &amp;_FilePath,
                        const String &amp;_Creator,    const String &amp;_Updater,    const bool &amp;_Accept,
                        const TDateTime &amp;_DateOfCreate,    const TDateTime &amp;_DateOfUpdate
                        )
{
if (ItTrueClassName())
    {
    SetId(_id);
    SetObd(_Obd);
    SpRazd=_SpRazd;
    Name=_Name.Trim();
    SpRazdName=_SpRazdName.Trim();
    icoID=_icoID;
    FileName=_FileName.Trim();
    FilePath=_FilePath.Trim();
    Creator=_Creator.Trim();
    Updater=_Updater.Trim();
    Accept=_Accept;
    DateOfCreate=_DateOfCreate;
    DateOfUpdate=_DateOfUpdate;
    }
return CanUse();
}
FileRow &amp;     FileRow::operator =(const FileRow &amp;r)
{
if (this==&amp;r) {return *this;}
//базовые
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
// свои
icoID=r.icoID;
FileName=r.FileName;
FilePath=r.FilePath;
Creator=r.Creator;
Updater=r.Updater;
Accept=r.Accept;
DateOfCreate=r.DateOfCreate;
DateOfUpdate=r.DateOfUpdate;
return *this;
}
bool     FileRow::operator ==(const FileRow &amp;r)
{
if (this==&amp;r) {return true;}
if (
    //базовые
    id!=r.id&amp;&amp;
    SpRazd!=r.SpRazd&amp;&amp;
    G_Obd!=r.G_Obd&amp;&amp;
    V_Obd!=r.V_Obd&amp;&amp;
    Name!=r.Name&amp;&amp;
    SpRazdName!=r.SpRazdName&amp;&amp;
    // свои
    icoID!=r.icoID&amp;&amp;
    FileName!=r.FileName&amp;&amp;
    FilePath!=r.FilePath&amp;&amp;
    Creator!=r.Creator&amp;&amp;
    Updater!=r.Updater&amp;&amp;
    Accept!=r.Accept&amp;&amp;
    DateOfCreate!=r.DateOfCreate&amp;&amp;
    DateOfUpdate!=r.DateOfUpdate
    ){return false;}else{return true;}
}
bool     FileRow::operator !=(const FileRow &amp;r)
{
if (this==&amp;r) {return false;}
if (
    //базовые
    id!=r.id&amp;&amp;
    SpRazd!=r.SpRazd&amp;&amp;
    G_Obd!=r.G_Obd&amp;&amp;
    V_Obd!=r.V_Obd&amp;&amp;
    Name!=r.Name&amp;&amp;
    SpRazdName!=r.SpRazdName&amp;&amp;
    // свои
    icoID!=r.icoID&amp;&amp;
    FileName!=r.FileName&amp;&amp;
    FilePath!=r.FilePath&amp;&amp;
    Creator!=r.Creator&amp;&amp;
    Updater!=r.Updater&amp;&amp;
    Accept!=r.Accept&amp;&amp;
    DateOfCreate!=r.DateOfCreate&amp;&amp;
    DateOfUpdate!=r.DateOfUpdate
    ){return true;}else{return false;}
}
void     FileRow::SetObd        (const String &amp;r)
{
V_Obd=GostToVin(r);
G_Obd=VinToGost(r);
}
</code>

@@IconsData
Description
Класс - контейнер иконок, также хранит информацию о
расположении иконок в базе и программе и условии их
применения

@@IconsData::~IconsData
Description
Деструктор.
C++ Syntax
<code lang="c++">
IconsData::~IconsData(void)
{
delete IMGList;
delete StateList;
mass.clear();
}
</code>

@@IconsData::IconsData@TComponent*
Description
Конструктор.
C++ Syntax
<code lang="c++">
IconsData::IconsData(TComponent* Owner):isEmpty(true)
{
IMGList=new TImageList(Owner);
IMGList-\>Height=24;
IMGList-\>Width=24;
StateList=new TImageList(Owner);
StateList-\>Height=24;
StateList-\>Width=24;
mass.clear();
}
</code>

Type Parameters
Owner :  Указатель на компонент\-хозяин

@@IconsData::=@IconsData &
Description
Оператор присваивния. (use less)
C++ Syntax
<code lang="c++">
IconsData &amp; IconsData::operator = (const IconsData &amp;r)
{
if (this==&amp;r) {return *this;}
isEmpty=r.isEmpty;
mass=r.mass;
return *this;
}
</code>


Type Parameters
r :  Ссылка на копируемый объект этого класса

@@IconsData::IMGList
Description
Контейнер с общими иконками

@@IconsData::StateList
Description
Контейнер с иконками состояниями (есть ограничение по
количеству иконок - Маскимум 16 штук)

@@IconsData::GetInList@int@bool@int
Description
Функция возврата значения позиции иконки в контейнере по
данным из базы.
C++ Syntax
<code lang="c++">
int   IconsData::GetInList(int inbase, bool Accept, int type)
{
vector\<collation\>::iterator i;
for (i=mass.begin(); i!=mass.end(); i++)
    {
    if (i-\>inbase==inbase&amp;&amp;i-\>Accept==Accept&amp;&amp;i-\>type==type)
        {
        return i-\>InList;
        }
    }
return -1;
}
</code>
Type Parameters
inbase :  Идентификатор иконки в базе данных
Accept :  Инидактор доступа
type :    Тип иконки

@@IconsData::GetImgList
Description
Inline функия возвращает указатель на контейнер с иконками
общего назначения для прикрепления к другим классам
C++ Syntax
<code lang="c++">
TImageList * GetImgList (void)const {return IMGList;}
</code>

@@IconsData::GetStateList
Description
Inline функия возвращает указатель на контейнер с
иконками-состояниями для прикрепления к другим классам


C++ Syntax
<code lang="c++">
TImageList * GetStateList (void)const {return StateList;}
</code>

@@IconsData::LoadCollation@int@int@bool@int
Description
Функция запоминание позиций считанных иконок и их данных из
базы.


C++ Syntax
<code lang="c++">
void         IconsData::LoadCollation(int inbase, int InList, bool Accept, int type)
{
collation tmp;
if (GetInList(inbase,Accept,type)==-1)
    {
    tmp.inbase=inbase;
    tmp.InList=InList;
    tmp.Accept=Accept;
    tmp.type=type;
    mass.push_back(tmp);
    }else
    {
    vector\<collation\>::iterator i;
    for (i=mass.begin(); i!=mass.end(); i++)
        {
        if (i-\>inbase==inbase&amp;&amp;i-\>Accept==Accept&amp;&amp;i-\>type==type)
            {
            i-\>InList=InList;
            }
        }
    }
isEmpty=false;
}
</code>
Type Parameters
inbase :  Идентификатор иконки в базе данных
InList :  Порядковый номер в контейнере
Accept :  Индикатор доступности
type :    Тип иконки

@@IconsData.cpp
Description
\ \ 

Класс - контейнер иконок, также хранит информацию о
расположении иконок в базе и программе и условии их
применения (файл описания)
C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "IconsData.h"
\#pragma package(smart_init)

            IconsData::IconsData(TComponent* Owner):isEmpty(true)
{
IMGList=new TImageList(Owner);
IMGList-\>Height=24;
IMGList-\>Width=24;
StateList=new TImageList(Owner);
StateList-\>Height=24;
StateList-\>Width=24;
mass.clear();
}
            IconsData::~IconsData(void)
{
delete IMGList;
delete StateList;
mass.clear();
}
void         IconsData::LoadCollation(int inbase, int InList, bool Accept, int type)
{
collation tmp;
if (GetInList(inbase,Accept,type)==-1)
    {
    tmp.inbase=inbase;
    tmp.InList=InList;
    tmp.Accept=Accept;
    tmp.type=type;
    mass.push_back(tmp);
    }else
    {
    vector\<collation\>::iterator i;
    for (i=mass.begin(); i!=mass.end(); i++)
        {
        if (i-\>inbase==inbase&amp;&amp;i-\>Accept==Accept&amp;&amp;i-\>type==type)
            {
            i-\>InList=InList;
            }
        }
    }
isEmpty=false;
}
int         IconsData::GetInList(int inbase, bool Accept, int type)
{
vector\<collation\>::iterator i;
for (i=mass.begin(); i!=mass.end(); i++)
    {
    if (i-\>inbase==inbase&amp;&amp;i-\>Accept==Accept&amp;&amp;i-\>type==type)
        {
        return i-\>InList;
        }
    }
return -1;
}
IconsData &amp; IconsData::operator = (const IconsData &amp;r)
{
if (this==&amp;r) {return *this;}
isEmpty=r.isEmpty;
mass=r.mass;
return *this;
}
</code>

@@IconsData.h
Description
\ \ 

Класс - контейнер иконок, также хранит информацию о
расположении иконок в базе и программе и условии их
применения (файл заголовков)
C++ Syntax
<code lang="c++">
\#ifndef IconsDataH
\#define IconsDataH
\#include \<Controls.hpp\>
\#include "collation.h"
\#include "vector.h"

class IconsData
    {
    public:
    IconsData(TComponent* Owner);
    ~IconsData(void);
    void LoadCollation(int inbase, int InList, bool Accept, int type);
    int GetInList(int inbase, bool Accept, int type);
    TImageList * GetImgList (void)const {return IMGList;}
    TImageList * GetStateList (void)const {return StateList;}
    bool isEmpty;
    IconsData &amp; operator = (const IconsData &amp;r);
    private:
    TImageList *IMGList;
    TImageList *StateList;
    vector \<collation\> mass;
    };
\#endif
</code>

@@IconsData::isEmpty
\ \ 
Description
Логическая переменная, отражающая наполненность класса
сопоставлениями данных об иконках

@@IconsData::mass
\ \ 
Description
Массив данных - набор сопоставлений данных из базы с
позициями иконок в программе

@@Obd::Obd@Obd &
Description
Конструктор копировщик.
C++ Syntax
<code lang="c++">
Obd::Obd    (const Obd &amp;r):DB(r.DB)
{
count++;
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
}
</code>

@@Obd::Obd@cSQL *const
Description
Конструктор общего назначения, для инициализации дочерних
классов и временных переменных на базе класса или для задания
данных класса внешними средствани через функцию SetData
C++ Syntax
<code lang="c++">
Obd::Obd    (cSQL *const db):DB(db)
{
count++;
init();
}
</code>

Type Parameters
db :  Указатель на класс работы с базой данных

@@Obd::Obd@cSQL *const@String &
Description
Конструктор для заполения данных класса на основе заранее
известного обозначения детали
C++ Syntax
<code lang="c++">
Obd::Obd    (cSQL *const db,const String &amp;_obd):DB(db)
{
count++;
SetObd(_obd);
}
</code>

Type Parameters
db :    Указатель на класс работы с базой данных
_obd :  Обозначение узла/детали 

@@Obd::Obd@cSQL *const@int &
Description
Конструктор для заполения данных класса на основе заранее
известного иденитфкатора детали
C++ Syntax
<code lang="c++">
Obd::Obd    (cSQL *db,const int &amp;_id):DB(db)
{
count++;
SetId(_id);
}
</code>
Type Parameters
db :   Указатель на класс работы с базой данных
_id :  Идентификатор узла/детали

@@Obd::~Obd
\ \ 
Description
Деструктор
C++ Syntax
<code lang="c++">
Obd::~Obd    (void)
{
count--;
}
</code>

@@Obd::DB
Description
Указатель на класс для работы с базой данных

@@Obd::G_Obd
Description
Переменная, хранящая обозначение узла/детали в обычном
формате

@@Obd::id
Description
Переменная, хранящая идентификатор узла/детали

@@Obd::Name
Description
Переменная, хранящая наименование детали

@@Obd::SpRazd
Description
Переменная, хранящая идентификатор раздела спецификации
узла/детали

@@Obd::SpRazdName
Description
Переменная, хранящая название раздела спецификации
узла/детали

@@Obd::V_Obd
Переменная, хранаящая обозначение узла/детали в цифровом виде
(старая кодировка АСУ)

@@Obd::CanUse@const
Description
Виртуальная inline функция, определяющая может быть
использован текущий экземпляр класса или нет
C++ Syntax
<code lang="c++">
virtual bool CanUse (void) const
{
return (id\>0&amp;&amp;Get_Obd(false)!="")?true:false;
};
</code>
Return Value List
True :   Минимальный набор данных есть. Класс может
         использоваться
False :  Отсутствует минимальный набор данных. Класс
         использовать нельзя

@@Obd::Count@const
Description
Inline функция возвращающая количество существующих
экземпляров класса
C++ Syntax
<code>
int Count(void)const{return count;};
</code>

@@Obd::Get_ID@const
Description
Inline функция доступа. Возвращает идентификатор узла/детали
C++ Syntax
<code lang="c++">
int Get_ID (void)const
{
return id;
};
</code>

@@Obd::Get_Name@const
Description
Inline функция доступа. Возвращает наименование узла/детали
C++ Syntax
<code lang="c++">
String Get_Name (void) const
{
return Name;
};
</code>

@@Obd::Get_Obd@bool@const
Description
Inline функция доступа. Возвращает обозначение детали в
заданном формате
C++ Syntax
<code lang="c++">
String Get_Obd (bool gost) const
{
return gost?G_Obd:V_Obd;
};
</code>

Type Parameters
gost :  Индикатор выбора формата возвращаемого обозначения

@@Obd::Get_SpRazd@const
Description
Inline функция доступа. Возвращает идентификатор раздела
спецификации узла/детали
C++ Syntax
<code lang="c++">
int  Get_SpRazd (void)  const
{
return SpRazd;
};
</code>

@@Obd::Get_SpRazdName@const
Description
Inline функция доступа. Возвращает название раздела
спецификации узла/детали
C++ Syntax
<code lang="c++">
String Get_SpRazdName(void) const
{
return SpRazdName;
};
</code>

@@Obd::Get_Text@const
Description
Inline функция доступа. Возвращает текст для отображения
пользователю
C++ Syntax
<code lang="c++">
String Get_Text (void) const
{
return G_Obd+" - "+Name;
};
</code>

@@Obd::Get_Val@char
Description
Внутренняя функция для обновления/наполнения данных
экземпляра класса из базы данных
C++ Syntax
<code lang="c++">
bool     Obd::Get_Val (char type)
{
String sql="";
switch (type)
    {
    case 0:{sql="select a.id,trim(a.obd)as obd,trim(a.namd)as namd,a.razdSPID,b.Razdname
                 from constructions.det_names a left join administration.sprazd b on RazdID=razdSPID
                 where obd='"+V_Obd+"'";break;}
    case 1:{sql="select a.id,trim(a.obd)as obd,trim(a.namd)as namd,a.razdSPID,b.Razdname
                 from constructions.det_names a left join administration.sprazd b on RazdID=razdSPID
                 where id='"+String(id)+"'";break;}
    default:return false;
    }
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    Name=rez-\>FieldByName("namd")-\>Value;
    id=rez-\>FieldByName("id")-\>Value;
    V_Obd=GostToVin(rez-\>FieldByName("obd")-\>Value);
    G_Obd=VinToGost(V_Obd);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    delete rez;
    }else
    {
    init();
    delete rez;
    }
return CanUse();
}
</code>
Type Parameters
type :  Вариант обновления данных<p />0\: Обновление на основе
        идентификатора узла/детали<p />1\: Обновление на
        основе обозначения узла/детали

@@Obd::init
Description
Функция инициализирующая переменные класса на значения по
умолчанию
C++ Syntax
<code lang="c++">
void Obd::init (void)
{
id=-1;
SpRazd=-1;
G_Obd="";
V_Obd="";
Name="";
SpRazdName="";
}
</code>

@@Obd::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code>
bool ItTrueClassName (void)const
{
return TrueClassName()=="Obd"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@Obd::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code>
virtual String TrueClassName (void)const{return "Obd";};
</code>

@@Obd::SetData@int &@int &@String &@String &@String &
Description
Функция предназначенная для загрузки данных из вне.
Используется как второстепенный источник данных для класса.
C++ Syntax
<code lang="c++">
bool Obd::SetData (const int &amp;_id,const int &amp;_SpRazd,const String &amp;_Obd,
                   const String &amp;_Name,const String &amp;_SpRazdName)
{
if (ItTrueClassName())
    {
    id=_id;
    SpRazd=_SpRazd;
    G_Obd=VinToGost(_Obd);
    V_Obd=GostToVin(_Obd);
    Name=_Name.Trim();
    SpRazdName=_SpRazdName.Trim();
    }
return CanUse();
}
</code>

Type Parameters
_id :          Идентификатор узла/детали
_SpRazd :      Идентификатор раздела спецификации узла/детали
_Obd :         Обозначение узла/детали
_Name :        Наименование узла/детали
_SpRazdName :  Название раздела спецификации узла/детали

@@Obd::SetId@int &
Description
Функция для загрузки в класс данных об узле/детали с заранее
известным идентификатором
C++ Syntax
<code lang="c++">
bool Obd::SetId (const int &amp;ID)
{
if (ItTrueClassName())
    {
    id=ID;
    return Get_Val (1);
    }
return false;
}
</code>

Type Parameters
ID :  Ссылка на идентификатор загружаемой детали

@@Obd::SetObd@String &
Description
Функция для загрузки в класс данных об узле/детали с заранее
известным обозначением
C++ Syntax
<code lang="c++">
bool Obd::SetObd (const String &amp;r)
{
if (ItTrueClassName())
    {
    V_Obd=GostToVin(r);
    return Get_Val (0);
    }
return false;
}
</code>
Type Parameters
r :  ссылка на обозначение загружаемой детали

@@Obd::UpdateVal
Description
Функция для вызова обновления данных класса из вне
C++ Syntax
<code lang="c++">
bool UpdateVal (void)
{
return Get_Val(1);
};
</code>

@@Obd::=@Obd &
Description
Оператор присвоения
C++ Syntax
<code lang="c++">
Obd &amp;     Obd::operator =    (const Obd &amp;r)
{
if (this==&amp;r) {return *this;}
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
return *this;
}
</code>

@@Obd::==@Obd &
Description
Прямой оператор сравнения.
C++ Syntax
<code lang="c++">
bool     Obd::operator ==(const Obd &amp;r)
{
if (this==&amp;r) {return true;}
if (id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName)
    {
    return true;
    }
return false;
}
</code>

@@Obd::!=@Obd &
Description
Обратный оператор сравнения
C++ Syntax
<code lang="c++">
bool     Obd::operator !=(const Obd &amp;r)
{
if (this==&amp;r) {return false;}
if (id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName)
    {
    return false;
    }
return true;
}
</code>

@@Obd
Description
Класс данных, несущий основную краткую информацию о детали.

Используется самостоятельно, как транспортный и для привязки
более детальных классов данных (его потомков) к контейнерам
визуальных элементов и массивам

@@Obd.h
Description
Класс данных, несущий основную краткую информацию о детали.

Используется самостоятельно, как транспортный и для привязки
более детальных классов данных (его потомков) к контейнерам
визуальных элементов и массивам

(файл заголовков)
C++ Syntax
<code lang="c++">


\#ifndef ObdH
\#define ObdH
\#include "SQL.h"
\#include "functions.h"


class Obd
    {
    public:

           Obd(cSQL *const db);
        Obd(cSQL *const db,const String &amp;_obd);
        Obd(cSQL *const db,const int &amp;_id);
        Obd(const Obd &amp;);
        virtual~Obd(void);

        String    Get_Obd        (bool gost)    const{return gost?G_Obd:V_Obd;};
        String    Get_Text    (void)        const{return G_Obd+" - "+Name;};
        String    Get_Name    (void)        const{return Name;};
        String     Get_SpRazdName(void)    const{return SpRazdName;};
        int     Get_SpRazd    (void)      const{return SpRazd;};
        int        Get_ID        (void)        const{return id;};
        bool     UpdateVal     (void)            {return Get_Val(1);};

        bool    SetObd    (const String &amp;r);
        bool    SetId    (const int &amp;ID);
        bool     SetData (const int &amp;_id,const int &amp;_SpRazd,
                          const String &amp;_Obd,const String &amp;_Name,
                          const String &amp;_SpRazdName);

        Obd &amp;     operator =    (const Obd &amp;);
        bool     operator ==    (const Obd &amp;);
        bool     operator !=    (const Obd &amp;);
        int    Count    (void)const{return count;};

        bool ItTrueClassName (void)const{return TrueClassName()=="Obd"?true:false;};
        virtual String TrueClassName (void)const{return "Obd";};
        virtual bool CanUse    (void)        const{return (id\>0&amp;&amp;Get_Obd(false)!="")?true:false;};
    protected:

        int    id;
        int    SpRazd;
        String G_Obd;
        String V_Obd;
        String Name;
        String SpRazdName;

        cSQL *const DB;

        void init (void);
    private:

        static int  count;
        bool     Get_Val     (char type);
    };
int Obd::count=0;
\#endif

</code>

@@Obd.cpp
Description
Класс данных, несущий основную краткую информацию о детали.

Используется самостоятельно, как транспортный и для привязки
более детальных классов данных (его потомков) к контейнерам
визуальных элементов и массивам

(файл описаний)


C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "Obd.h"
\#pragma package(smart_init)

        Obd::Obd    (cSQL *const db):DB(db)
{
count++;
init();
}
        Obd::Obd    (cSQL *const db,const String &amp;_obd):DB(db)
{
count++;
SetObd(_obd);
}
        Obd::Obd    (cSQL *db,const int &amp;_id):DB(db)
{
count++;
SetId(_id);
}
        Obd::Obd    (const Obd &amp;r):DB(r.DB)
{
count++;
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
}
        Obd::~Obd    (void)
{
count--;
}


Obd &amp;     Obd::operator =    (const Obd &amp;r)
{
if (this==&amp;r) {return *this;}
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
return *this;
}
bool     Obd::operator ==(const Obd &amp;r)
{
if (this==&amp;r) {return true;}
if (id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName)
    {
    return true;
    }
return false;
}
bool     Obd::operator !=(const Obd &amp;r)
{
if (this==&amp;r) {return false;}
if (id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName)
    {
    return false;
    }
return true;
}


void     Obd::init         (void)
{
id=-1;
SpRazd=-1;
G_Obd="";
V_Obd="";
Name="";
SpRazdName="";
}
bool     Obd::Get_Val (char type)
{
String sql="";
switch (type)
    {
    case 0:{sql="select a.id,trim(a.obd)as obd,trim(a.namd)as namd,a.razdSPID,b.Razdname from det_names a left join sprazd b on RazdID=razdSPID where obd='"+V_Obd+"'";break;}
    case 1:{sql="select a.id,trim(a.obd)as obd,trim(a.namd)as namd,a.razdSPID,b.Razdname from det_names a left join sprazd b on RazdID=razdSPID where id='"+String(id)+"'";break;}
    default:return false;
    }
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    Name=rez-\>FieldByName("namd")-\>Value;
    id=rez-\>FieldByName("id")-\>Value;
    V_Obd=GostToVin(rez-\>FieldByName("obd")-\>Value);
    G_Obd=VinToGost(V_Obd);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    delete rez;
    }else
    {
    init();
    delete rez;
    }
return CanUse();
}


bool       Obd::SetObd        (const String &amp;r)
{
if (ItTrueClassName())
    {
    V_Obd=GostToVin(r);
    return Get_Val (0);
    }
return false;
}
bool      Obd::SetId       (const int &amp;ID)
{
if (ItTrueClassName())
    {
    id=ID;
    return Get_Val (1);
    }
return false;
}
bool     Obd::SetData     (const int &amp;_id,const int &amp;_SpRazd,const String &amp;_Obd,const String &amp;_Name,const String &amp;_SpRazdName)
{
if (ItTrueClassName())
    {
    id=_id;
    SpRazd=_SpRazd;
    G_Obd=VinToGost(_Obd);
    V_Obd=GostToVin(_Obd);
    Name=_Name.Trim();
    SpRazdName=_SpRazdName.Trim();
    }
return CanUse();
}

</code>

@@AutoWidthSG@TStringGrid *
Description
Функция автоматического расчета и назначения ширины колонки
для сетки
C++ Syntax
<code lang="c++">
void AutoWidthSG(TStringGrid *sg)
{
int i,j,NewWidth;
for (i = 0; i \<sg-\>ColCount; i++)
    {
    sg-\>ColWidths[i]=sg-\>DefaultColWidth;
    for (j=0; j \<sg-\>RowCount; j++)
        {
        sg-\>Canvas-\>Font-\>Charset=sg-\>Font-\>Charset;
        sg-\>Canvas-\>Font-\>Color=sg-\>Font-\>Color;
        sg-\>Canvas-\>Font-\>Height=sg-\>Font-\>Height;
        sg-\>Canvas-\>Font-\>Name=sg-\>Font-\>Name;
        sg-\>Canvas-\>Font-\>Orientation=sg-\>Font-\>Orientation;
        sg-\>Canvas-\>Font-\>Pitch=sg-\>Font-\>Pitch;
        sg-\>Canvas-\>Font-\>Quality=sg-\>Font-\>Quality;
        sg-\>Canvas-\>Font-\>Size=sg-\>Font-\>Size;
        sg-\>Canvas-\>Font-\>Style=sg-\>Font-\>Style;
        NewWidth=sg-\>Canvas-\>TextWidth(sg-\>Cells[i][j])+5;
        if (sg-\>ColWidths[i]\<NewWidth&amp;&amp;NewWidth\>sg-\>DefaultColWidth)
            {sg-\>ColWidths[i]=NewWidth;}
        if (i&amp;&amp;sg-\>ColWidths[i]\<40)
            {sg-\>ColWidths[i]=40;}//минимальный размерчик под комбо
        }
    }
}
</code>

Type Parameters
sg :  Указатель на объект сетки

@@change@T &@T &
Description
Функция-шаблон для замены переменных местами
C++ Syntax
<code lang="c++">
template\<typename T\>
void change (T &amp;el1,T &amp;el2)
{
   int temp=el1;
    el1=el2;
    el2=temp;
}
</code>
Type Parameters
el1 :  ссылка на первую переменную типа <c>T</c>
el2 :  ссылка на вторую переменную типа <c>T</c>

@@DeleteDir@AnsiString
Description
Функция для удаления директории (папки)
C++ Syntax
<code lang="c++">
bool DeleteDir(AnsiString DirName)
{
TSearchRec sr;
if (DirName.Length())
 {
 if (!FindFirst(DirName+"\\\\*.*",faAnyFile,sr))
 do
  {
  if (!(sr.Name=="." || sr.Name==".."))// это удалять не надо
   if (((sr.Attr &amp; faDirectory) == faDirectory ) ||
   (sr.Attr == faDirectory))// найдена папка
    {
    FileSetAttr(DirName+"\\\\"+sr.Name, faDirectory );// сброс всяких read-only
    DeleteDir(DirName+"\\\\"+sr.Name);//рекурсивно удаляем содержимое
    RemoveDir(DirName + "\\\\"+sr.Name);// удаляем теперь уже пустую папку
    }
    else// иначе найден файл
    {
    FileSetAttr(DirName+"\\\\"+sr.Name, 0);// сброс всяких read-only
    DeleteFile(DirName+"\\\\"+sr.Name);// удаляем файл
    }
  }
 while (!FindNext(sr));// ищем опять, пока не найдем все
 FindClose(sr);
 }
RemoveDir(DirName);
return true;
}
</code>
Type Parameters
DirName :  путь к удаляемой директории

@@ekran@String
Description
Функция для экранирования строковых значений передаваемых в
базу
C++ Syntax
<code lang="c++">
String ekran (String inpstr)
{
int i;
for (i = 1; i\<=inpstr.Length(); i++)
    {
    if (inpstr.operator [](i)=='\\\\'||
        inpstr.operator [](i)=='\\`'||
        inpstr.operator [](i)=='\\"'||
        inpstr.operator [](i)=='\\''/*||
        inpstr.operator [](i)=='\\%'*/)
        {
         inpstr.Insert("\\\\",i);
         i++;
        }
    /*if (inpstr.operator [](i)==',')
        {
         inpstr.Delete(i,1);
         inpstr.Insert(".",i);
         i++;
        } */
    }
return inpstr;
}
</code>
Type Parameters
inpstr :  Экранируемая строка

@@GetDirName
Description
Функция для генерации названия папки
C++ Syntax
<code lang="c++">
String GetDirName (void)
{
randomize();
String part="";
int i,level=random(10);
for (i=0; i \<= level; i++)
{
part=part+IntToStr(random(40))+"\\\\";
}
return part;
}
</code>

@@GetFileName
Description
Функция для генерации имени файла
C++ Syntax
<code lang="c++">
String GetFileName (void)
{
randomize();
String name=IntToStr(random(99999999))+".bdf";
return name;
}
</code>

@@GetGostNum@String
Description
Функция возвращающая все цифры из обозначения узла/детали до
первой буквы.
C++ Syntax
<code lang="c++">
String GetGostNum(String st)
{
int i;
for (i = 1; i \<=st.Length(); i++)
    {
    if (!isdigit(st[i]))
        {
        if (ischar(st[i]))
            {
            return st.SubString(1,i-1);
            }
        st.Delete(i,1);
        i--;
        }
    }
return st;
}
</code>

Type Parameters
st :  Строка обозначения

@@GetOnlyNum@String
Description
Функция сканирующая строку и возвращающая только цыфры из нее
C++ Syntax
<code lang="c++">
String GetOnlyNum(String st)
{
int i;
for (i = 1; i \<=st.Length(); i++)
    {
    if (!isdigit(st[i]))
        {
        st.Delete(i,1);
        i--;
        }
    }
return st;
}
</code>

Type Parameters
st :  Строка

@@GostToInt@AnsiString
Description
Функция преобразующая обозначения формата ГОСТ в строку чисел
C++ Syntax
<code lang="c++">
String GostToInt(AnsiString Gost)
{
String tmp=Gost;
Gost=Replace(Gost," ","");    // показывает может ли отсутствовать исполнение в обозначении
if (Trim(Gost)==""){return "";} else
    {
    if (Gost.UpperCase().Pos("ПЕШК"))
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ПЕШК"),Gost.Length()-Gost.UpperCase().Pos("ПЕШК")+1);
        Gost.Insert("97",Gost.UpperCase().Pos("ПЕШК"));
        Gost.Delete(Gost.UpperCase().Pos("ПЕШК"),4);
        }
    if (Gost.UpperCase().Pos("ГКНЮ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ГКНЮ"),Gost.Length()-Gost.UpperCase().Pos("ГКНЮ")+1);
        Gost.Insert("95",Gost.UpperCase().Pos("ГКНЮ"));   //находим в строке буквенное обозначение и меняем на цифровое
        Gost.Delete(Gost.UpperCase().Pos("ГКНЮ"),4);
        }
    if (Gost.UpperCase().Pos("НАЦВ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НАЦВ"),Gost.Length()-Gost.UpperCase().Pos("НАЦВ")+1);
        Gost.Insert("85",Gost.UpperCase().Pos("НАЦВ"));
        Gost.Delete(Gost.UpperCase().Pos("НАЦВ"),4);
        }
    if (Gost.UpperCase().Pos("НЕИА")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НЕИА"),Gost.Length()-Gost.UpperCase().Pos("НЕИА")+1);
        Gost.Insert("98",Gost.UpperCase().Pos("НЕИА"));
        Gost.Delete(Gost.UpperCase().Pos("НЕИА"),4);
        }
    if (!isdigit(Gost[1]))
        {
        return tmp;
        }
    Gost=GetGostNum(Gost);
    return Gost;
    }
}
</code>

Type Parameters
Gost :  Обозначение узла/детали в нормальной форме

@@GostToVin@AnsiString
Description
Функция преобразующая обозначение Формата ГОСТ в 15ти значный
цифровой код
C++ Syntax
<code lang="c++">
String GostToVin(AnsiString Gost)
{
String tmp=Gost;
Gost=Replace(Gost," ","");
bool isp=false;    // показывает может ли отсутствовать исполнение в обозначении
if (Trim(Gost)==""){return "";} else
    {
    if (Gost.UpperCase().Pos("ПЕШК"))
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ПЕШК"),Gost.Length()-Gost.UpperCase().Pos("ПЕШК"));
        Gost.Insert("97",Gost.UpperCase().Pos("ПЕШК"));
        Gost.Delete(Gost.UpperCase().Pos("ПЕШК"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("ГКНЮ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ГКНЮ"),Gost.Length()-Gost.UpperCase().Pos("ГКНЮ"));
        Gost.Insert("95",Gost.UpperCase().Pos("ГКНЮ"));   //находим в строке буквенное обозначение и меняем на цифровое
        Gost.Delete(Gost.UpperCase().Pos("ГКНЮ"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("НАЦВ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НАЦВ"),Gost.Length()-Gost.UpperCase().Pos("НАЦВ"));
        Gost.Insert("85",Gost.UpperCase().Pos("НАЦВ"));
        Gost.Delete(Gost.UpperCase().Pos("НАЦВ"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("НЕИА")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НЕИА"),Gost.Length()-Gost.UpperCase().Pos("НЕИА"));
        Gost.Insert("98",Gost.UpperCase().Pos("НЕИА"));
        Gost.Delete(Gost.UpperCase().Pos("НЕИА"),4);
        isp=true;
        }
    if (!isdigit(Gost[1]))
        {
        return tmp;
        }
    Gost=GetGostNum(Gost);
    Gost=Gost.SubString(1,15);
    if (Gost.Length()\<=15&amp;&amp;Gost.Length()\>5)
        {
        if (isp)
            {
            while (Gost.Length()\<15)
                {Gost=Gost+"0";}     // если в обозначении отсутствует номер исполнения(нулевое исполнение) то добиваем конец нулями
            }else
            {
            while (Gost.Length()\<15)
                {Gost="0"+Gost;}     // если трока меньше 15 символов добиваем нулями (случай с обозначением стандартных или покупных изделий)
            }
        } else return tmp;
    }
 return Gost;
}
</code>

Type Parameters
Gost :  Обозначение узла/детали в нормальной форме

@@increment@long@long
Description
Функция для расчета коэффициентов для сортировки шелла
C++ Syntax
<code lang="c++">
int increment(long inc[], long size)
{
int p1, p2, p3, s;
p1 = p2 = p3 = 1;
s = -1;
do
    {
    if (++s % 2)
        {
        inc[s] = 8*p1 - 6*p2 + 1;
        } else
        {
        inc[s] = 9*p1 - 9*p3 + 1;
        p2 *= 2;
        p3 *= 2;
        }
    p1 *= 2;
    }
while(3*inc[s] \< size);
return s \> 0 ? --s : 0;
}
</code>
Type Parameters
inc :   массив
size :  размер массива

@@insertSort@T@long
Description
Сортировка вставками
C++ Syntax
<code lang="c++">
template\<typename T\>
void insertSort (T a[], long size)
{
\long prev,curr;
for (curr=1; curr \< size; curr++)
    {
    for (prev=curr-1; (prev\>=0)&amp;&amp;(a[prev]\>a[prev+1]); prev--)
        {
        change(a[prev+1],a[prev]);
        }
    }

}
</code>
Type Parameters
a :     Массив типа Т
size :  Размер масссива

@@ischar@char
Description
функция проверки принадлежности символа к буквам
C++ Syntax
<code lang="c++">
bool   ischar (const char ch)
{
String str="йцукенгшщзхъфывапролджэячсмитьбюёqwertyuiopasdfghjklzxcvbnm";
if (str.Pos(LowerCase(ch)))
    {
    return true;
    }else
    {
    return false;
    }
}
</code>
Type Parameters
ch :  Символ для проверки

Return Value List
True :   Символ является буквой
False :  Символ не является буквой

@@isdigit@char
Description
функция проверки принадлежности символа к цифрам
C++ Syntax
<code lang="c++">
bool   isdigit(const char ch)
{
String str="0123456789";
if (str.Pos(LowerCase(ch)))
    {
    return true;
    }else
    {
    return false;
    }
}
</code>
Return Value List
True :   Символ является цифрой
False :  Символ не является цифрой

Type Parameters
ch :  Проверяемый символ

@@MkPjDir@String@String
Description
Функция для создания папки с указанным адресом
C++ Syntax
<code lang="c++">
void MkPjDir(String subpart,String part)
{
String newfold,fold="";
while (subpart.Pos("\\\\")!=0)
    {
    newfold=subpart.SubString(1,subpart.Pos("\\\\"));
    subpart.Delete(1,subpart.Pos("\\\\"));
    MkDir(part+fold+newfold);
    fold=fold+newfold;
    }
}
</code>
Type Parameters
subpart :  Кусок адреской строки который нужно воспроизвести
part :     Точка отправления для начала создания цепочек
           папок(корневой каталог)

@@Replace@String@String@String
Description
Функция замены одной комбинации символов на другую
C++ Syntax
<code lang="c++">
String Replace (String st,String Old,String New)
{
int i;
String sub;
for (i=1; i \<=st.Length(); i++)
    {
    sub=st.SubString(i,Old.Length());
    if (sub==Old)
        {
        st.Delete(i,Old.Length());
        st.Insert(New,i);
        i+=New.Length()-1;
        }
    }
return st;
}
</code>
Type Parameters
st :   Исходная строка
Old :  Старый набор символов
New :  Новый набор символов

@@SGClear@TStringGrid *@int
Description
Функция для очистки сетки
C++ Syntax
<code lang="c++">
void SGClear (TStringGrid *SG,int RightOfset)
{
int i,j;
for (i = SG-\>FixedRows; i \< SG-\>RowCount; i++)
    {
    for (j=0; j \< SG-\>ColCount+RightOfset; j++)
        {
        SG-\>Cells[j][i]="";
        }
    }
SG-\>RowCount=2;
}
</code>
Type Parameters
SG :          Указатель на очищаемую сетку
RightOfset :  Количество столбцов правее правого столбца
              сетки(невидимые), которые очищаются
              дополнительно

@@shellSort@T@long
Description
Сортировка Шелла
C++ Syntax
<code lang="c++">
template\<typename T\>
void shellSort(T a[], long size)
{
\long inc,i,j,seq[40];
/*for (i = 0; i \< 40; i++)
    {
    seq[i]=0;
    } */
int s;
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        for (j = i-inc; (j \>= 0) &amp;&amp; (a[j] \> a[j+inc]); j -= inc)
            {
            change(a[j+inc],a[j]);
            }
        }
    }
}
</code>
Type Parameters
a :     Массив типа Т
size :  Размер массива

@@VinToGost@String
Description
Функция преобразования циферного обозначения в буквенное
C++ Syntax
<code lang="c++">
String VinToGost (String Vin)
{
if (Vin.Length()!=15||GetOnlyNum(Vin).Length()!=Vin.Length()) {return Vin;}
if (Vin.SubString(1,6)=="000000")
    {
    while (Vin[1]=='0'&amp;&amp;Vin.Length()\>6)
        {
        Vin.Delete(1,1);
        }
    return Vin;
    }
String s1,s2,s3,s4,s5,s6,s7;
int type=0;
if (Trim(Vin)==""){return "";}
s1=Vin.SubString(1,2);
s2=Vin.SubString(3,1);
s3=Vin.SubString(4,3);
s4=Vin.SubString(7,2);
s5=Vin.SubString(9,2);
s6=Vin.SubString(11,3);
s7=Vin.SubString(14,2);
if (s1=="85") {s1="НАЦВ";type=1;}
if (s1=="95") {s1="ГКНЮ";type=1;}
if (s1=="97") {s1="ПЕШК";type=1;}
if (s1=="98") {s1="НЕИА";type=1;}
switch (type)
    {
    case 0:{return s1+s2+"."+s3+"."+s4+"."+s5+"."+s6+"-"+s7;}
    case 1:{return s1+"."+s2+"."+s3+"."+s4+"."+s5+"."+s6+"-"+s7;}
default: return Vin;
    }
}
</code>
Type Parameters
Vin :  15ти значное циферное обозначение

@@functions.cpp
Description
Файл реализации функций
C++ Syntax
<code lang="c++">
\#pragma hdrstop
\#include "functions.h"

\#pragma package(smart_init)

void MkPjDir(String subpart,String part)
{
String newfold,fold="";
while (subpart.Pos("\\\\")!=0)
    {
    newfold=subpart.SubString(1,subpart.Pos("\\\\"));
    subpart.Delete(1,subpart.Pos("\\\\"));
    MkDir(part+fold+newfold);
    fold=fold+newfold;
    }
}
String GetDirName (void)
{
randomize();
String part="";
int i,level=random(10);
for (i=0; i \<= level; i++)
{
part=part+IntToStr(random(40))+"\\\\";
}
return part;
}
String GetFileName (void)
{
randomize();
String name=IntToStr(random(99999999))+".bdf";
return name;
}
bool DeleteDir(AnsiString DirName)
{
TSearchRec sr;
if (DirName.Length())
 {
 if (!FindFirst(DirName+"\\\\*.*",faAnyFile,sr))
 do
  {
  if (!(sr.Name=="." || sr.Name==".."))// это удалять не надо
   if (((sr.Attr &amp; faDirectory) == faDirectory ) ||
   (sr.Attr == faDirectory))// найдена папка
    {
    FileSetAttr(DirName+"\\\\"+sr.Name, faDirectory );// сброс всяких read-only
    DeleteDir(DirName+"\\\\"+sr.Name);//рекурсивно удаляем содержимое
    RemoveDir(DirName + "\\\\"+sr.Name);// удаляем теперь уже пустую папку
    }
    else// иначе найден файл
    {
    FileSetAttr(DirName+"\\\\"+sr.Name, 0);// сброс всяких read-only
    DeleteFile(DirName+"\\\\"+sr.Name);// удаляем файл
    }
  }
 while (!FindNext(sr));// ищем опять, пока не найдем все
 FindClose(sr);
 }
RemoveDir(DirName);
return true;
}

String ekran (String inpstr)
{
int i;
for (i = 1; i\<=inpstr.Length(); i++)
    {
    if (inpstr.operator [](i)=='\\\\'||
        inpstr.operator [](i)=='\\`'||
        inpstr.operator [](i)=='\\"'||
        inpstr.operator [](i)=='\\''/*||
        inpstr.operator [](i)=='\\%'*/)
        {
         inpstr.Insert("\\\\",i);
         i++;
        }
    /*if (inpstr.operator [](i)==',')
        {
         inpstr.Delete(i,1);
         inpstr.Insert(".",i);
         i++;
        } */
    }
return inpstr;
}
String Replace (String st,String Old,String New)
{
int i;
String sub;
for (i=1; i \<st.Length(); i++)
    {
    sub=st.SubString(i,Old.Length());
    if (sub==Old)
        {
        st.Delete(i,Old.Length());
        st.Insert(New,i);
        i+=New.Length()-1;
        }
    }
return st;
}
String GetOnlyNum(String st)
{
int i;
for (i = 1; i \<=st.Length(); i++)
    {
    if (!isdigit(st[i]))
        {
        st.Delete(i,1);
        i--;
        }
    }
return st;
}
bool   ischar (const char ch)
{
String str="йцукенгшщзхъфывапролджэячсмитьбюёqwertyuiopasdfghjklzxcvbnm";
if (str.Pos(LowerCase(ch)))
    {
    return true;
    }else
    {
    return false;
    }
}
bool   isdigit(const char ch)
{
String str="0123456789";
if (str.Pos(LowerCase(ch)))
    {
    return true;
    }else
    {
    return false;
    }
}

String GostToVin(AnsiString Gost)
{
String tmp=Gost;
Gost=Replace(Gost," ","");
bool isp=false;    // показывает может ли отсутствовать исполнение в обозначении
if (Trim(Gost)==""){return "";} else
    {
    if (Gost.UpperCase().Pos("ПЕШК"))
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ПЕШК"),Gost.Length()-Gost.UpperCase().Pos("ПЕШК"));
        Gost.Insert("97",Gost.UpperCase().Pos("ПЕШК"));
        Gost.Delete(Gost.UpperCase().Pos("ПЕШК"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("ГКНЮ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ГКНЮ"),Gost.Length()-Gost.UpperCase().Pos("ГКНЮ"));
        Gost.Insert("95",Gost.UpperCase().Pos("ГКНЮ"));   //находим в строке буквенное обозначение и меняем на цифровое
        Gost.Delete(Gost.UpperCase().Pos("ГКНЮ"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("НАЦВ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НАЦВ"),Gost.Length()-Gost.UpperCase().Pos("НАЦВ"));
        Gost.Insert("85",Gost.UpperCase().Pos("НАЦВ"));
        Gost.Delete(Gost.UpperCase().Pos("НАЦВ"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("НЕИА")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НЕИА"),Gost.Length()-Gost.UpperCase().Pos("НЕИА"));
        Gost.Insert("98",Gost.UpperCase().Pos("НЕИА"));
        Gost.Delete(Gost.UpperCase().Pos("НЕИА"),4);
        isp=true;
        }
    if (!isdigit(Gost[1]))
        {
        return tmp;
        }
    Gost=GetGostNum(Gost);
    Gost=Gost.SubString(1,15);
    if (Gost.Length()\<=15&amp;&amp;Gost.Length()\>5)
        {
        if (isp)
            {
            while (Gost.Length()\<15)
                {Gost=Gost+"0";}     // если в обозначении отсутствует номер исполнения(нулевое исполнение) то добиваем конец нулями
            }else
            {
            while (Gost.Length()\<15)
                {Gost="0"+Gost;}     // если трока меньше 15 символов добиваем нулями (случай с обозначением стандартных или покупных изделий)
            }
        } else return tmp;
    }
 return Gost;
}
String GostToInt(AnsiString Gost)
{
String tmp=Gost;
Gost=Replace(Gost," ","");
bool isp=false;    // показывает может ли отсутствовать исполнение в обозначении
if (Trim(Gost)==""){return "";} else
    {
    if (Gost.UpperCase().Pos("ПЕШК"))
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ПЕШК"),Gost.Length()-Gost.UpperCase().Pos("ПЕШК"));
        Gost.Insert("97",Gost.UpperCase().Pos("ПЕШК"));
        Gost.Delete(Gost.UpperCase().Pos("ПЕШК"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("ГКНЮ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("ГКНЮ"),Gost.Length()-Gost.UpperCase().Pos("ГКНЮ"));
        Gost.Insert("95",Gost.UpperCase().Pos("ГКНЮ"));   //находим в строке буквенное обозначение и меняем на цифровое
        Gost.Delete(Gost.UpperCase().Pos("ГКНЮ"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("НАЦВ")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НАЦВ"),Gost.Length()-Gost.UpperCase().Pos("НАЦВ"));
        Gost.Insert("85",Gost.UpperCase().Pos("НАЦВ"));
        Gost.Delete(Gost.UpperCase().Pos("НАЦВ"),4);
        isp=true;
        }
    if (Gost.UpperCase().Pos("НЕИА")!=0)
        {
        Gost=Gost.SubString(Gost.UpperCase().Pos("НЕИА"),Gost.Length()-Gost.UpperCase().Pos("НЕИА"));
        Gost.Insert("98",Gost.UpperCase().Pos("НЕИА"));
        Gost.Delete(Gost.UpperCase().Pos("НЕИА"),4);
        isp=true;
        }
    if (!isdigit(Gost[1]))
        {
        return tmp;
        }
    Gost=GetGostNum(Gost);
    return Gost;
    }
}
String GetGostNum(String st)
{
int i;
for (i = 1; i \<=st.Length(); i++)
    {
    if (!isdigit(st[i]))
        {
        if (ischar(st[i]))
            {
            return st.SubString(1,i-1);
            }
        st.Delete(i,1);
        i--;
        }
    }
return st;
}
String VinToGost (String Vin)
{
if (Vin.Length()!=15||GetOnlyNum(Vin).Length()!=Vin.Length()) {return Vin;}
if (Vin.SubString(1,6)=="000000")
    {
    while (Vin[1]=='0'&amp;&amp;Vin.Length()\>=6)
        {
        Vin.Delete(1,1);
        }
    return Vin;
    }
String s1,s2,s3,s4,s5,s6,s7;
int type=0;
if (Trim(Vin)==""){return "";}
s1=Vin.SubString(1,2);
s2=Vin.SubString(3,1);
s3=Vin.SubString(4,3);
s4=Vin.SubString(7,2);
s5=Vin.SubString(9,2);
s6=Vin.SubString(11,3);
s7=Vin.SubString(14,2);
if (s1=="85") {s1="НАЦВ";type=1;}
if (s1=="95") {s1="ГКНЮ";type=1;}
if (s1=="97") {s1="ПЕШК";type=1;}
if (s1=="98") {s1="НЕИА";type=1;}
switch (type)
    {
    case 0:{return s1+s2+"."+s3+"."+s4+"."+s5+"."+s6+"-"+s7;}
    case 1:{return s1+"."+s2+"."+s3+"."+s4+"."+s5+"."+s6+"-"+s7;}
default: return Vin;
    }
}

void AutoWidthSG(TStringGrid *sg)
{
int i,j,NewWidth;
for (i = 0; i \<sg-\>ColCount; i++)
    {
    sg-\>ColWidths[i]=sg-\>DefaultColWidth;
    for (j=0; j \<sg-\>RowCount; j++)
        {
        sg-\>Canvas-\>Font-\>Charset=sg-\>Font-\>Charset;
        sg-\>Canvas-\>Font-\>Color=sg-\>Font-\>Color;
        sg-\>Canvas-\>Font-\>Height=sg-\>Font-\>Height;
        sg-\>Canvas-\>Font-\>Name=sg-\>Font-\>Name;
        sg-\>Canvas-\>Font-\>Orientation=sg-\>Font-\>Orientation;
        sg-\>Canvas-\>Font-\>Pitch=sg-\>Font-\>Pitch;
        sg-\>Canvas-\>Font-\>Quality=sg-\>Font-\>Quality;
        sg-\>Canvas-\>Font-\>Size=sg-\>Font-\>Size;
        sg-\>Canvas-\>Font-\>Style=sg-\>Font-\>Style;
        NewWidth=sg-\>Canvas-\>TextWidth(sg-\>Cells[i][j])+5;
        if (sg-\>ColWidths[i]\<NewWidth&amp;&amp;NewWidth\>sg-\>DefaultColWidth)
            {sg-\>ColWidths[i]=NewWidth;}
        if (i&amp;&amp;sg-\>ColWidths[i]\<40)
            {sg-\>ColWidths[i]=40;}//минимальный размерчик под комбо
        }
    }
}
void SGClear (TStringGrid *SG,int RightOfset)
{
int i,j;
for (i = SG-\>FixedRows; i \< SG-\>RowCount; i++)
    {
    for (j=0; j \< SG-\>ColCount+RightOfset; j++)
        {
        SG-\>Cells[j][i]="";
        }
    }
SG-\>RowCount=2;
}

template\<typename T\>
void shellSort(T a[], long size)
{
\long inc,i,j,seq[40];
/*for (i = 0; i \< 40; i++)
    {
    seq[i]=0;
    } */
int s;
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        for (j = i-inc; (j \>= 0) &amp;&amp; (a[j] \> a[j+inc]); j -= inc)
            {
            change(a[j+inc],a[j]);
            }
        }
    }
}
int increment(long inc[], long size)
{
int p1, p2, p3, s;
p1 = p2 = p3 = 1;
s = -1;
do
    {
    if (++s % 2)
        {
        inc[s] = 8*p1 - 6*p2 + 1;
        } else
        {
        inc[s] = 9*p1 - 9*p3 + 1;
        p2 *= 2;
        p3 *= 2;
        }
    p1 *= 2;
    }
while(3*inc[s] \< size);
return s \> 0 ? --s : 0;
}
template\<typename T\>
void change (T &amp;el1,T &amp;el2)
{
   int temp=el1;
    el1=el2;
    el2=temp;
}

template\<typename T\>
void insertSort (T a[], long size)
{
\long prev,curr;
for (curr=1; curr \< size; curr++)
    {
    for (prev=curr-1; (prev\>=0)&amp;&amp;(a[prev]\>a[prev+1]); prev--)
        {
        change(a[prev+1],a[prev]);
        }
    }

}


</code>

@@functions.h
Description
Файл описания функций
C++ Syntax
<code lang="c++">


\#ifndef functionsH
\#define functionsH
\#include \<Controls.hpp\>
\#include \<StdCtrls.hpp\>
\#include \<Grids.hpp\>

void MkPjDir(String subpart,String part);
String GetDirName (void);
String GetFileName (void);
bool  DeleteDir(AnsiString DirName);

String ekran (String inpstr);
String Replace (String st,String Old,String New);
String GetOnlyNum(String st);
bool   ischar (const char ch);
bool   isdigit(const char ch);

String GostToVin(AnsiString Gost);
String GostToInt(AnsiString Gost);
String VinToGost (String Vin);
String GetGostNum(String st);

void AutoWidthSG(TStringGrid *sg);
void  SGClear (TStringGrid *SG,int RightOfset);

template\<typename T\>
void shellSort(T a[], long size);
int increment(long inc[], long size);
template\<typename T\>
void change (T &amp;el1,T &amp;el2);

template\<typename T\>
void insertSort (T a[], long size);
\#endif
</code>

@@TStSelect::BitBtn1
Description
Кнопка отмены.

@@TStSelect::BitBtn2
Description
Кнопка принять.

@@TStSelect::CB1
Description
Выпадающий список с возможными следующими состояниями 

@@TStSelect::DB
Description
Указатель на класс для работы с базой данных

@@TStSelect::IcoData
Description
Указатель на класс-контейнер иконок.

@@TStSelect::IMG
Description
Графическая область для отображения иконки выбранного
состояния

@@TStSelect::L1
Description
Строка для вывода информации опльзователю об изменяемом
состоянии

@@TStSelect::NextState
Description
Идентификатор состояния выбранного как замена текущему
состоянию

@@TStSelect::NextStateAccept
Description
Идентификатор доступа к состоянию выбранному как замена
текущему состоянию

@@TStSelect::NextStateName
Description
Название состояния выбранного как замена текущему состоянию

@@TStSelect::BitBtn2Click@TObject *
Description
Действие выполняемое при нажании на кнопку "Принять"
(TStSelect::BitBtn2).

Присвыивание выходным переменным конечных значений.
C++ Syntax
<code lang="c++">
void __fastcall TStSelect::BitBtn2Click(TObject *Sender)
{
TComboBox *cb=CB1;
int current=cb-\>Items-\>IndexOf(cb-\>Text);
if (current\<0) {return;}
ComboRow *row=(ComboRow *)cb-\>Items-\>Objects[current];  //вызов класса
if (row)
    {
    NextState=row-\>GetStateID();
    NextStateName=row-\>GetStateName();
    NextStateAccept=row-\>GetStateAccept();
    }
}
</code>
Type Parameters
Sender :  Ссылка типа TObject на объект вызвавший процедуру

@@TStSelect::CB1Click@TObject *
Description
Действие выполняемое при выборе нового состояния (клике на
TStSelect::CB1). Отрисовка иконки выбранного состояния.
C++ Syntax
<code lang="c++">
void __fastcall TStSelect::CB1Click(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
ComboRow *row=(ComboRow *)cb-\>Items-\>Objects[cb-\>ItemIndex];  //вызов класса
if (row)
    {
    IMG-\>Picture-\>Bitmap=0;
    TImageList *ico=IcoData-\>GetStateList();
    ico-\>GetBitmap(IcoData-\>GetInList(row-\>GetStateID(),row-\>GetStateAccept(),0),IMG-\>Picture-\>Bitmap);
    }
}
</code>
Type Parameters
Sender :  Ссылка типа TObject на объект вызвавший процедуру

@@TStSelect::ComboClear
Description
Мехханизм очистки данных из выпадающего списка.
C++ Syntax
<code lang="c++">
void TStSelect::ComboClear(void)
{
TComboBox *cb=CB1;
for (int i = 0; i\<cb-\>Items-\>Count; i++)
    {
    delete (ComboRow *)cb-\>Items-\>Objects[i];
    cb-\>Items-\>Delete(i);//очистить бокс
    i--;
    }
}
</code>

@@TStSelect::TStSelect::TStSelect@TComponent*@cSQL *@IconsData *@int &@int &
Description
Конструктор. Проводит первоначальную инициализацию и
заполнение возможных состояний в выпадающем списке.
C++ Syntax
<code lang="c++">
__fastcall     TStSelect::TStSelect(TComponent* Owner,cSQL *db,IconsData *_IcoData,const int &amp;State,const int &amp;User)
    \: TForm(Owner)
{
DB=db;
IcoData=_IcoData;
NextState=-1;
NextStateName="";
NextStateAccept=false;
String sql="Call constructions.GetNextStates('"+String(State)+"','"+String(User)+"')" ;
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    L1-\>Caption="\\""+rez-\>FieldByName("CurrName")-\>Value+"\\" изменить на";
    while (!rez-\>Eof)
        {
        ComboRow *row=new ComboRow(rez-\>FieldByName("NextState")-\>Value,rez-\>FieldByName("NextName")-\>Value,rez-\>FieldByName("NextAccept")-\>Value);
        CB1-\>Items-\>AddObject(row-\>GetStateName(),(TObject *)row);
        rez-\>Next();
        }
    }
delete rez;
}
</code>
Type Parameters
Owner :     Указатель на объект владелец
db :        Указатель на класс для работы с базой данных
_IcoData :  Указатель на класс\-коллекцию иконок
State :     Ссылка на идентификатор заменяемого состояния
User :      Ссылка на идентификатор пользователя

@@TStSelect::~TStSelect
Description
Деструктор
C++ Syntax
<code lang="c++">
__fastcall    TStSelect::~TStSelect(void)
{
ComboClear();
}
</code>

@@TStSelect
Description
Класс для выбора состояния на смену текущему при
возникновении не однозначности смены состояния.

@@selector.h
Description
Класс для выбора состояния на смену текущему при
возникновении не однозначности смены состояния. (файл
заголовков)
C++ Syntax
<code lang="c++">
\#ifndef selectorH
\#define selectorH
\#include "SQL.h"
\#include "IconsData.h"
\#include "ComboRow.h"
\#include \<Buttons.hpp\>
\#include \<Classes.hpp\>
\#include \<Controls.hpp\>
\#include \<ExtCtrls.hpp\>
\#include \<StdCtrls.hpp\>

class TStSelect : public TForm
{
__published:
    TBitBtn *BitBtn1;
    TBitBtn *BitBtn2;
    TComboBox *CB1;
    TImage *IMG;
    TLabel *L1;
    void __fastcall CB1Click(TObject *Sender);
    void __fastcall BitBtn2Click(TObject *Sender);
private:
cSQL         *DB;
IconsData     *IcoData;
void         ComboClear(void);
public:
int     NextState;
String     NextStateName;
bool     NextStateAccept;
    __fastcall     TStSelect::TStSelect(TComponent* Owner,cSQL *db,IconsData *_IcoData,const int &amp;State,const int &amp;User);
    __fastcall ~TStSelect(void);
};
\#endif
</code>

@@selector.cpp
Description
Класс для выбора состояния на смену текущему при
возникновении не однозначности смены состояния. (файл
описания)
C++ Syntax
<code lang="c++">
\#include \<vcl.h\>
\#pragma hdrstop

\#include "selector.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)
\#pragma resource "*.dfm"
//---------окно
__fastcall     TStSelect::TStSelect(TComponent* Owner,cSQL *db,IconsData *_IcoData,const int &amp;State,const int &amp;User)
    \: TForm(Owner)
{
DB=db;
IcoData=_IcoData;
NextState=-1;
NextStateName="";
NextStateAccept=false;
String sql="Call GetNextStates('"+String(State)+"','"+String(User)+"')" ;
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    L1-\>Caption="\\""+rez-\>FieldByName("CurrName")-\>Value+"\\" изменить на";
    while (!rez-\>Eof)
        {
        ComboRow *row=new ComboRow(rez-\>FieldByName("NextState")-\>Value,rez-\>FieldByName("NextName")-\>Value,rez-\>FieldByName("NextAccept")-\>Value);
        CB1-\>Items-\>AddObject(row-\>GetStateName(),(TObject *)row);
        rez-\>Next();
        }
    }
delete rez;
}
__fastcall    TStSelect::~TStSelect(void)
{
ComboClear();
}
void         TStSelect::ComboClear(void)
{
TComboBox *cb=CB1;
for (int i = 0; i\<cb-\>Items-\>Count; i++)
    {
    delete (ComboRow *)cb-\>Items-\>Objects[i];
    cb-\>Items-\>Delete(i);//очистить бокс
    i--;
    }
}

void __fastcall TStSelect::CB1Click(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
int current=cb-\>Items-\>IndexOf(cb-\>Text);
ComboRow *row=(ComboRow *)cb-\>Items-\>Objects[current];  //вызов класса
if (row)
    {
    IMG-\>Picture-\>Bitmap=0;
    TImageList *ico=IcoData-\>GetStateList();
    ico-\>GetBitmap(IcoData-\>GetInList(row-\>GetStateID(),row-\>GetStateAccept(),0),IMG-\>Picture-\>Bitmap);
    }
}

void __fastcall TStSelect::BitBtn2Click(TObject *Sender)
{
TComboBox *cb=CB1;
int current=cb-\>Items-\>IndexOf(cb-\>Text);
if (current\<0) {return;}
ComboRow *row=(ComboRow *)cb-\>Items-\>Objects[current];  //вызов класса
if (row)
    {
    NextState=row-\>GetStateID();
    NextStateName=row-\>GetStateName();
    NextStateAccept=row-\>GetStateAccept();
    }
}
</code>

@@TObdSelector::~TObdSelector
Description
Деструктор
C++ Syntax
<code lang="c++">
__fastcall TObdSelector::~TObdSelector()
{
ComboClear();
}
</code>

@@TObdSelector::TObdSelector@TComponent*@ClassConnector *const@TWinControl *@cSQL *const@char
Description
Конструктор.
C++ Syntax
<code lang="c++">
__fastcall TObdSelector::TObdSelector(TComponent* Owner,ClassConnector *const Own,
                                      TWinControl *_p,cSQL *const db,char _ListSize):
                                      TFrame(Owner),DB(db),ListSize(_ListSize),owner(Own)
{
static int count=0;
count++;
Name=Name+String(count);
Align=alClient;
Parent=_p;
}
</code>
Type Parameters
Owner :      Указатель на класс\-хозяин
Own :        Указатель на интерфейс взаимодействия
             класса\-хозяина
_p :         Указатель на родительский объект (объект на
             котором будет отображаться компонент)
db :         Указатель на класс для работы с базой данных
_ListSize :  Переменная регулюрующая количество строк при
             запоминании истории

@@TObdSelector::BackSP
Description
Кнопка возврата к предыдущему обозначению из списка

@@TObdSelector::NextSP
Description
Кнопка возврата к следующему обозначению из списка

@@TObdSelector::owner
Description
Указатель на интерфейс взаимодействия класса-хозяина

@@TObdSelector::ListSize
Description
Переменная-ограничитель количества обозначений узлов/деталей
в истории вызовов

@@TObdSelector::DB
Description
Указатель на класс для работы с базой данных

@@TObdSelector::FastNavigator
Description
Выпадающий список-история загрузок узлов/деталей

@@TObdSelector::ComboClear
Description
Функция очистки содержимого выпадающего списка
TObdSelector::FastNavigator
C++ Syntax
<code lang="c++">
void TObdSelector::ComboClear()
{
TComboBox *cb=FastNavigator;
for (int i = 0; i\<cb-\>Items-\>Count; i++)
    {
    delete (Obd *)cb-\>Items-\>Objects[i];
    cb-\>Items-\>Delete(i);//очистить бокс
    i--;
    }
}
</code>

@@TObdSelector::FastNavigatorClick@TObject *
Description
Действи вызываемое выбором узла/детали из списка ранее
загруженых.
C++ Syntax
<code lang="c++">
void __fastcall TObdSelector::FastNavigatorClick(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
if (!cb-\>Tag)
    {
    Obd *tmp=new Obd(*((Obd *)cb-\>Items-\>Objects[cb-\>ItemIndex]));
    LoadDet(tmp);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший эту процедуру

@@TObdSelector::FastNavigatorDropDown@TObject *
Description
Действие при раскрытии списка TObdSelector::FastNavigator
C++ Syntax
<code lang="c++">
void __fastcall TObdSelector::FastNavigatorDropDown(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
cb-\>Tag=0;
}
</code>

Type Parameters
Sender :  Указатель на объект вызвавший эту процедуру

@@TObdSelector::FastNavigatorKeyPress@TObject *@wchar_t &
Description
Действие при нажатии клавиши клавиатуры в поле ввода текста
C++ Syntax
<code lang="c++">
void __fastcall TObdSelector::FastNavigatorKeyPress(TObject *Sender, wchar_t &amp;Key)
{
TComboBox *cb=(TComboBox *)Sender;
if (Key==13)
    {
    SetText(cb-\>Text);
    }else
    {
    cb-\>Tag=1;
    }
}
</code>

Type Parameters
Sender :  Указатель на объект вызвавший эту процедуру
Key :     Ссылка на код нажатой клавиши клавиатуры

@@TObdSelector::LoadDet@Obd *
Description
Функция для отправки команды на загрузку детали из базы через
интерфейст компонента-хозяина
C++ Syntax
<code lang="c++">
void               TObdSelector::LoadDet  (Obd *det)
{
TComboBox *cb=FastNavigator;
//если есть деталь то вставить в очередь массива
for (int i = 0; i\<cb-\>Items-\>Count; i++)
    {
    if (cb-\>Items-\>operator [](i)==det-\>Get_Obd(true))
        {
        delete (Obd *)cb-\>Items-\>Objects[i];
        cb-\>Items-\>Delete(i);//удалить повторение
        i--;
        }
    }
int count=cb-\>Items-\>Count;
if (count\>ListSize)
    {
    delete (Obd *)cb-\>Items-\>Objects[count-1];
    cb-\>Items-\>Delete(count-1);//удалить повторение
    }
if (det-\>UpdateVal())
    {
    cb-\>Items-\>InsertObject(0,det-\>Get_Obd(true),(TObject*)det);//вставить текст в первый итем
    cb-\>ItemIndex=0;                    //показать вставленное
    cb-\>SelStart=cb-\>Text.Length();       // установить курсор в последнюю позицию
    owner-\>Load(det);
    }else{delete det;}
}
</code>
Type Parameters
det :  Указатель на объект краткого описания детали

@@TObdSelector::SetText@String &
Description
Функция для отправки команды на загрузку детали при вводе
текста в TObdSelector::FastNavigator
C++ Syntax
<code lang="c++">
void TObdSelector::SetText(const String &amp;Text)
{
Obd *tmp=new Obd(DB,Text);
if (!tmp-\>CanUse()){delete tmp;return;}
LoadDet(tmp);
}
</code>
Type Parameters
Text :  Ссылка на обозначение детали

@@TObdSelector::SpChange@TObject *
Description
Обработчик нажатия кнопок навигации по списку ранее
загруженных деталей. Отправляет команду на загрузку в
компонент хозяин через интерфейс связи
C++ Syntax
<code lang="c++">
void __fastcall TObdSelector::SpChange(TObject *Sender)
{
TSpeedButton *sb=(TSpeedButton *)Sender;
TComboBox *cb=FastNavigator;
if (!cb-\>Items-\>Count) {return;}
int current=cb-\>ItemIndex;
int count=cb-\>Items-\>Count;
if (sb-\>Tag)
    {
    if (current==0)
        {
        current=count-1;
        }else
        {
        current--;
        }
    }else
    {
    if (current==count-1)
        {
        current=0;
        }else
        {
        current++;
        }
    }
Obd *f=(Obd *)cb-\>Items-\>Objects[current];  //вызов класса
if (f-\>UpdateVal())
    {
    cb-\>ItemIndex=current; //показать вставленное
    owner-\>Load(f);
    }else
    {
    delete f;
    cb-\>Items-\>Delete(current);
    cb-\>ItemIndex=0;
    SpChange(Sender);
    }
}
</code>

Type Parameters
Sender :  Указатель на объект вызвавший эту процедуру

@@TObdSelector
Description
Компонент для отправки команды на загрузку в другие
компоненты и ведения истории загрузки узлов/деталей

@@DetSelector.h
Description
Компонент для отправки команды на загрузку в другие
компоненты и ведения истории загрузки узлов/деталей (файл
заголовков)
C++ Syntax
<code lang="c++">
\#ifndef DetSelectorH
\#define DetSelectorH

\#include \<Classes.hpp\>
\#include \<Controls.hpp\>
\#include \<StdCtrls.hpp\>
\#include \<Forms.hpp\>
\#include \<Buttons.hpp\>
\#include "ClassConnector.h"

class TObdSelector : public TFrame
{
__published:
    TSpeedButton     *BackSP;
    TSpeedButton     *NextSP;
    TComboBox        *FastNavigator;
    void __fastcall FastNavigatorClick(TObject *Sender);
    void __fastcall FastNavigatorDropDown(TObject *Sender);
    void __fastcall FastNavigatorKeyPress(TObject *Sender, wchar_t &amp;Key);
    void __fastcall SpChange(TObject *Sender);
private:
    char ListSize;
    cSQL *const DB;
    ClassConnector *const owner;
    void              SetText(const String &amp;Text);
    void              ComboClear(void);
public:
    __fastcall TObdSelector(TComponent* Owner, ClassConnector *const Own,TWinControl *_p,cSQL *const db,char _ListSize=10);
    __fastcall ~TObdSelector();
    void               LoadDet  (Obd *det);
};
\#endif

</code>

@@DetSelector.cpp
Description
Компонент для отправки команды на загрузку в другие
компоненты и ведения истории загрузки узлов/деталей (файл
описаний)
C++ Syntax
<code lang="c++">
\#include \<vcl.h\>
\#pragma hdrstop
\#include "DetSelector.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)
\#pragma resource "*.dfm"

__fastcall TObdSelector::TObdSelector(TComponent* Owner,ClassConnector *const Own,TWinControl *_p,cSQL *const db,char _ListSize):
TFrame(Owner),DB(db),ListSize(_ListSize),owner(Own)
{
static int count=0;
count++;
Name=Name+String(count);
Align=alClient;
Parent=_p;
}
__fastcall TObdSelector::~TObdSelector()
{
ComboClear();
}
void __fastcall TObdSelector::FastNavigatorClick(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
if (!cb-\>Tag)
    {
    SetText(cb-\>Text);
    }
}
void __fastcall TObdSelector::FastNavigatorDropDown(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
cb-\>Tag=0;
}
void __fastcall TObdSelector::FastNavigatorKeyPress(TObject *Sender, wchar_t &amp;Key)

{
TComboBox *cb=(TComboBox *)Sender;
if (Key==13)
    {
    SetText(cb-\>Text);
    }else
    {
    cb-\>Tag=1;
    }
}
void __fastcall TObdSelector::SpChange(TObject *Sender)
{
TSpeedButton *sb=(TSpeedButton *)Sender;
TComboBox *cb=FastNavigator;
if (!cb-\>Items-\>Count) {return;}
int current=cb-\>Items-\>IndexOf(cb-\>Text);
int count=cb-\>Items-\>Count;
if (sb-\>Tag)
    {
    if (current==0)
        {
        current=count-1;
        }else
        {
        current--;
        }
    }else
    {
    if (current==count-1)
        {
        current=0;
        }else
        {
        current++;
        }
    }
cb-\>ItemIndex=current; //показать вставленное

Obd *f=(Obd *)cb-\>Items-\>Objects[current];  //вызов класса
owner-\>Load(f);
}
void              TObdSelector::SetText(const String &amp;Text)
{
Obd *tmp=new Obd(DB,Text);
if (!tmp-\>CanUse()){delete tmp;return;}
LoadDet(tmp);
}
void               TObdSelector::LoadDet  (Obd *det)
{
TComboBox *cb=FastNavigator;
//если есть деталь то вставить в очередь массива
for (int i = 0; i\<cb-\>Items-\>Count; i++)
    {
    if (cb-\>Items-\>operator [](i)==det-\>Get_Obd(true))
        {
        delete (Obd *)cb-\>Items-\>Objects[i];
        cb-\>Items-\>Delete(i);//удалить повторение
        i--;
        }
    }
int count=cb-\>Items-\>Count;
if (count\>ListSize)
    {
    delete (Obd *)cb-\>Items-\>Objects[count-1];
    cb-\>Items-\>Delete(count-1);//удалить повторение
    }
cb-\>Items-\>InsertObject(0,det-\>Get_Obd(true),(TObject*)det);//вставить текст в первый итем
cb-\>ItemIndex=0;                    //показать вставленное
cb-\>SelStart=cb-\>Text.Length();       // установить курсор в последнюю позицию
owner-\>Load(det);
}
void              TObdSelector::ComboClear()
{
TComboBox *cb=FastNavigator;
for (int i = 0; i\<cb-\>Items-\>Count; i++)
    {
    delete (Obd *)cb-\>Items-\>Objects[i];
    cb-\>Items-\>Delete(i);//очистить бокс
    i--;
    }
}
</code>

@@TreeRow::Accept
Description
Индикатор доступа в детали/узлу

@@TreeRow::Arhive
Description
Индикатор нахождения в архиве

@@TreeRow::CanChild
Description
Индикатор возможности иметь в своем составе детали/узлы

@@TreeRow::CondName
Description
Название состояния в котором прибывает узел/деталь

@@TreeRow::count
Description
Переменная, показывающая количество экземпляров класса.

@@TreeRow::DetCreated
Description
Дата занесения записи о детали в базу

@@TreeRow::DetCreator
Description
Имя пользователя, занесшего деталь в базу данных

@@TreeRow::DetUpdated
Description
Дата обоновления информации о детали в базе

@@TreeRow::DetUpdater
Description
Имя пользователя, обновившего информацию в базе

@@TreeRow::ei
Description
Идентификатор едениц измерения в которых подсчитывается
позиция спецификации (детали узлы материалы)

@@TreeRow::eiName
Description
Сокращенное название едениц измерения, которыми
подсчитывается количество.

@@TreeRow::Force
Description
Индикатор действия над деталью игнорируя параметр CanChild
(на случай ошибочной расстановки индикации в базе)

@@TreeRow::format
Description
Формат- спецификация

@@TreeRow::G_Obu
Description
Обозначение узла в формате ГОСТ, СТП

@@TreeRow::idparent
Description
Идентификатор узла в который входит деталь/узел

@@TreeRow::kol
Description
Количество - спецификация

@@TreeRow::LUser
Description
Ссылка на идетификатор пользователя вошедшего в программу

@@TreeRow::pos
Description
Позиция детали/узла в общей сборке

@@TreeRow::pp
Description
Код производственного признака

@@TreeRow::ppName
Description
Название производственного признака

@@TreeRow::ppp
Description
Признак приминяемости
Note
  * 0&#45;Постоянная часть
  * 1&#45;переменная часть

@@TreeRow::prim
Description
Примечание - спецификация

@@TreeRow::RowCreated
Description
Дата создания строки спецификации

@@TreeRow::RowCreator
Description
Пользоватеь создавший строку спецификации

@@TreeRow::RowUpdated
Description
Дата последнего обновления строки спецификации

@@TreeRow::RowUpdater
Description
Пользователь обновивший строку спецификации

@@TreeRow::state
Description
Идентификатор состояния 

@@TreeRow::User
Description
Имя пользователя, в данный момент работающего с деталью

@@TreeRow::UserID
Description
Идентификатор пользователя в данный момент работающего с
деталью

@@TreeRow::V_Obu
Description
Обозначение узла куда входит деталь/узел в 15ти значном
цыфровом формате

@@TreeRow::zona
Description
Зона-спецификация

@@TreeRow::CanUse@const
Description
Виртуальная inline функция, определяющая может быть
использован текущий экземпляр класса или нет
C++ Syntax
<code>
bool CanUse (void)const
{
return (id\>0&amp;&amp;Get_Obd(false)!="")?true:false;
};
</code>
Return Value List
True :   Минимальный набор данных есть. Класс может
         использоваться
False :  Отсутствует минимальный набор данных. Класс
         использовать нельзя

@@TreeRow::Count@const
Description
Inline функция возвращающая количество существующих
экземпляров класса
C++ Syntax
<code lang="c++">
int Count (void)const{return count;};
</code>

@@TreeRow::Get_Accept@const
Description
Inline функция доступа. Возвращает значение метки доступности
для изменения
C++ Syntax
<code lang="c++">
bool Get_Accept(void)const{return Accept;};
</code>

@@TreeRow::Get_Arhive@const
Description
Inline функция доступа. Возвращает значение метки нахождения
в архиве
C++ Syntax
<code lang="c++">
bool Get_Arhive(void)const{return Arhive;};
</code>

@@TreeRow::Get_CanChild@const
Description
Inline функция доступа. Возвращает значение метки
показывающей возможность иметь в составе другие узлы/детали


C++ Syntax
<code lang="c++">
bool Get_CanChild(void) const{return CanChild;};
</code>

@@TreeRow::Get_CondName@const
Description
Inline функция доступа. Возвращает название состояния в
котором находится деталь/узел.
C++ Syntax
<code lang="c++">
String Get_CondName(void)const{return CondName;};
</code>

@@TreeRow::Get_DetCreated@const
Description
Inline функция доступа. Возвращает дату создания записи
детали/узла в базу
C++ Syntax
<code lang="c++">
TDateTime  Get_DetCreated(void) const{return DetCreated;};
</code>

@@TreeRow::Get_DetCreator@const
Description
Inline функция доступа. Возвращает имя пользователя
создавшего запись по детали в базе данных
C++ Syntax
<code lang="c++">
String Get_DetCreator(void)    const{return DetCreator;};
</code>

@@TreeRow::Get_DetUpdated@const
Description
Inline функция доступа. Возвращает дату последнего обновления
записи в базе данных
C++ Syntax
<code lang="c++">
TDateTime  Get_DetUpdated(void)    const{return DetUpdated;};
</code>

@@TreeRow::Get_DetUpdater@const
Description
Inline функция доступа. Возвращает
C++ Syntax
<code lang="c++">
String Get_DetUpdater(void)const{return DetUpdater;};
</code>

@@TreeRow::Get_ei@const
Description
Inline функция доступа. Возвращает идентификатор едениц
измерения
C++ Syntax
<code lang="c++">
int Get_ei(void)const{return ei;};
</code>

@@TreeRow::Get_eiName@const
Description
Inline функция доступа. Возвращает краткое название едениц
измерения
C++ Syntax
<code lang="c++">
String Get_eiName(void)    const{return eiName;};
</code>

@@TreeRow::Get_Force@const
Description
Inline функция доступа. Возвращает индикатор игнорирования
метки CanChild
C++ Syntax
<code lang="c++">
bool Get_Force(void) const{return Force;};
</code>

@@TreeRow::Get_format@const
Description
Inline функция доступа. Возвращает формат листа чертежа
(спецификация)
C++ Syntax
<code lang="c++">
String Get_format(void)    const{return format;};
</code>

@@TreeRow::Get_kol@const
Description
Inline функция доступа. Возвращает количественную
характеристику строки спецификации
C++ Syntax
<code lang="c++">
double Get_kol(void)        const{return kol;};
</code>

@@TreeRow::Get_Obu@bool@const
Description
Inline функция доступа. Возвращает обозначение узла в который
входит деталь/узел
C++ Syntax
<code lang="c++">
String Get_Obu(bool gost)const{return gost?G_Obu:V_Obu;};
</code>

@@TreeRow::Get_ParentID@const
Description
Inline функция доступа. Возвращает идентификатор узла в
который входит деталь/узел
C++ Syntax
<code lang="c++">
int Get_ParentID(void)    const{return idparent;};
</code>

@@TreeRow::Get_pos@const
Description
Inline функция доступа. Возвращает позицию детали/узла на
сборочном чертеже (спецификация)
C++ Syntax
<code>
String Get_pos(void)    const{return pos;};
</code>

@@TreeRow::Get_pp@const
Description
Inline функция доступа. Возвращает код признака производства
детали
C++ Syntax
<code>
int Get_pp(void) const{return pp;};
</code>

@@TreeRow::Get_ppName@const
Description
Inline функция доступа. Возвращает название производственного
признака узла/детали
C++ Syntax
<code>
String Get_ppName(void)    const{return ppName;};
</code>

@@TreeRow::Get_ppp@const
Description
Inline функция доступа. Возвращает признак постоянного
состава
C++ Syntax
<code>
int Get_ppp(void) const{return ppp;};
</code>

@@TreeRow::Get_prim@const
Description
Inline функция доступа. Возвращает примечание (спецификация)
C++ Syntax
<code>
String Get_prim(void)    const{return prim;};
</code>

@@TreeRow::Get_RowCreated@const
Description
Inline функция доступа. Возвращает дату создания строки
спецификации
C++ Syntax
<code>
TDateTime  Get_RowCreated(void) const{return RowCreated;};
</code>

@@TreeRow::Get_RowCreator@const
Description
Inline функция доступа. Возвращает имя пользователя
создавшего строку спецификации
C++ Syntax
<code>
String Get_RowCreator(void) const{return RowCreator;};
</code>

@@TreeRow::Get_RowUpdated@const
Description
Inline функция доступа. Возвращает дату последнего обновления
строки спецификации
C++ Syntax
<code>
TDateTime  Get_RowUpdated(void) const{return RowUpdated;};
</code>

@@TreeRow::Get_RowUpdater@const
Description
Inline функция доступа. Возвращает имя пользователя последним
внесшего изменения в строку спецификации
C++ Syntax
<code>
String Get_RowUpdater(void)    const{return RowUpdater;};
</code>

@@TreeRow::Get_state@const
Description
Inline функция доступа. Возвращает идентификатор состояния в
котором находится деталь/узел
C++ Syntax
<code>
int Get_state(void) const{return state;};
</code>

@@TreeRow::Get_Text@const
Description
Inline функция доступа. Возвращает текст отображаемый
пользователю
C++ Syntax
<code>
String Get_Text (void) const
{
return G_Obd+" - "+Name+" - "+String(kol)+eiName;
};
</code>

@@TreeRow::Get_User@const
Description
Inline функция доступа. Возвращает имя пользователя уже
работающего с данной деталью/узлом
C++ Syntax
<code>
String Get_User(void)    const{return User;};
</code>

@@TreeRow::Get_UserID@const
Description
Inline функция доступа. Возвращает идентификатор пользователя
уже работающего с данной деталью/узлом
C++ Syntax
<code>
int Get_UserID(void)    const{return UserID;};
</code>

@@TreeRow::Get_zona@const
Description
Inline функция доступа. Возвращает зону (спецификация)
C++ Syntax
<code>
String Get_zona(void)    const{return zona;};
</code>

@@TreeRow::init
Description
Функция инициализации переменных на значения по умолчанию
C++ Syntax
<code lang="c++">
void         TreeRow::init            (void)
{
idparent=-1;
pp=-1;
ppp=-1;
ei=-1;
state=-1;
UserID=-1;
V_Obu="";
G_Obu="";
format="";
pos="";
prim="";
zona="";
ppName="";
eiName="";
User="";
CondName="";
DetCreator="";
DetUpdater="";
RowCreator="";
RowUpdater="";
kol=0;
Arhive=false;
Force=false;
CanChild=false;
Accept=false;
DetCreated=0;
DetUpdated=0;
RowCreated=0;
RowUpdated=0;
}
</code>

@@TreeRow::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code lang="c++">
bool ItTrueClassName (void)const
{
return TrueClassName()=="TreeRow"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса 
False :  Тип указателя отличается от созданного класса 

@@TreeRow::Set_Force@bool
Description
Inline функция для включения/отключения режима игнорирования
значения CanChild
C++ Syntax
<code lang="c++">
void Set_Force(const bool force){Force=force;};
</code>

Type Parameters
force :  Новое значение для индикатора режима игнорирования

@@TreeRow::SetData@int &@int &@int &@int &@int &@int &@int &@int &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@String &@double &@bool &@bool &@bool &@TDateTime &@TDateTime &@TDateTime &@TDateTime &
Description
Функция предназначенная для загрузки данных из вне.
Используется как основной источник данных для класса.
C++ Syntax
<code lang="c++">
bool         TreeRow::SetData(
                    const int &amp;_id,    const int &amp;_idparent,const int &amp;_SpRazd,    const int &amp;_pp,
                    const int &amp;_ppp,    const int &amp;_ei,        const int &amp;_state,    const int &amp;_UserID,
                    const String &amp;_Obd,        const String &amp;_Obu,
                    const String &amp;_Name,    const String &amp;_SpRazdName,
                    const String &amp;_format,    const String &amp;_pos,        const String &amp;_prim,
                    const String &amp;_zona,        const String &amp;_ppName,    const String &amp;_eiName,
                    const String &amp;_User,        const String &amp;_CondName,    const String &amp;_DetCreator,
                    const String &amp;_DetUpdater,    const String &amp;_RowCreator,
                    const String &amp;_RowUpdater,    const double &amp;_kol,
                    const bool &amp;_arhive,    const bool &amp;_CanChild,    const bool &amp;_Accept,
                    const TDateTime  &amp;_DetCreated,    const TDateTime  &amp;_DetUpdated,
                    const TDateTime  &amp;_RowCreated,    const TDateTime  &amp;_RowUpdated
                    )
{
if (ItTrueClassName())
    {
    SetId(_id);// базовый класс
    SpRazd=_SpRazd;
    SetObd(_Obd);
    Name=_Name.Trim();
    SpRazdName=_SpRazdName.Trim();
    // текущий класс
    idparent=_idparent;
    pp=_pp;
    ppp=_ppp;
    ei=_ei;
    state=_state;
    UserID=_UserID;
    SetObu(_Obu);
    format=_format.Trim();
    pos=_pos.Trim();
    prim=_prim.Trim();
    zona=_zona.Trim();
    ppName=_ppName.Trim();
    eiName=_eiName.Trim();
    User=_User.Trim();
    CondName=_CondName.Trim();
    DetCreator=_DetCreator.Trim();
    DetUpdater=_DetUpdater.Trim();
    RowCreator=_RowCreator.Trim();
    RowUpdater=_RowUpdater.Trim();
    kol=_kol;
    Arhive=_arhive;
    Set_Force(false);
    CanChild=_CanChild;
    Accept=_Accept;
    DetCreated=_DetCreated;
    DetUpdated=_DetUpdated;
    RowCreated=_RowCreated;
    RowUpdated=_RowUpdated;
    }
return CanUse();
}
</code>
Type Parameters
_id :          Переменная, хранящая идентификатор узла/детали 
_idparent :    Идентификатор узла в который входит деталь/узел
_SpRazd :      Переменная, хранящая идентификатор раздела
               спецификации узла/детали 
_pp :          Код производственного признака 
_ppp :         Признак приминяемости 
_ei :          Идентификатор едениц измерения в которых
               подсчитывается позиция спецификации (детали
               узлы материалы)
_state :       Идентификатор состояния 
_UserID :      Идентификатор пользователя в данный момент
               работающего с деталью 
_Obd :         Переменная, хранящая обозначение узла/детали
_Obu :         Обозначение узла
_Name :        Переменная, хранящая наименование детали 
_SpRazdName :  Переменная, хранящая название раздела
               спецификации узла/детали 
_format :      Формат\- спецификация
_pos :         Позиция детали/узла в общей сборке 
_prim :        Примечание \- спецификация 
_zona :        Зона\-спецификация 
_ppName :      Название производственного признака 
_eiName :      Сокращенное название едениц измерения, которыми
               подсчитывается количество.
_User :        Имя пользователя, в данный момент работающего с
               деталью 
_CondName :    Название состояния в котором прибывает
               узел/деталь
_DetCreator :  Имя пользователя, занесшего деталь в базу
               данных
_DetUpdater :  Имя пользователя, обновившего информацию в базе
_RowCreator :  Пользоватеь создавший строку спецификации 
_RowUpdater :  Пользователь обновивший строку спецификации 
_kol :         Количество \- спецификация
_arhive :      Индикатор нахождения в архиве
_CanChild :    Индикатор возможности иметь в своем составе
               детали/узлы
_Accept :      Индикатор доступа в детали/узлу
_DetCreated :  Дата занесения записи о детали в базу
_DetUpdated :  Дата обоновления информации о детали в базе
_RowCreated :  Дата создания строки спецификации 
_RowUpdated :  Дата последнего обновления строки спецификации 

@@TreeRow::SetId@int &
Description
Функция присваивания нового идентификатора
C++ Syntax
<code lang="c++">
void TreeRow::SetId (const int &amp;r)
{
id=r;
}
</code>
Type Parameters
r :  ссылка на новый идентификатор

@@TreeRow::SetObd@String &
Description
Функция присваивания нового обозначения детали/узла
C++ Syntax
<code lang="c++">
void         TreeRow::SetObd         (const String &amp;r)
{
V_Obd=GostToVin(r);
G_Obd=VinToGost(r);
}
</code>

Type Parameters
r :  Ссылка на новое обозначение

@@TreeRow::SetObu@String &
Description
Функция присваивания нового обозначения детали/узла
C++ Syntax
<code lang="c++">
void         TreeRow::SetObu         (const String &amp;r)
{
V_Obu=GostToVin(r);
G_Obu=VinToGost(r);
}
</code>
Type Parameters
r :  Ссылка на новое обозначение сборки куда входит узел/деталь

@@TreeRow::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code lang="c++">
String TrueClassName (void)const{return "TreeRow";};
</code>

@@TreeRow::UpdateVal
Description
Функция для вызова обновления данных класса из вне
C++ Syntax
<code lang="c++">
bool         TreeRow::UpdateVal         (void)
{
String sql;
if (idparent\>=0)
    {
    sql="call constructions.UpdateRowInfo('"+String(idparent)+"','"+String(id)+"','"+String(LUser)+"')";
    }else
    {
    sql="Call constructions.LoadDet('"+String(id)+"','"+String(LUser)+"')";
    }
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    //базовый класс
    SetId(rez-\>FieldByName("idchild")-\>Value);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SetObd(rez-\>FieldByName("obd")-\>Value.operator UnicodeString());
    Name=rez-\>FieldByName("name")-\>Value.operator UnicodeString();
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    //текущий классс
    idparent=rez-\>FieldByName("idparent")-\>Value;
    pp=rez-\>FieldByName("pp")-\>Value.operator UnicodeString().ToInt();
    ppp=rez-\>FieldByName("ppp")-\>Value.operator UnicodeString().ToInt();
    ei=rez-\>FieldByName("ei")-\>Value.operator UnicodeString().ToInt();
    state=rez-\>FieldByName("state")-\>Value;
    UserID=rez-\>FieldByName("UserID")-\>Value;
    SetObu(rez-\>FieldByName("obu")-\>Value.operator UnicodeString());
    format=rez-\>FieldByName("format")-\>Value;
    pos=rez-\>FieldByName("pos")-\>Value;
    prim=rez-\>FieldByName("prim")-\>Value;
    zona=rez-\>FieldByName("zona")-\>Value;
    ppName=rez-\>FieldByName("ppName")-\>Value.operator UnicodeString();
    eiName=rez-\>FieldByName("eiName")-\>Value;
    User=rez-\>FieldByName("User")-\>Value;
    CondName=rez-\>FieldByName("CondName")-\>Value;
    DetCreator=rez-\>FieldByName("DetCreator")-\>Value;
    DetUpdater=rez-\>FieldByName("DetUpdater")-\>Value;
    RowCreator=rez-\>FieldByName("RowCreator")-\>Value;
    RowUpdater=rez-\>FieldByName("RowUpdater")-\>Value;
    kol=rez-\>FieldByName("kol")-\>Value;
    Arhive=rez-\>FieldByName("arhive")-\>Value;
    CanChild=rez-\>FieldByName("CanChild")-\>Value;
    Accept=rez-\>FieldByName("Accept")-\>Value;
    if (!rez-\>FieldByName("DetCreated")-\>Value.IsNull()){DetCreated=rez-\>FieldByName("DetCreated")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("DetUpdated")-\>Value.IsNull()){DetUpdated=rez-\>FieldByName("DetUpdated")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("RowCreated")-\>Value.IsNull()){RowCreated=rez-\>FieldByName("RowCreated")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("RowUpdated")-\>Value.IsNull()){RowUpdated=rez-\>FieldByName("RowUpdated")-\>Value.operator TDateTime();}
    delete rez;
    }else
    {
    Obd::init();
    init();
    delete rez;
    }
return CanUse();
}
</code>

@@TreeRow::!=@TreeRow &
Description
Обратный оператор сравнения
C++ Syntax
<code lang="c++">
bool           TreeRow::operator !=    (const TreeRow &amp;r)
{
if (this==&amp;r) {return false;}
if (//базовый класс
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    //текущий класс
    idparent==r.idparent&amp;&amp;
    pp==r.pp&amp;&amp;
    ppp==r.ppp&amp;&amp;
    ei==r.ei&amp;&amp;
    state==r.state&amp;&amp;
    UserID==r.UserID&amp;&amp;
    V_Obu==r.V_Obu&amp;&amp;
    G_Obu==r.G_Obu&amp;&amp;
    format==r.format&amp;&amp;
    pos==r.pos&amp;&amp;
    prim==r.prim&amp;&amp;
    zona==r.zona&amp;&amp;
    ppName==r.ppName&amp;&amp;
    eiName==r.eiName&amp;&amp;
    User==r.User&amp;&amp;
    CondName==r.CondName&amp;&amp;
    DetCreator==r.DetCreator&amp;&amp;
    DetUpdater==r.DetUpdater&amp;&amp;
    RowCreator==r.RowCreator&amp;&amp;
    RowUpdater==r.RowUpdater&amp;&amp;
    kol==r.kol&amp;&amp;
    Arhive==r.Arhive&amp;&amp;
    Force==r.Force&amp;&amp;
    CanChild==r.CanChild&amp;&amp;
    Accept==r.Accept&amp;&amp;
    DetCreated==r.DetCreated&amp;&amp;
    DetUpdated==r.DetUpdated&amp;&amp;
    RowCreated==r.RowCreated&amp;&amp;
    RowUpdated==r.RowUpdated)
    {
    return false;
    }
return true;
}
</code>

@@TreeRow::==@TreeRow &
Description
Прямой оператор сравнения.
C++ Syntax
<code lang="c++">
bool           TreeRow::operator ==    (const TreeRow &amp;r)
{
if (this==&amp;r) {return true;}
if (//базовый класс
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    //текущий класс
    idparent==r.idparent&amp;&amp;
    pp==r.pp&amp;&amp;
    ppp==r.ppp&amp;&amp;
    ei==r.ei&amp;&amp;
    state==r.state&amp;&amp;
    UserID==r.UserID&amp;&amp;
    V_Obu==r.V_Obu&amp;&amp;
    G_Obu==r.G_Obu&amp;&amp;
    format==r.format&amp;&amp;
    pos==r.pos&amp;&amp;
    prim==r.prim&amp;&amp;
    zona==r.zona&amp;&amp;
    ppName==r.ppName&amp;&amp;
    eiName==r.eiName&amp;&amp;
    User==r.User&amp;&amp;
    CondName==r.CondName&amp;&amp;
    DetCreator==r.DetCreator&amp;&amp;
    DetUpdater==r.DetUpdater&amp;&amp;
    RowCreator==r.RowCreator&amp;&amp;
    RowUpdater==r.RowUpdater&amp;&amp;
    kol==r.kol&amp;&amp;
    Arhive==r.Arhive&amp;&amp;
    Force==r.Force&amp;&amp;
    CanChild==r.CanChild&amp;&amp;
    Accept==r.Accept&amp;&amp;
    DetCreated==r.DetCreated&amp;&amp;
    DetUpdated==r.DetUpdated&amp;&amp;
    RowCreated==r.RowCreated&amp;&amp;
    RowUpdated==r.RowUpdated)
    {
    return true;
    }
return false;
}
</code>

@@TreeRow::=@TreeRow &
Description
Оператор присвоения
C++ Syntax
<code lang="c++">
TreeRow &amp;     TreeRow::operator =        (const TreeRow &amp;r)
{
if (this==&amp;r) {return *this;}
//базовый класс
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
//текущий класс
idparent=r.idparent;
pp=r.pp;
ppp=r.ppp;
ei=r.ei;
state=r.state;
UserID=r.UserID;
V_Obu=r.V_Obu;
G_Obu=r.G_Obu;
format=r.format;
pos=r.pos;
prim=r.prim;
zona=r.zona;
ppName=r.ppName;
eiName=r.eiName;
User=r.User;
CondName=r.CondName;
DetCreator=r.DetCreator;
DetUpdater=r.DetUpdater;
RowCreator=r.RowCreator;
RowUpdater=r.RowUpdater;
kol=r.kol;
Arhive=r.Arhive;
Force=r.Force;
CanChild=r.CanChild;
Accept=r.Accept;
DetCreated=r.DetCreated;
DetUpdated=r.DetUpdated;
RowCreated=r.RowCreated;
RowUpdated=r.RowUpdated;
return *this;
}
</code>

@@TreeRow::TreeRow@TreeRow &
Description
Конструктор копировщик.
C++ Syntax
<code lang="c++">
TreeRow::TreeRow        (const TreeRow &amp;r):Obd(r),LUser(r.LUser)
{
count++;
idparent=r.idparent;
pp=r.pp;
ppp=r.ppp;
ei=r.ei;
state=r.state;
UserID=r.UserID;
V_Obu=r.V_Obu;
G_Obu=r.G_Obu;
format=r.format;
pos=r.pos;
prim=r.prim;
zona=r.zona;
ppName=r.ppName;
eiName=r.eiName;
User=r.User;
CondName=r.CondName;
DetCreator=r.DetCreator;
DetUpdater=r.DetUpdater;
RowCreator=r.RowCreator;
RowUpdater=r.RowUpdater;
kol=r.kol;
Arhive=r.Arhive;
Force=r.Force;
CanChild=r.CanChild;
Accept=r.Accept;
DetCreated=r.DetCreated;
DetUpdated=r.DetUpdated;
RowCreated=r.RowCreated;
RowUpdated=r.RowUpdated;
}
</code>

@@TreeRow::TreeRow@cSQL *const@int &
Description
Базовый конструктор
C++ Syntax
<code lang="c++">
TreeRow::TreeRow (cSQL *const db,const int &amp;User):Obd(db),LUser(User)
{
count++;
init();
}
</code>

Type Parameters
db :    Указатель на класс работы с базой данных
User :  Ссылка на идентификатора пользователя

@@TreeRow::~TreeRow
Description
Деструктор
C++ Syntax
<code lang="c++">
TreeRow::~TreeRow        (void)
{
count--;
}
</code>

@@TreeRow
Description
Класс данных для построения дерева спецификации и самой
спецификации

@@TreeRow.cpp
Description
Класс данных для построения дерева спецификации и самой
спецификации (файл описания)
C++ Syntax
<code lang="c++">



\#pragma hdrstop

\#include "TreeRow.h"
\#pragma package(smart_init)

            TreeRow::TreeRow        (cSQL *const db,const int &amp;User):Obd(db),LUser(User)
{
count++;
init();
}
            TreeRow::TreeRow        (const TreeRow &amp;r):Obd(r),LUser(r.LUser)
{
count++;
idparent=r.idparent;
pp=r.pp;
ppp=r.ppp;
ei=r.ei;
state=r.state;
UserID=r.UserID;
V_Obu=r.V_Obu;
G_Obu=r.G_Obu;
format=r.format;
pos=r.pos;
prim=r.prim;
zona=r.zona;
ppName=r.ppName;
eiName=r.eiName;
User=r.User;
CondName=r.CondName;
DetCreator=r.DetCreator;
DetUpdater=r.DetUpdater;
RowCreator=r.RowCreator;
RowUpdater=r.RowUpdater;
kol=r.kol;
Arhive=r.Arhive;
Force=r.Force;
CanChild=r.CanChild;
Accept=r.Accept;
DetCreated=r.DetCreated;
DetUpdated=r.DetUpdated;
RowCreated=r.RowCreated;
RowUpdated=r.RowUpdated;
}
            TreeRow::~TreeRow        (void)
{
count--;
}

TreeRow &amp;     TreeRow::operator =        (const TreeRow &amp;r)
{
if (this==&amp;r) {return *this;}
//базовый класс
id=r.id;
SpRazd=r.SpRazd;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
//текущий класс
idparent=r.idparent;
pp=r.pp;
ppp=r.ppp;
ei=r.ei;
state=r.state;
UserID=r.UserID;
V_Obu=r.V_Obu;
G_Obu=r.G_Obu;
format=r.format;
pos=r.pos;
prim=r.prim;
zona=r.zona;
ppName=r.ppName;
eiName=r.eiName;
User=r.User;
CondName=r.CondName;
DetCreator=r.DetCreator;
DetUpdater=r.DetUpdater;
RowCreator=r.RowCreator;
RowUpdater=r.RowUpdater;
kol=r.kol;
Arhive=r.Arhive;
Force=r.Force;
CanChild=r.CanChild;
Accept=r.Accept;
DetCreated=r.DetCreated;
DetUpdated=r.DetUpdated;
RowCreated=r.RowCreated;
RowUpdated=r.RowUpdated;
return *this;
}
bool           TreeRow::operator ==    (const TreeRow &amp;r)
{
if (this==&amp;r) {return true;}
if (//базовый класс
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    //текущий класс
    idparent==r.idparent&amp;&amp;
    pp==r.pp&amp;&amp;
    ppp==r.ppp&amp;&amp;
    ei==r.ei&amp;&amp;
    state==r.state&amp;&amp;
    UserID==r.UserID&amp;&amp;
    V_Obu==r.V_Obu&amp;&amp;
    G_Obu==r.G_Obu&amp;&amp;
    format==r.format&amp;&amp;
    pos==r.pos&amp;&amp;
    prim==r.prim&amp;&amp;
    zona==r.zona&amp;&amp;
    ppName==r.ppName&amp;&amp;
    eiName==r.eiName&amp;&amp;
    User==r.User&amp;&amp;
    CondName==r.CondName&amp;&amp;
    DetCreator==r.DetCreator&amp;&amp;
    DetUpdater==r.DetUpdater&amp;&amp;
    RowCreator==r.RowCreator&amp;&amp;
    RowUpdater==r.RowUpdater&amp;&amp;
    kol==r.kol&amp;&amp;
    Arhive==r.Arhive&amp;&amp;
    Force==r.Force&amp;&amp;
    CanChild==r.CanChild&amp;&amp;
    Accept==r.Accept&amp;&amp;
    DetCreated==r.DetCreated&amp;&amp;
    DetUpdated==r.DetUpdated&amp;&amp;
    RowCreated==r.RowCreated&amp;&amp;
    RowUpdated==r.RowUpdated)
    {
    return true;
    }
return false;
}
bool           TreeRow::operator !=    (const TreeRow &amp;r)
{
if (this==&amp;r) {return false;}
if (//базовый класс
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    //текущий класс
    idparent==r.idparent&amp;&amp;
    pp==r.pp&amp;&amp;
    ppp==r.ppp&amp;&amp;
    ei==r.ei&amp;&amp;
    state==r.state&amp;&amp;
    UserID==r.UserID&amp;&amp;
    V_Obu==r.V_Obu&amp;&amp;
    G_Obu==r.G_Obu&amp;&amp;
    format==r.format&amp;&amp;
    pos==r.pos&amp;&amp;
    prim==r.prim&amp;&amp;
    zona==r.zona&amp;&amp;
    ppName==r.ppName&amp;&amp;
    eiName==r.eiName&amp;&amp;
    User==r.User&amp;&amp;
    CondName==r.CondName&amp;&amp;
    DetCreator==r.DetCreator&amp;&amp;
    DetUpdater==r.DetUpdater&amp;&amp;
    RowCreator==r.RowCreator&amp;&amp;
    RowUpdater==r.RowUpdater&amp;&amp;
    kol==r.kol&amp;&amp;
    Arhive==r.Arhive&amp;&amp;
    Force==r.Force&amp;&amp;
    CanChild==r.CanChild&amp;&amp;
    Accept==r.Accept&amp;&amp;
    DetCreated==r.DetCreated&amp;&amp;
    DetUpdated==r.DetUpdated&amp;&amp;
    RowCreated==r.RowCreated&amp;&amp;
    RowUpdated==r.RowUpdated)
    {
    return false;
    }
return true;
}
void         TreeRow::init            (void)
{
idparent=-1;
pp=-1;
ppp=-1;
ei=-1;
state=-1;
UserID=-1;
V_Obu="";
G_Obu="";
format="";
pos="";
prim="";
zona="";
ppName="";
eiName="";
User="";
CondName="";
DetCreator="";
DetUpdater="";
RowCreator="";
RowUpdater="";
kol=0;
Arhive=false;
Force=false;
CanChild=false;
Accept=false;
DetCreated=0;
DetUpdated=0;
RowCreated=0;
RowUpdated=0;
}
void         TreeRow::SetObu         (const String &amp;r)
{
V_Obu=GostToVin(r);
G_Obu=VinToGost(r);
}
void         TreeRow::SetObd         (const String &amp;r)
{
V_Obd=GostToVin(r);
G_Obd=VinToGost(r);
}
void         TreeRow::SetId           (const int &amp;r)
{
id=r;
}
bool         TreeRow::UpdateVal         (void)
{
String sql;
if (idparent\>=0)
    {
    sql="call UpdateRowInfo('"+String(idparent)+"','"+String(id)+"','"+String(LUser)+"')";
    }else
    {
    sql="Call LoadDet('"+String(id)+"','"+String(LUser)+"')";
    }
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    //базовый класс
    SetId(rez-\>FieldByName("idchild")-\>Value);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SetObd(rez-\>FieldByName("obd")-\>Value.operator UnicodeString());
    Name=rez-\>FieldByName("name")-\>Value.operator UnicodeString();
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    //текущий классс
    idparent=rez-\>FieldByName("idparent")-\>Value;
    pp=rez-\>FieldByName("pp")-\>Value.operator UnicodeString().ToInt();
    ppp=rez-\>FieldByName("ppp")-\>Value.operator UnicodeString().ToInt();
    ei=rez-\>FieldByName("ei")-\>Value.operator UnicodeString().ToInt();
    state=rez-\>FieldByName("state")-\>Value;
    UserID=rez-\>FieldByName("UserID")-\>Value;
    SetObu(rez-\>FieldByName("obu")-\>Value.operator UnicodeString());
    format=rez-\>FieldByName("format")-\>Value;
    pos=rez-\>FieldByName("pos")-\>Value;
    prim=rez-\>FieldByName("prim")-\>Value;
    zona=rez-\>FieldByName("zona")-\>Value;
    ppName=rez-\>FieldByName("ppName")-\>Value.operator UnicodeString();
    eiName=rez-\>FieldByName("eiName")-\>Value;
    User=rez-\>FieldByName("User")-\>Value;
    CondName=rez-\>FieldByName("CondName")-\>Value;
    DetCreator=rez-\>FieldByName("DetCreator")-\>Value;
    DetUpdater=rez-\>FieldByName("DetUpdater")-\>Value;
    RowCreator=rez-\>FieldByName("RowCreator")-\>Value;
    RowUpdater=rez-\>FieldByName("RowUpdater")-\>Value;
    kol=rez-\>FieldByName("kol")-\>Value;
    Arhive=rez-\>FieldByName("arhive")-\>Value;
    CanChild=rez-\>FieldByName("CanChild")-\>Value;
    Accept=rez-\>FieldByName("Accept")-\>Value;
    if (!rez-\>FieldByName("DetCreated")-\>Value.IsNull()){DetCreated=rez-\>FieldByName("DetCreated")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("DetUpdated")-\>Value.IsNull()){DetUpdated=rez-\>FieldByName("DetUpdated")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("RowCreated")-\>Value.IsNull()){RowCreated=rez-\>FieldByName("RowCreated")-\>Value.operator TDateTime();}
    if (!rez-\>FieldByName("RowUpdated")-\>Value.IsNull()){RowUpdated=rez-\>FieldByName("RowUpdated")-\>Value.operator TDateTime();}
    delete rez;
    }else
    {
    Obd::init();
    init();
    delete rez;
    }
return CanUse();
}

bool         TreeRow::SetData(
                    const int &amp;_id,    const int &amp;_idparent,const int &amp;_SpRazd,    const int &amp;_pp,
                    const int &amp;_ppp,    const int &amp;_ei,        const int &amp;_state,    const int &amp;_UserID,
                    const String &amp;_Obd,        const String &amp;_Obu,
                    const String &amp;_Name,    const String &amp;_SpRazdName,
                    const String &amp;_format,    const String &amp;_pos,        const String &amp;_prim,
                    const String &amp;_zona,        const String &amp;_ppName,    const String &amp;_eiName,
                    const String &amp;_User,        const String &amp;_CondName,    const String &amp;_DetCreator,
                    const String &amp;_DetUpdater,    const String &amp;_RowCreator,
                    const String &amp;_RowUpdater,    const double &amp;_kol,
                    const bool &amp;_arhive,    const bool &amp;_CanChild,    const bool &amp;_Accept,
                    const TDateTime  &amp;_DetCreated,    const TDateTime  &amp;_DetUpdated,
                    const TDateTime  &amp;_RowCreated,    const TDateTime  &amp;_RowUpdated
                    )
{
if (ItTrueClassName())
    {
    SetId(_id);// базовый класс
    SpRazd=_SpRazd;
    SetObd(_Obd);
    Name=_Name.Trim();
    SpRazdName=_SpRazdName.Trim();
    // текущий класс
    idparent=_idparent;
    pp=_pp;
    ppp=_ppp;
    ei=_ei;
    state=_state;
    UserID=_UserID;
    SetObu(_Obu);
    format=_format.Trim();
    pos=_pos.Trim();
    prim=_prim.Trim();
    zona=_zona.Trim();
    ppName=_ppName.Trim();
    eiName=_eiName.Trim();
    User=_User.Trim();
    CondName=_CondName.Trim();
    DetCreator=_DetCreator.Trim();
    DetUpdater=_DetUpdater.Trim();
    RowCreator=_RowCreator.Trim();
    RowUpdater=_RowUpdater.Trim();
    kol=_kol;
    Arhive=_arhive;
    Set_Force(false);
    CanChild=_CanChild;
    Accept=_Accept;
    DetCreated=_DetCreated;
    DetUpdated=_DetUpdated;
    RowCreated=_RowCreated;
    RowUpdated=_RowUpdated;
    }
return CanUse();
}                    
</code>

@@TreeRow.h
Description
Класс данных для построения дерева спецификации и самой
спецификации (файл заголовков)
C++ Syntax
<code lang="c++">


\#ifndef TreeRowH
\#define TreeRowH
\#include "Obd.h"

class TreeRow:public Obd
    {
    public:
        TreeRow        (cSQL *const db,const int &amp;User);
        TreeRow        (const TreeRow &amp;r);
        ~TreeRow    (void);
        bool UpdateVal     (void);
        void Set_Force(const bool force){Force=force;};

        String Get_Text (void)    const{return G_Obd+" - "+Name+" - "+String(kol)+eiName;};
        int Get_ParentID(void)    const{return idparent;};
        int Get_pp(void)        const{return pp;};
        int Get_ppp(void)        const{return ppp;};
        int Get_ei(void)        const{return ei;};
        int Get_state(void)        const{return state;};
        int Get_UserID(void)    const{return UserID;};
        String Get_Obu(bool gost)const{return gost?G_Obu:V_Obu;};
        String Get_format(void)    const{return format;};
        String Get_pos(void)    const{return pos;};
        String Get_prim(void)    const{return prim;};
        String Get_zona(void)    const{return zona;};
        String Get_ppName(void)    const{return ppName;};
        String Get_eiName(void)    const{return eiName;};
        String Get_User(void)    const{return User;};
        String Get_CondName(void)    const{return CondName;};
        String Get_DetCreator(void)    const{return DetCreator;};
        String Get_DetUpdater(void)    const{return DetUpdater;};
        String Get_RowCreator(void)    const{return RowCreator;};
        String Get_RowUpdater(void)    const{return RowUpdater;};
        double Get_kol(void)        const{return kol;};
        bool Get_Arhive(void)        const{return Arhive;};
        bool Get_Force(void)        const{return Force;};
        bool Get_CanChild(void)        const{return CanChild;};
        bool Get_Accept(void)        const{return Accept;};
        TDateTime  Get_DetCreated(void)    const{return DetCreated;};
        TDateTime  Get_DetUpdated(void)    const{return DetUpdated;};
        TDateTime  Get_RowCreated(void)    const{return RowCreated;};
        TDateTime  Get_RowUpdated(void)    const{return RowUpdated;};

        bool SetData(
                    const int &amp;_id,    const int &amp;_idparent,const int &amp;_SpRazd,    const int &amp;_pp,
                    const int &amp;_ppp,    const int &amp;_ei,        const int &amp;_state,    const int &amp;_UserID,
                    const String &amp;_Obd,        const String &amp;_Obu,
                    const String &amp;_Name,    const String &amp;_SpRazdName,
                    const String &amp;_format,    const String &amp;_pos,        const String &amp;_prim,
                    const String &amp;_zona,        const String &amp;_ppName,    const String &amp;_eiName,
                    const String &amp;_User,        const String &amp;_CondName,    const String &amp;_DetCreator,
                    const String &amp;_DetUpdater,    const String &amp;_RowCreator,
                    const String &amp;_RowUpdater,    const double &amp;_kol,
                    const bool &amp;_arhive,    const bool &amp;_CanChild,    const bool &amp;_Accept,
                    const TDateTime  &amp;_DetCreated,    const TDateTime  &amp;_DetUpdated,
                    const TDateTime  &amp;_RowCreated,    const TDateTime  &amp;_RowUpdated
                    );

        TreeRow &amp;     operator =(const TreeRow &amp;);
        bool           operator ==    (const TreeRow &amp;);
        bool           operator !=    (const TreeRow &amp;);

        bool ItTrueClassName (void)const{return TrueClassName()=="TreeRow"?true:false;}
        String TrueClassName (void)const{return "TreeRow";};
        bool CanUse    (void)        const{return (id\>0&amp;&amp;Get_Obd(false)!="")?true:false;};

        int    Count    (void)const{return count;};
    private:

        int idparent;
        int pp;
        int ppp;
        int ei;
        int state;
        int UserID;
        String V_Obu;
        String G_Obu;
        String format;
        String pos;
        String prim;
        String zona;
        String ppName;
        String eiName;
        String User;
        String CondName;
        String DetCreator;
        String DetUpdater;
        String RowCreator;
        String RowUpdater;
        double kol;
        bool Arhive;
        bool Force;
        bool CanChild;
        bool Accept;
        TDateTime  DetCreated;
        TDateTime  DetUpdated;
        TDateTime  RowCreated;
        TDateTime  RowUpdated;

        const int &amp;LUser;
        static int count;

        void init        (void);
        void SetObu     (const String &amp;r);
        void SetObd     (const String &amp;r);
        void SetId       (const int &amp;r);
    protected:
    };

int  TreeRow::count=0;
\#endif

</code>

@@TCond::BitBtn3
Description
Кнопка "Принять"

@@TCond::BitBtn4
Description
Кнопка "Отмена".

@@TCond::CondName
Description
Строка вывода названия состояния

@@TCond::current
Description
Кнопка установки сменного состояния в позицию "текущее"

@@TCond::next
Description
Кнопка установки сменного состояния в позицию "Следующее"

@@TCond::prev
Description
Кнопка установки сменного состояния в позицию "Предудущее"

@@TCond::DB
Description
Указатель на класс для работы с базой данных

@@TCond::IcoData
Description
Указатель на класс работы с контейнерами изображений

@@TCond::IDS
Description
Накопительная переменная, содержащая список идентификаторов
узлов/деталей для которых меняется состояние

@@TCond::IMG
Description
Место вывода иконки состояния объекта выделенного мышью в
списке объектов для смены состояния

@@TCond::LUser
Description
Ссылка на идентификатор пользователя работающего в программе

@@TCond::MassAction
Description
Индикатор массовых действий. В данном случае показывает
необходимость смены состояний в составе выбранного узла

@@TCond::Panel1
Description
Визуальный компонент для размещения элементов управления.

@@TCond::RG1
Description
Группа переключателей, отвечающая за работы кнопок смены
состояний
  * Все &#45; состояния будут меняться у всего списка
    отображаемых элементов
  * Выбранные &#45; состояния будут меняться только у
    выделенных элементов списка

@@TCond::RG2
Description
Группа переключателей отвечающая за смену состояний при
MassAction=true (сквозная смена состояний у всего состава)
  * Все &#45; состояния сменятся у всех элементов состава
    отвечающих требованиям
  * Кроме стандартных &#45; Смена состояний для стандартных
    элементов не будет произведена
  * Только оригинальные&#45; Смена состояния будет проведена
    только для оригинальных деталей, имеющих такуюже структуру
    обозначения что и выбранный для смены состояния узел


@@TCond::TV
Description
Визуальный компонент для вывода списка элементов для которых
меняется состояние

@@TCond::BitBtn3Click@TObject *
Description
Обработчик нажатия для TCond::BitBtn3
C++ Syntax
<code lang="c++">
void __fastcall TCond::BitBtn3Click(TObject *Sender)
{
//кнопка применить
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        ChangeCondition((CRowData*)node-\>Data);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        ChangeCondition((CRowData*)TV-\>Selections[i]-\>Data);
        }
    }
if (MassAction)
    {
    DB-\>SendCommand("Call constructions.ChangeStates('"+IDS+"','0','0','"+IntToStr(RG2-\>ItemIndex+1)+"')");
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TCond::ChangeCondition@CRowData *
Description
Функция для смены в базе текущих состояний на выбранные.
C++ Syntax
<code lang="c++">
bool              TCond::ChangeCondition(CRowData *row)
{
// сменить состояние на GetSelectedState  в зависимости от режима смены состояний
if (!row) {return false;}
if (row-\>GetCurrState()==row-\>GetSelectedState()){return true;}
String sql="";
if (MassAction)
    {
    sql="Call constructions.ChangeStates('0','"+String(row-\>GetCurrState())+"','"+String(row-\>GetSelectedState())+"','0')";
    }else
    {
    sql="Call constructions.ChangeState("+String(row-\>GetID())+","+String(row-\>GetSelectedState())+")";
    }
if(sql.Length())
    {
    DB-\>SendCommand(sql);
    return true;
    }
return false;
}
</code>

@@TCond::FormShow@TObject *
Description
Обработчик события "показать форму"
C++ Syntax
<code lang="c++">
void __fastcall TCond::FormShow(TObject *Sender)
{
SetFocus();
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TCond::SelectNextState@CRowData *
Description
Функция выбора следующего состояния в случае невозможности
автоматического назначения.
C++ Syntax
<code lang="c++">
void              TCond::SelectNextState(CRowData *row)
{
TStSelect *wnd=new TStSelect(this,DB,IcoData,row-\>GetSelectedState(),LUser);
CRowData *Row=0;
wnd-\>ShowModal();    //спросить куда отправить
if (wnd-\>ModalResult==mrOk)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode(); node; node=node-\>GetNext())
        {
        if (!RG1-\>ItemIndex)
            {
            Row=(CRowData *)node-\>Data;
            if (Row-\>GetCurrState()==row-\>GetCurrState()&amp;&amp;Row-\>GetNextState()==-1)
                {
                Row-\>SetNextState(wnd-\>NextState,wnd-\>NextStateName,wnd-\>NextStateAccept);
                Row-\>TurnNextState();
                }
            }else
            {
            if (node-\>Selected)
                {
                Row=(CRowData *)node-\>Data;
                if (Row-\>GetCurrState()==row-\>GetCurrState()&amp;&amp;Row-\>GetNextState()==-1)
                    {
                    Row-\>SetNextState(wnd-\>NextState,wnd-\>NextStateName,wnd-\>NextStateAccept);
                    Row-\>TurnNextState();
                    }
                }
            }
        }
    }
delete wnd;
}
</code>
Type Parameters
row :  Указатель на объект класса данных, в котором возникли
       трудности с назначением состояния

@@TCond::currentClick@TObject *
Description
Обработчик нажатия кнопки TCond::current
C++ Syntax
<code lang="c++">
void __fastcall TCond::currentClick(TObject *Sender)
{
CRowData* row=0;
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        row=(CRowData*)node-\>Data;
        row-\>TurnCurrState();
         node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        row=(CRowData*)TV-\>Selections[i]-\>Data;
        row-\>TurnCurrState();
        TV-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }
TVClick(TV);
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TCond::nextClick@TObject *
Description
Обработчик нажатия кнопки TCond::next
C++ Syntax
<code lang="c++">
void __fastcall TCond::nextClick(TObject *Sender)
{
CRowData* row=0;
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        row=(CRowData*)node-\>Data;
        if (!row-\>TurnNextState())
            {
            if (row-\>GetArhive())
                {
                SelectNextState(row);
                }
            }
        node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        row=(CRowData*)TV-\>Selections[i]-\>Data;
        row-\>TurnNextState();
        if (!row-\>TurnNextState())
            {
            if (row-\>GetArhive())
                {
                SelectNextState(row);
                }
            }
        TV-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }
TVClick(TV);
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TCond::prevClick@TObject *
Description
Обработчик нажатия кнопки TCond::prev
C++ Syntax
<code lang="c++">
void __fastcall TCond::prevClick(TObject *Sender)
{
CRowData* row=0;
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        row=(CRowData*)node-\>Data;
        if (!row-\>TurnPrevState())
            {
            row-\>TurnCurrState();
            }
         node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        row=(CRowData*)TV-\>Selections[i]-\>Data;
        if (!row-\>TurnPrevState())
            {
            row-\>TurnCurrState();
            }
        TV-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }
TVClick(TV);
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TCond::TVClick@TObject *
Description
Обработчик события возникающем при щелчке мыши на TCond::TV.
Отображает информацию о выбранном состоянии выделенного
элемента
C++ Syntax
<code lang="c++">
void __fastcall TCond::TVClick(TObject *Sender)
{
TTreeView *TView=(TTreeView *)Sender;
if (!TView-\>Items-\>Count||!TView-\>Selected) {return;}
CRowData *row;
row=(CRowData *)TView-\>Selected-\>Data;
if (row)
    {
    IMG-\>Picture-\>Bitmap=0;
    TImageList *ico=IcoData-\>GetStateList();
    ico-\>GetBitmap(IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0),IMG-\>Picture-\>Bitmap);
    CondName-\>Caption=row-\>GetSelectedStateName();
    }
}
</code>

Type Parameters
Sender :  указатель на объект вызвавший функцию

@@TCond::TVMouseDown@TObject *@TMouseButton@TShiftState@int@int
Description
Обработчик события возникающем при нажатии кнопки мыши на
TCond::TV. Осуществляет управление выделением объектов списка
C++ Syntax
<code lang="c++">
void __fastcall TCond::TVMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y)
{
TTreeView *TView=(TTreeView *)Sender;
if (!TView-\>Items-\>Count||!TView-\>GetNodeAt(X,Y)) {return;}
if (Shift.ToInt()!=17&amp;&amp;Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=20&amp;&amp;Shift.ToInt()!=9)
{
TView-\>ClearSelection();
}
if (Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=9)
{
TView-\>Select(TView-\>GetNodeAt(X,Y),Shift);
TView-\>GetNodeAt(X,Y)-\>Focused=true;
}
TView-\>Repaint();
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию
Button :  Идентификатор нажатой кнопки мыши
Shift :   Идентификатор состоняния кнопок Shift Alt Ctrl
X :       координата по оси X
Y :       координата по оси Y

@@TCond
Description
Класс для смены состояний выбранных узлов/деталей и входящих
в их состав деталей.


Note
  * При MassAction=false происходит смена состояния
    непосредственно в выбранных узлах/деталях.
  * При MassAction=true происходит смена состояния у
    выбранных узлов/деталей и у узлов и деталей входящих в их
    состав, при условии что они находятся в томже состоянии что и
    выбранных узел/деталь

@@Conditions.cpp
Description
Класс для смены состояний выбранных узлов/деталей и входящих
в их состав деталей. (файл описаний)
C++ Syntax
<code lang="c++">
\#include \<vcl.h\>
\#pragma hdrstop

\#include "Conditions.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)
\#pragma resource "*.dfm"


__fastcall TCond::TCond(TComponent* Owner,/*const */TTreeView &amp;Tree,
                        const bool &amp;_MassAction,cSQL *db,IconsData *_IcoData,const int &amp;User)
    \: TForm(Owner),MassAction(_MassAction),LUser(User)
{
DB=db;
IcoData=_IcoData;
TV-\>StateImages=IcoData-\>GetStateList();
TV-\>Images=IcoData-\>GetImgList();

IDS="";
CRowData *row=0;
Obd *bag=0;
TreeRow *Row=0;
TTreeNode *node=0;

String ids="";
String sql;
TADOQuery *rez=0;

if (_MassAction)
    {
    RG2-\>Enabled=true;
    for (unsigned int i=0; i\<Tree.SelectionCount; i++)
        {
        bag=(Obd *)Tree.Selections[i]-\>Data;
        if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
            {
            Row=(TreeRow*)bag;
            ids=ids+String(Row-\>Get_ID())+",";// собрать все выделенные ид деталей и узлов
            }
        }
    ids.Delete(ids.Length(),1);  //-- переменную сделать общекласовой (потребуется при массовых действиях)
    IDS=ids;
    sql="Call GetTreeConditions('"+ids+"','"+LUser+"')";
    rez=DB-\>SendSQL(sql);
    if (rez&amp;&amp;rez-\>RecordCount)     //  получить возможные смены, там где (GetTreeConditions)
        {                          //  значений нет оставить принятие решения при нажатии на кнопку смены
        rez-\>First();
        while (!rez-\>Eof)
            {
            int id,CurrState,NextState,PrevState;
            String text,CurrStateName,NextStateName,PrevStateName;
            bool Accept,Arhive,NextAccept,PrevAccept;

            CurrState=rez-\>FieldByName("CurrState")-\>Value;
            CurrStateName=rez-\>FieldByName("CurrName")-\>Value;
            Accept=true;
            Arhive=rez-\>FieldByName("Arhive")-\>Value;
            NextState=rez-\>FieldByName("NextState")-\>Value;
            NextStateName=rez-\>FieldByName("NextName")-\>Value;
            NextAccept=rez-\>FieldByName("NextAccept")-\>Value;
            PrevState=rez-\>FieldByName("PrevState")-\>Value;
            PrevStateName=rez-\>FieldByName("PrevName")-\>Value;
            PrevAccept=rez-\>FieldByName("PrevAccept")-\>Value;
            id=-1;
            text="";

            row=new CRowData(MassAction,id,CurrState,NextState,PrevState,
                            text,CurrStateName,NextStateName,PrevStateName,
                            Accept,Arhive,NextAccept,PrevAccept);

            node=TV-\>Items-\>AddObject(0,CurrStateName,row);
            node-\>ImageIndex=IcoData-\>GetInList(CurrState,Accept,3);
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),Accept,0);
            rez-\>Next();
            }
        }
    delete rez;
    rez=0;
    }else
    {
    RG2-\>Enabled=false;
    for (unsigned int i=0; i\<Tree.SelectionCount; i++)
        {
        bag=(Obd *)Tree.Selections[i]-\>Data;
        if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
               {
            Row=(TreeRow*)bag;
            if (Row-\>Get_Accept())
                {
                row=new CRowData(MassAction,Row-\>Get_ID(),Row-\>Get_state(),-1,-1,
                                Row-\>Get_Text(),Row-\>Get_CondName(),"","",
                                Row-\>Get_Accept(),Row-\>Get_Arhive(),false,false);
                node=TV-\>Items-\>AddObject(0,row-\>GetText(),row);
                node-\>ImageIndex=IcoData-\>GetInList(Row-\>Get_SpRazd(),true,1);
                node-\>SelectedIndex=node-\>ImageIndex;
                node-\>ExpandedImageIndex=node-\>ImageIndex;
                node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
                if (!ids.Pos(String(row-\>GetSelectedState())+","))
                    {
                    ids=ids+String(row-\>GetSelectedState())+","; // коллекционировать ид состояний,
                    }
                }
            }
        }
    ids.Delete(ids.Length(),1);
    sql="Call GetAvailableConditions('"+ids+"','"+LUser+"')" ;
    rez=DB-\>SendSQL(sql);
    if (rez&amp;&amp;rez-\>RecordCount)     //  получить возможные смены, там где (GetAvailableConditions)
        {                          //  значений нет оставить принятие решения при нажатии на кнопку смены
        rez-\>First();
        while (!rez-\>Eof)
            {
            for (node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
                {
                row=(CRowData*)node-\>Data;
                if (row-\>GetCurrState()==rez-\>FieldByName("CurrState")-\>Value)
                    {
                    row-\>SetNextState(rez-\>FieldByName("NextState")-\>Value,rez-\>FieldByName("NextName")-\>Value,rez-\>FieldByName("NextAccept")-\>Value);
                    row-\>SetPrevState(rez-\>FieldByName("PrevState")-\>Value,rez-\>FieldByName("PrevName")-\>Value,rez-\>FieldByName("PrevAccept")-\>Value);
                    }
                }
            rez-\>Next();
            }
        }
    delete rez;
    }
}
void __fastcall TCond::FormShow(TObject *Sender)
{
SetFocus();
}
void __fastcall TCond::nextClick(TObject *Sender)
{
CRowData* row=0;
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        row=(CRowData*)node-\>Data;
        if (!row-\>TurnNextState())
            {
            if (row-\>GetArhive())
                {
                SelectNextState(row);
                }
            }
        node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        row=(CRowData*)TV-\>Selections[i]-\>Data;
        row-\>TurnNextState();
        if (!row-\>TurnNextState())
            {
            if (row-\>GetArhive())
                {
                SelectNextState(row);
                }
            }
        TV-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }
TVClick(TV);
}
void __fastcall TCond::currentClick(TObject *Sender)
{
CRowData* row=0;
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        row=(CRowData*)node-\>Data;
        row-\>TurnCurrState();
         node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        row=(CRowData*)TV-\>Selections[i]-\>Data;
        row-\>TurnCurrState();
        TV-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }
TVClick(TV);
}
void __fastcall TCond::prevClick(TObject *Sender)
{
CRowData* row=0;
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        row=(CRowData*)node-\>Data;
        if (!row-\>TurnPrevState())
            {
            row-\>TurnCurrState();
            }
         node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        row=(CRowData*)TV-\>Selections[i]-\>Data;
        if (!row-\>TurnPrevState())
            {
            row-\>TurnCurrState();
            }
        TV-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
        }
    }
TVClick(TV);
}
void __fastcall TCond::BitBtn3Click(TObject *Sender)
{
//кнопка применить
if (!RG1-\>ItemIndex)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
        {
        ChangeCondition((CRowData*)node-\>Data);
        }
    }else
    {
    for (unsigned int i=0; i\<TV-\>SelectionCount; i++)
        {
        ChangeCondition((CRowData*)TV-\>Selections[i]-\>Data);
        }
    }
if (MassAction)
    {
    DB-\>SendCommand("Call ChangeStates('"+IDS+"','0','0','"+IntToStr(RG2-\>ItemIndex+1)+"')");
    }
}
bool              TCond::SelectNextState(CRowData *row)
{
TStSelect *wnd=new TStSelect(this,DB,IcoData,row-\>GetSelectedState(),LUser);
CRowData *Row=0;
wnd-\>ShowModal();    //спросить куда отправить
if (wnd-\>ModalResult==mrOk)
    {
    for (TTreeNode *node=TV-\>Items-\>GetFirstNode(); node; node=node-\>GetNext())
        {
        if (!RG1-\>ItemIndex)
            {
            Row=(CRowData *)node-\>Data;
            if (Row-\>GetCurrState()==row-\>GetCurrState()&amp;&amp;Row-\>GetNextState()==-1)
                {
                Row-\>SetNextState(wnd-\>NextState,wnd-\>NextStateName,wnd-\>NextStateAccept);
                Row-\>TurnNextState();
                }
            }else
            {
            if (node-\>Selected)
                {
                Row=(CRowData *)node-\>Data;
                if (Row-\>GetCurrState()==row-\>GetCurrState()&amp;&amp;Row-\>GetNextState()==-1)
                    {
                    Row-\>SetNextState(wnd-\>NextState,wnd-\>NextStateName,wnd-\>NextStateAccept);
                    Row-\>TurnNextState();
                    }
                }
            }
        }
    }
delete wnd;
}
bool              TCond::ChangeCondition(CRowData *row)
{
// сменить состояние на GetSelectedState  в зависимости от режима смены состояний
if (!row) {return false;}
if (row-\>GetCurrState()==row-\>GetSelectedState()){return true;}
String sql="";
if (MassAction)
    {
    DB-\>SendCommand("Call ChangeStates('0','"+String(row-\>GetCurrState())+"','"+String(row-\>GetSelectedState())+"','0')");
    }else
    {
    sql="Call ChangeState("+String(row-\>GetID())+","+String(row-\>GetSelectedState())+")";
    }
if(sql.Length())
    {
    DB-\>SendCommand(sql);
    return true;
    }
return false;
}

void __fastcall TCond::TVMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y)
{
TTreeView *TView=(TTreeView *)Sender;
if (!TView-\>Items-\>Count||!TView-\>GetNodeAt(X,Y)) {return;}
if (Shift.ToInt()!=17&amp;&amp;Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=20&amp;&amp;Shift.ToInt()!=9)
{
TView-\>ClearSelection();
}
if (Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=9)
{
TView-\>Select(TView-\>GetNodeAt(X,Y),Shift);
TView-\>GetNodeAt(X,Y)-\>Focused=true;
}
TView-\>Repaint();
}

void __fastcall TCond::TVClick(TObject *Sender)
{
TTreeView *TView=(TTreeView *)Sender;
if (!TView-\>Items-\>Count||!TView-\>Selected) {return;}
CRowData *row;
row=(CRowData *)TView-\>Selected-\>Data;
if (row)
    {
    IMG-\>Picture-\>Bitmap=0;
    TImageList *ico=IcoData-\>GetStateList();
    ico-\>GetBitmap(IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0),IMG-\>Picture-\>Bitmap);
    CondName-\>Caption=row-\>GetSelectedStateName();
    }
}
</code>

@@Conditions.h
Description
Класс для смены состояний выбранных узлов/деталей и входящих
в их состав деталей. (файл заголовков)
C++ Syntax
<code lang="c++">

\#ifndef ConditionsH
\#define ConditionsH

\#include "selector.h"
\#include "CRowData.h"
\#include "TreeRow.h"

\#include \<Buttons.hpp\>
\#include \<Classes.hpp\>
\#include \<ComCtrls.hpp\>
\#include \<Controls.hpp\>
\#include \<ExtCtrls.hpp\>
\#include \<StdCtrls.hpp\>


class TCond : public TForm
{
__published:
    TPanel         *Panel1;
    TButton     *prev;
    TButton     *next;
    TButton     *current;
    TRadioGroup *RG1;
    TImage         *IMG;
    TLabel         *CondName;
    TBitBtn     *BitBtn3;
    TBitBtn     *BitBtn4;
    TTreeView     *TV;
    TRadioGroup *RG2;
    void __fastcall FormShow(TObject *Sender);
    void __fastcall nextClick(TObject *Sender);
    void __fastcall currentClick(TObject *Sender);
    void __fastcall prevClick(TObject *Sender);
    void __fastcall BitBtn3Click(TObject *Sender);
    void __fastcall TVMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y);
    void __fastcall TVClick(TObject *Sender);
private:
cSQL         *DB;
IconsData     *IcoData;
const int &amp;LUser;
bool         MassAction;
String         IDS;
bool  ChangeCondition(CRowData *row);
bool  SelectNextState(CRowData *row);
public:
    __fastcall TCond(TComponent* Owner,/*const */TTreeView &amp;Tree,const bool &amp;_MassAction,cSQL *db,IconsData *_IcoData,const int &amp;User);
};
\#endif

</code>

@@TCond::TCond@TComponent*@TTreeView &@bool &@cSQL *@IconsData *@int &
Description
Конструктор.
C++ Syntax
<code lang="c++">
__fastcall TCond::TCond(TComponent* Owner,TTreeView &amp;Tree,
                        const bool &amp;_MassAction,cSQL *db,IconsData *_IcoData,const int &amp;User)
    \: TForm(Owner),MassAction(_MassAction),LUser(User)
{
DB=db;
IcoData=_IcoData;
TV-\>StateImages=IcoData-\>GetStateList();
TV-\>Images=IcoData-\>GetImgList();

IDS="";
CRowData *row=0;
Obd *bag=0;
TreeRow *Row=0;
TTreeNode *node=0;

String ids="";
String sql;
TADOQuery *rez=0;

if (_MassAction)
    {
    RG2-\>Enabled=true;
    for (unsigned int i=0; i\<Tree.SelectionCount; i++)
        {
        bag=(Obd *)Tree.Selections[i]-\>Data;
        if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
            {
            Row=(TreeRow*)bag;
            ids=ids+String(Row-\>Get_ID())+",";// собрать все выделенные ид деталей и узлов
            }
        }
    ids.Delete(ids.Length(),1);  //-- переменную сделать общекласовой (потребуется при массовых действиях)
    IDS=ids;
    sql="Call constructions.GetTreeConditions('"+ids+"','"+LUser+"')";
    rez=DB-\>SendSQL(sql);
    if (rez&amp;&amp;rez-\>RecordCount)     //  получить возможные смены, там где (GetTreeConditions)
        {                          //  значений нет оставить принятие решения при нажатии на кнопку смены
        rez-\>First();
        while (!rez-\>Eof)
            {
            int id,CurrState,NextState,PrevState;
            String text,CurrStateName,NextStateName,PrevStateName;
            bool Accept,Arhive,NextAccept,PrevAccept;

            CurrState=rez-\>FieldByName("CurrState")-\>Value;
            CurrStateName=rez-\>FieldByName("CurrName")-\>Value;
            Accept=true;
            Arhive=rez-\>FieldByName("Arhive")-\>Value;
            NextState=rez-\>FieldByName("NextState")-\>Value;
            NextStateName=rez-\>FieldByName("NextName")-\>Value;
            NextAccept=rez-\>FieldByName("NextAccept")-\>Value;
            PrevState=rez-\>FieldByName("PrevState")-\>Value;
            PrevStateName=rez-\>FieldByName("PrevName")-\>Value;
            PrevAccept=rez-\>FieldByName("PrevAccept")-\>Value;
            id=-1;
            text="";

            row=new CRowData(MassAction,id,CurrState,NextState,PrevState,
                            text,CurrStateName,NextStateName,PrevStateName,
                            Accept,Arhive,NextAccept,PrevAccept);

            node=TV-\>Items-\>AddObject(0,CurrStateName,row);
            node-\>ImageIndex=IcoData-\>GetInList(CurrState,Accept,3);
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),Accept,0);
            rez-\>Next();
            }
        }
    delete rez;
    rez=0;
    }else
    {
    RG2-\>Enabled=false;
    for (unsigned int i=0; i\<Tree.SelectionCount; i++)
        {
        bag=(Obd *)Tree.Selections[i]-\>Data;
        if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
               {
            Row=(TreeRow*)bag;
            if (Row-\>Get_Accept())
                {
                row=new CRowData(MassAction,Row-\>Get_ID(),Row-\>Get_state(),-1,-1,
                                Row-\>Get_Text(),Row-\>Get_CondName(),"","",
                                Row-\>Get_Accept(),Row-\>Get_Arhive(),false,false);
                node=TV-\>Items-\>AddObject(0,row-\>GetText(),row);
                node-\>ImageIndex=IcoData-\>GetInList(Row-\>Get_SpRazd(),true,1);
                node-\>SelectedIndex=node-\>ImageIndex;
                node-\>ExpandedImageIndex=node-\>ImageIndex;
                node-\>StateIndex=IcoData-\>GetInList(row-\>GetSelectedState(),row-\>GetSelectedAccept(),0);
                if (!ids.Pos(String(row-\>GetSelectedState())+","))
                    {
                    ids=ids+String(row-\>GetSelectedState())+","; // коллекционировать ид состояний,
                    }
                }
            }
        }
    ids.Delete(ids.Length(),1);
    if (ids!="")
        {
        sql="Call constructions.GetAvailableConditions('"+ids+"','"+LUser+"')" ;
        rez=DB-\>SendSQL(sql);
        if (rez&amp;&amp;rez-\>RecordCount)     //  получить возможные смены, там где (GetAvailableConditions)
            {                          //  значений нет оставить принятие решения при нажатии на кнопку смены
            rez-\>First();
            while (!rez-\>Eof)
                {
                for (node=TV-\>Items-\>GetFirstNode();node; node=node-\>getNextSibling())
                    {
                    row=(CRowData*)node-\>Data;
                    if (row-\>GetCurrState()==rez-\>FieldByName("CurrState")-\>Value)
                        {
                        row-\>SetNextState(rez-\>FieldByName("NextState")-\>Value,rez-\>FieldByName("NextName")-\>Value,rez-\>FieldByName("NextAccept")-\>Value);
                        row-\>SetPrevState(rez-\>FieldByName("PrevState")-\>Value,rez-\>FieldByName("PrevName")-\>Value,rez-\>FieldByName("PrevAccept")-\>Value);
                        }
                    }
                rez-\>Next();
                }
            }
        delete rez;
        }
    }
}
</code>
Type Parameters
Owner :        Указатель на объект в котором был создан данных
               экземпляр класса
Tree :         Ссылка на список объектов для изменения
               состояния
_MassAction :  Индикатор массовых действий
db :           Указатель на класс для работы с базой данных
_IcoData :     Указатель на класс для работы с контейнерами
               изображений
User :         Ссылка на идентификатор пользователя
               работающего с программой

@@TSpTree::TreeMouseDown@TObject *@TMouseButton@TShiftState@int@int
Description
Обработчик нажатия кнопки мыши на TSpTree::Tree
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::TreeMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y)
{
TTreeView* TV=(TTreeView*)Sender;
Selection(TV,Shift,X,Y);
TTreeNode *node=TV-\>GetNodeAt(X,Y);
if (!node) {return;}
if (node==TV-\>Selected&amp;&amp;memo)
    {
    memo-\>Lines-\>Clear();
    if (node-\>Data)
        {
        Obd *bag=(Obd *)node-\>Data;
        if (bag-\>TrueClassName()=="TreeRow")
            {
            TreeRow* row=(TreeRow*)bag;
            if (row-\>Get_CanChild())
                {
                node=node-\>getFirstChild();
                }
            }
        if (bag-\>TrueClassName()=="FileRow")
            {
            node=node-\>Parent;
            }
        GetInfo(node);
        }
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию
Button :  Индентификатор нажатой кнопки мыши
Shift :   Индикатор состояния кнопок Shift Alt Ctrl
X :       Координата курсока по оси X
Y :       Координата курсока по оси Y

@@TSpTree::Selection@TTreeView *@TShiftState@int@int
Description
Функция для управления выделением элементов в дереве
Type Parameters
TView :  Указатель на управляемое дерево 
Shift :  Индикатор состояния кнопок Shift Alt Ctrl
X :      Координата курсора по оси X
Y :      Координата курсора по оси Y

C++ Syntax
<code lang="c++">
void TSpTree::Selection(TTreeView *TView,TShiftState Shift,int X, int Y)
{
if (!TView-\>Items-\>Count||!TView-\>GetNodeAt(X,Y)) {return;}
if (Shift.ToInt()!=17&amp;&amp;Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=20&amp;&amp;Shift.ToInt()!=9)
    {
    TView-\>ClearSelection();
    }
if (Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=9)
    {
    TView-\>Select(TView-\>GetNodeAt(X,Y),Shift);
    TView-\>GetNodeAt(X,Y)-\>Focused=true;
    }
TView-\>Repaint();
}
</code>

@@TSpTree::TreeAdvancedCustomDrawItem@TCustomTreeView *@TTreeNode *@TCustomDrawState@TCustomDrawStage@bool &@bool &
Description
Функция для отрисовки узла
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::TreeAdvancedCustomDrawItem(TCustomTreeView *Sender, TTreeNode *Node,
          TCustomDrawState State, TCustomDrawStage Stage, bool &amp;PaintImages,
          bool &amp;DefaultDraw)
{
TTreeView *TV=(TTreeView *)Sender;
DefaultDraw=true;
Obd *bag=(Obd *)Node-\>Data;
if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow *)bag;
    if (Node-\>Selected&amp;&amp;TV-\>Focused())   // В зависимости от того, выделен узел или нет
        {
        if (Row-\>Get_Accept())
            {
            if (LUser==Row-\>Get_UserID())
                {
                Sender-\>Canvas-\>Font-\>Color=clYellow; // разрешонный узел
                }
            }else
            {
            if (Row-\>Get_UserID()!=-1)
                {
                Sender-\>Canvas-\>Font-\>Color=clRed;  //заблокированный узел
                }else
                {
                Sender-\>Canvas-\>Font-\>Color=clWhite; // а это остальные
                }
            }                        // Используются разные цветовые схемы
        }else
        {
        if (Row-\>Get_Accept())
            {
            if (LUser==Row-\>Get_UserID())
                {
                Sender-\>Canvas-\>Font-\>Color=clGreen; // разрешонный узел
                }
            }else
            {
            if (Row-\>Get_UserID()!=-1)
                {
                Sender-\>Canvas-\>Font-\>Color=clRed; //заблокированный узел
                }else
                {
                Sender-\>Canvas-\>Font-\>Color=clBlack; // а это остальные
                }
            }
        }
    }
}
</code>
Type Parameters
Sender :       Указатель на объект вызвавший функцию
Node :         Указатель на рисуемый узел
State :        Индикатор
Stage :        Индикатор
PaintImages :  Индикатор рисования изображения
DefaultDraw :  Индикатор вызова отрисовщика заданного ко
               умолчанию

@@TSpTree::GetInfo@TTreeNode *
Description
Функция получения информации о выделенном объекте
C++ Syntax
<code lang="c++">
void              TSpTree::GetInfo(TTreeNode *Node)
{
Obd *bag=(Obd *)Node-\>Data;
TreeRow *tr(0);
FileRow *fl(0);
if (bag-\>ItTrueClassName())
    {
    tr=(TreeRow *)Node-\>Parent-\>Data;
    }else
    {
    tr=(TreeRow *)Node-\>Data;
    }

// расписать информацию об узле/детали
memo-\>Lines-\>Add("Информация по спецификации");
memo-\>Lines-\>Add("Деталь: "+tr-\>Get_Text());
memo-\>Lines-\>Add("Формат: "+tr-\>Get_format());
memo-\>Lines-\>Add("Зона: "+tr-\>Get_zona());
memo-\>Lines-\>Add("Позиция: "+tr-\>Get_pos());
memo-\>Lines-\>Add("Кол-во: "+String(tr-\>Get_kol())+" "+tr-\>Get_eiName());
memo-\>Lines-\>Add("Признак производства: "+IntToStr(tr-\>Get_pp())+" - "+tr-\>Get_ppName());
memo-\>Lines-\>Add("Примечание: "+tr-\>Get_prim());
memo-\>Lines-\>Add("");
// расписать информацию о блокираторах и создателях
memo-\>Lines-\>Add("Работы c деталью/спецификацией");
memo-\>Lines-\>Add("Текущее состояние: "+tr-\>Get_CondName());
String dat="";
if (tr-\>Get_DetCreated().Val){dat=tr-\>Get_DetCreated();}else{dat="";}
memo-\>Lines-\>Add("Дата создания: "+dat);
memo-\>Lines-\>Add("Создал: "+tr-\>Get_DetCreator());
if (tr-\>Get_DetUpdated().Val){dat=tr-\>Get_DetUpdated();}else{dat="";}
memo-\>Lines-\>Add("Дата редактирования: "+dat);
memo-\>Lines-\>Add("Редактировал: "+tr-\>Get_DetUpdater());
if (tr-\>Get_RowCreated().Val){dat=tr-\>Get_RowCreated();}else{dat="";}
memo-\>Lines-\>Add("Внесена в спец-ю: "+dat);
memo-\>Lines-\>Add("Внес: "+tr-\>Get_RowCreator());
if (tr-\>Get_RowUpdated().Val){dat=tr-\>Get_RowUpdated();}else{dat="";}
memo-\>Lines-\>Add("Редактирование спец-и:"+dat);
memo-\>Lines-\>Add("Редактировал: "+tr-\>Get_RowUpdater());
memo-\>Lines-\>Add("");
memo-\>Lines-\>Add("Занято пользователем: ");
memo-\>Lines-\>Add(tr-\>Get_User());
memo-\>Lines-\>Add("");
// расписать информацию о входящих файлах
if (Node-\>Count)
    {
    memo-\>Lines-\>Add("Количество прикрепленных файлов: "+IntToStr(Node-\>Count));
    TTreeNode *node=Node-\>getFirstChild();
    while (node)
        {
        bag=(Obd *)node-\>Data;
        if (bag&amp;&amp;bag-\>TrueClassName()=="FileRow")
            {
            FileRow *fl=(FileRow*)bag;
            if (fl)
                {
                memo-\>Lines-\>Add("Файл: "+fl-\>Get_FileName());//данные о файле
                //memo-\>Lines-\>Add("Текущее состояние: "+fl-\>CondName);
                if (fl-\>Get_DateOfCreate().Val){dat=fl-\>Get_DateOfCreate();}else{dat="";}
                memo-\>Lines-\>Add("Дата добавления: "+dat);
                memo-\>Lines-\>Add("Добавил: "+fl-\>Get_Creator());
                if (fl-\>Get_DateOfUpdate().Val){dat=fl-\>Get_DateOfUpdate();}else{dat="";}
                memo-\>Lines-\>Add("Обновлен: "+dat);
                memo-\>Lines-\>Add("Обновил: "+fl-\>Get_Updater());
               //    memo-\>Lines-\>Add("Занято пользователем: "+fl-\>User);
                memo-\>Lines-\>Add("");
                }
            }
        node=node-\>getNextSibling();
        }
    }
// расписать  инфо о дате последнего запуска в производство;
}
</code>
Type Parameters
Node :  Указатель на выделенный узел

@@TSpTree::N23Click@TObject *
Description
Обработчик кнопки "Обновить" (N23)
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N23Click(TObject *Sender)
{
int id=((Obd*)Tree-\>Items-\>GetFirstNode()-\>Data)-\>Get_ID();
LoadTree(id);
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSpTree::LoadTree@int
Description
Функция загрузки дерева спецификации по известному
идентификатору главного изделия
C++ Syntax
<code lang="c++">
void              TSpTree::LoadTree (int _id)
{
TreeClear();
TTreeNode *node;
TreeRow *row;
TADOQuery *rez;
String sql;
sql="Call constructions.LoadDet('"+String(_id)+"','"+String(LUser)+"')";  //загрузка информации о детали формировавние раздела документация
rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    int id,idparent,sprazd,pp,ppp,ei,state,userid;
    String obd,obu,name,sprazdname,format,pos,prim,zona,ppname,einame,user,condname,detcreator,
    detupdater,rowcreator,rowupdater;
    double kol;
    bool arhive,canchild,accept;
    TDateTime  detcreated,detupdated,rowcreated,rowupdated;

    rez-\>First();
    row=new TreeRow(DB,LUser);

    id=rez-\>FieldByName("idchild")-\>Value;
    idparent=rez-\>FieldByName("idparent")-\>Value;
    sprazd=rez-\>FieldByName("razdSPID")-\>Value;
    pp=rez-\>FieldByName("pp")-\>Value.operator UnicodeString().ToInt();
    ppp=rez-\>FieldByName("ppp")-\>Value.operator UnicodeString().ToInt();
    ei=rez-\>FieldByName("ei")-\>Value.operator UnicodeString().ToInt();
    state=rez-\>FieldByName("state")-\>Value;
    userid=rez-\>FieldByName("UserID")-\>Value;
    obd=rez-\>FieldByName("obd")-\>Value;
    obu=rez-\>FieldByName("obu")-\>Value;
    name=rez-\>FieldByName("name")-\>Value;
    sprazdname=rez-\>FieldByName("Razdname")-\>Value;
    format=rez-\>FieldByName("format")-\>Value;
    pos=rez-\>FieldByName("pos")-\>Value;
    prim=rez-\>FieldByName("prim")-\>Value;
    zona=rez-\>FieldByName("zona")-\>Value;
    ppname=rez-\>FieldByName("ppName")-\>Value;
    einame=rez-\>FieldByName("eiName")-\>Value;
    user=rez-\>FieldByName("User")-\>Value;
    condname=rez-\>FieldByName("CondName")-\>Value;
    detcreator=rez-\>FieldByName("DetCreator")-\>Value;
    detupdater=rez-\>FieldByName("DetUpdater")-\>Value;
    rowcreator=rez-\>FieldByName("RowCreator")-\>Value;
    rowupdater=rez-\>FieldByName("RowUpdater")-\>Value;
    kol=rez-\>FieldByName("kol")-\>Value;
    arhive=rez-\>FieldByName("arhive")-\>Value;
    canchild=rez-\>FieldByName("CanChild")-\>Value;
    accept=rez-\>FieldByName("Accept")-\>Value;
    if (!rez-\>FieldByName("DetCreated")-\>Value.IsNull()){detcreated=rez-\>FieldByName("DetCreated")-\>Value.operator TDateTime();}else{detcreated=0;}
    if (!rez-\>FieldByName("DetUpdated")-\>Value.IsNull()){detupdated=rez-\>FieldByName("DetUpdated")-\>Value.operator TDateTime();}else{detupdated=0;}
    if (!rez-\>FieldByName("RowCreated")-\>Value.IsNull()){rowcreated=rez-\>FieldByName("RowCreated")-\>Value.operator TDateTime();}else{rowcreated=0;}
    if (!rez-\>FieldByName("RowUpdated")-\>Value.IsNull()){rowupdated=rez-\>FieldByName("RowUpdated")-\>Value.operator TDateTime();}else{rowupdated=0;}
    row-\>SetData(id,idparent,sprazd,pp,ppp,ei,state,userid,obd,obu,name,
                sprazdname,format,pos,prim,zona,ppname,einame,user,
                condname,detcreator,detupdater,rowcreator,rowupdater,
                kol,arhive,canchild,accept,detcreated,detupdated,rowcreated,
                rowupdated);
    //создание узла
    node=Tree-\>Items-\>AddObject(0,row-\>Get_Text(),(void*)row);
    node-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
    node-\>SelectedIndex=node-\>ImageIndex;
    node-\>ExpandedImageIndex=node-\>ImageIndex;
    node-\>StateIndex=IcoData-\>GetInList(row-\>Get_state(),row-\>Get_Accept(),0);
    if (row-\>Get_CanChild())
        {
        Obd *r=new Obd(*((Obd*)row));
        r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация"); //создание раздела документация, прикрепление к нему фыйлов
        node=Tree-\>Items-\>AddChildObject(node,r-\>Get_SpRazdName(),(void*)r);
        node-\>ImageIndex=IcoData-\>GetInList(r-\>Get_SpRazd(),true,1);
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        }
    LoadFiles(node);
    if (row-\>Get_CanChild())
        {
        LoadBranch(Tree-\>Items-\>GetFirstNode());// если кен чилд то LoadBranch
        }
    }
if (Tree-\>Items-\>GetFirstNode())
    {
    Tree-\>Items-\>GetFirstNode()-\>Expand(false);
    }
delete rez;
}
</code>
Type Parameters
_id :  Идентификатог изделия для которого загружается состав

@@TSpTree::TreeClear
Description
Функция очистки дерева
C++ Syntax
<code lang="c++">
void TSpTree::TreeClear(void)
{
TTreeNode *node=Tree-\>Items-\>GetFirstNode();
while (node!=0)
    {
    if ((int)node-\>Data)
        {
        delete (Obd *)node-\>Data;
        }
    node=node-\>GetNext();
    }
Tree-\>Items-\>Clear();
}
</code>

@@TSpTree::LoadFiles@TTreeNode *
Description
Функция для загрузки информации о прикрепленных к детали
файлах в дерево спецификации
C++ Syntax
<code lang="c++">
void              TSpTree::LoadFiles(TTreeNode *Node)
{
FileRow *file;
TTreeNode *node;
int _id=((Obd*)Node-\>Data)-\>Get_ID();
String sql="Call constructions.LoadFiles('"+String(_id)+"','"+String(LUser)+"')";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    int id,sprazd,icoid;
    String obd,name,sprazdname,filename,filepath,creator,updater;
    bool accept;
    TDateTime dateofcreate,dateofupdate;
    while (!rez-\>Eof)
        {
        \file=new FileRow(DB,LUser); //создание ксаса свойств
        //заполнение свойств файла
        id=rez-\>FieldByName("id")-\>Value;
        sprazd=rez-\>FieldByName("razdSPID")-\>Value;
        icoid=rez-\>FieldByName("icoID")-\>Value;
        obd=rez-\>FieldByName("obd")-\>Value;
        name=rez-\>FieldByName("namd")-\>Value;
        sprazdname=rez-\>FieldByName("Razdname")-\>Value;
        filename=rez-\>FieldByName("FileName")-\>Value;
        filepath=rez-\>FieldByName("FilePath")-\>Value;
        creator=rez-\>FieldByName("Creator")-\>Value;
        updater=rez-\>FieldByName("Updater")-\>Value;
        accept=rez-\>FieldByName("Accept")-\>Value;
        if (!rez-\>FieldByName("DateOfCreate")-\>Value.IsNull()){dateofcreate=rez-\>FieldByName("DateOfCreate")-\>Value.operator TDateTime();}else{dateofcreate=0;}
        if (!rez-\>FieldByName("DateOfUpdate")-\>Value.IsNull()){dateofupdate=rez-\>FieldByName("DateOfUpdate")-\>Value.operator TDateTime();}else{dateofupdate=0;}
        \file-\>SetData    (id,sprazd,obd,name,sprazdname,icoid,
                        filename,filepath,creator,updater,accept,
                        dateofcreate,dateofupdate);
        node=Node-\>Owner-\>AddChildObject(Node,file-\>Get_Text(),(void*)file);
        node-\>ImageIndex=IcoData-\>GetInList(file-\>Get_icoID(),true,2);
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        rez-\>Next();
        }
    }
delete rez;
}
</code>
Type Parameters
Node :  Указатель на узел для которого загружается информация
        о файлах

@@TSpTree::TreeExpanding@TObject *@TTreeNode *@bool &
Description
Обработчик событиря развертывания узла
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::TreeExpanding(TObject *Sender, TTreeNode *Node, bool &amp;AllowExpansion)
{
Obd *bag=(Obd *)Node-\>Data;
if (Node-\>Level&amp;&amp;bag&amp;&amp;bag-\>TrueClassName()=="TreeRow"&amp;&amp;!((TreeRow*)bag)-\>Get_Force())
    {
    BranchClear(Node);
    LoadTree(Node);
    }
}
</code>
Type Parameters
Sender :          Указатель на объект вызвавший функцию
Node :            Указатель на рыскрываемый узел
AllowExpansion :  Индикатор разрешения на развертывание

@@TSpTree::N14Click@TObject *
Description
Обработчик нажатия меню "Показать состав"
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N14Click(TObject *Sender)
{
UpdateBranch(Tree-\>Selected,true);
Tree-\>Selected-\>Expand(false);
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSpTree::UpdateBranch@TTreeNode *@bool
Description
Функция для обновления содержимого ветви дерева
C++ Syntax
<code lang="c++">
void TSpTree::UpdateBranch(TTreeNode *Node,bool force=false)
{
Obd *bag=(Obd *)Node-\>Data;
if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow*)bag;
    Row-\>Set_Force(force);
    Node-\>Owner-\>AddChildObject(Node,"",0);
    //Node-\>Expand(false);
    BranchClear(Node);
    LoadTree(Node);
    }
}
</code>
Note
<c>force=false -значение по умолчанию. Если force будет равен
true то будет учитываться индикатор CanChild при дальнейшей
работе с ветвью</c>
Type Parameters
Node :   Указатель на корневой узел обновляемой ветви
force :  Индикатор игнорирования признака на наличие
         собственного состава

@@TSpTree::BranchClear@TTreeNode *
Description
Функция очистки ветви дерева
C++ Syntax
<code lang="c++">
void TSpTree::BranchClear(TTreeNode *Node)
{
TTreeNode *node=Node-\>getFirstChild();
while (node)  //перебор детей
    {
    if (node-\>Count) //есть дети которых надо порезать
        {
        BranchClear(node);
        }
    if ((int)node-\>Data)
        {
        delete (Obd *)node-\>Data;
        node-\>Data=0;
        }
    node=node-\>getNextSibling();
    }
Node-\>DeleteChildren();
}
</code>
Type Parameters
Node :  Указатель на корневой узел ветви

@@TSpTree::LoadTree@TTreeNode *
Description
Загрузка дерева на основе данных из корневого узла
C++ Syntax
<code lang="c++">
void TSpTree::LoadTree (TTreeNode *Node)
{
Obd* bag=(Obd*)Node-\>Data;
if (!bag) {return;}
if (bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *row=(TreeRow*)bag;
    TTreeNode *node=Node;
    bool force=row-\>Get_Force();
    row-\>UpdateVal();
    node-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
    node-\>SelectedIndex=node-\>ImageIndex;
    node-\>ExpandedImageIndex=node-\>ImageIndex;
    node-\>StateIndex=IcoData-\>GetInList(row-\>Get_state(),row-\>Get_Accept(),0);
    if (row-\>Get_CanChild()||force) //создание раздела документация, прикрепление к нему фaйлов
        {   //добавить в контейнер обд и тут оперировать им
        Obd *r=new Obd(*((Obd*)row));
        r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация"); //создание раздела документация, прикрепление к нему фыйлов
        node=Tree-\>Items-\>AddChildObject(node,r-\>Get_SpRazdName(),(void*)r);
        node-\>ImageIndex=IcoData-\>GetInList(r-\>Get_SpRazd(),true,1);
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        }
    LoadFiles(node);  // если кен чилд то LoadBranch
    if (row-\>Get_CanChild()||force)
        {
        LoadBranch(Node);
        }
    }
}
</code>
Type Parameters
Node :  Указатель на объект корневого узла дерева

@@TSpTree::LoadBranch@TTreeNode *
Description
Функция для загрузки ветви дерева на основе данных из
корневого узла
C++ Syntax
<code lang="c++">
void              TSpTree::LoadBranch(TTreeNode *Node)
{  // продолжение отдельной функцией получения состава
Obd* t=(Obd*)Node-\>Data;
if (!t) {return;}
if (t-\>TrueClassName()=="TreeRow")
    { //загрузка информации о составе детали формирования остальных разделов
    TreeRow *row=(TreeRow*)t;
    int id=row-\>Get_ID();
    String sql="Call constructions.LoadTree('"+String(id)+"','"+String(LUser)+"')";
    TADOQuery *rez=DB-\>SendSQL(sql);
    if (rez&amp;&amp;rez-\>RecordCount)
        {
        rez-\>First();
        String CurRazd="";
        TTreeNode *node,*pnode;
        int id,idparent,sprazd,pp,ppp,ei,state,userid;
        String obd,obu,name,sprazdname,format,pos,prim,zona,ppname,einame,user,condname,detcreator,
        detupdater,rowcreator,rowupdater;
        double kol;
        bool arhive,canchild,accept;
        TDateTime  detcreated,detupdated,rowcreated,rowupdated;
        while (!rez-\>Eof)
            {
            row=new TreeRow(DB,LUser);
            id=rez-\>FieldByName("idchild")-\>Value;
            idparent=rez-\>FieldByName("idparent")-\>Value;
            sprazd=rez-\>FieldByName("razdSPID")-\>Value;
            pp=rez-\>FieldByName("pp")-\>Value.operator UnicodeString().ToInt();
            ppp=rez-\>FieldByName("ppp")-\>Value.operator UnicodeString().ToInt();
            ei=rez-\>FieldByName("ei")-\>Value.operator UnicodeString().ToInt();
            state=rez-\>FieldByName("state")-\>Value;
            userid=rez-\>FieldByName("UserID")-\>Value;
            obd=rez-\>FieldByName("obd")-\>Value;
            obu=rez-\>FieldByName("obu")-\>Value;
            name=rez-\>FieldByName("name")-\>Value;
            sprazdname=rez-\>FieldByName("Razdname")-\>Value;
            format=rez-\>FieldByName("format")-\>Value;
            pos=rez-\>FieldByName("pos")-\>Value;
            prim=rez-\>FieldByName("prim")-\>Value;
            zona=rez-\>FieldByName("zona")-\>Value;
            ppname=rez-\>FieldByName("ppName")-\>Value;
            einame=rez-\>FieldByName("eiName")-\>Value;
            user=rez-\>FieldByName("User")-\>Value;
            condname=rez-\>FieldByName("CondName")-\>Value;
            detcreator=rez-\>FieldByName("DetCreator")-\>Value;
            detupdater=rez-\>FieldByName("DetUpdater")-\>Value;
            rowcreator=rez-\>FieldByName("RowCreator")-\>Value;
            rowupdater=rez-\>FieldByName("RowUpdater")-\>Value;
            kol=rez-\>FieldByName("kol")-\>Value;
            arhive=rez-\>FieldByName("arhive")-\>Value;
            canchild=rez-\>FieldByName("CanChild")-\>Value;
            accept=rez-\>FieldByName("Accept")-\>Value;
            if (!rez-\>FieldByName("DetCreated")-\>Value.IsNull()){detcreated=rez-\>FieldByName("DetCreated")-\>Value.operator TDateTime();}else{detcreated=0;}
            if (!rez-\>FieldByName("DetUpdated")-\>Value.IsNull()){detupdated=rez-\>FieldByName("DetUpdated")-\>Value.operator TDateTime();}else{detupdated=0;}
            if (!rez-\>FieldByName("RowCreated")-\>Value.IsNull()){rowcreated=rez-\>FieldByName("RowCreated")-\>Value.operator TDateTime();}else{rowcreated=0;}
            if (!rez-\>FieldByName("RowUpdated")-\>Value.IsNull()){rowupdated=rez-\>FieldByName("RowUpdated")-\>Value.operator TDateTime();}else{rowupdated=0;}
            row-\>SetData(id,idparent,sprazd,pp,ppp,ei,state,userid,obd,obu,name,
                        sprazdname,format,pos,prim,zona,ppname,einame,user,
                        condname,detcreator,detupdater,rowcreator,rowupdater,
                        kol,arhive,canchild,accept,detcreated,detupdated,rowcreated,
                        rowupdated);
            if (CurRazd!=row-\>Get_SpRazdName())
                {
                pnode=Node-\>Owner-\>AddChildObject(Node,row-\>Get_SpRazdName(),0);
                pnode-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
                pnode-\>SelectedIndex=pnode-\>ImageIndex;
                pnode-\>ExpandedImageIndex=pnode-\>ImageIndex;
                pnode-\>StateIndex=-1;
                CurRazd=row-\>Get_SpRazdName();
                }
            node=Node-\>Owner-\>AddChildObject(pnode,row-\>Get_Text(),(void*)row);
            node-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=IcoData-\>GetInList(row-\>Get_state(),row-\>Get_Accept(),0);
            if (row-\>Get_CanChild()) //создание раздела документация, прикрепление к нему фaйлов
                {   //добавить в контейнер обд и тут оперировать им
                Obd *r=new Obd(*((Obd*)row));
                r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация"); //создание раздела документация, прикрепление к нему фыйлов
                node=Tree-\>Items-\>AddChildObject(node,r-\>Get_SpRazdName(),(void*)r);
                node-\>ImageIndex=IcoData-\>GetInList(r-\>Get_SpRazd(),true,1);
                node-\>SelectedIndex=node-\>ImageIndex;
                node-\>ExpandedImageIndex=node-\>ImageIndex;
                node-\>StateIndex=-1;
                }
            LoadFiles(node);
            rez-\>Next();
            }
        }
    delete rez;
    }
}
</code>
Type Parameters
Node :  Указатель на объект корневого узла

@@TSpTree::N21Click@TObject *
Description
Обработчик нажатия пункта меню "Раскрыть"
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N21Click(TObject *Sender)
{
TTreeNode *node=Tree-\>Selected;
if (node)
    {
    node-\>Expand(true);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, Вызвавший функцию

@@TSpTree::N22Click@TObject *
Description
Обработчик нажатия пункта меню "свернуть"
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N22Click(TObject *Sender)
{
TTreeNode *node=Tree-\>Selected;
if (node)
    {
    node-\>Collapse(true);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::N9Click@TObject *
Description
Включение режима массовых действий (над узлом и входящими в
него узлами/деталями)
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N9Click(TObject *Sender)
{
MassAction=true;
N10-\>Checked=!MassAction;
N9-\>Checked=MassAction;
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::N10Click@TObject *
Description
Включение режима массовых действий (над узлом и входящими в
него узлами/деталями)
C++ Syntax
<code>
void __fastcall TSpTree::N10Click(TObject *Sender)
{
MassAction=false;
N10-\>Checked=!MassAction;
N9-\>Checked=MassAction;
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::N26Click@TObject *
Description
Обработчик нажатия пукнта меню"состояние". Запускает механизм
смены состояний
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N26Click(TObject *Sender)
{
vector \<TTreeNode *\>nodes;
for (unsigned int i=0; i \< Tree-\>SelectionCount; i++)
    {
    nodes.push_back(Tree-\>Selections[i]);
    }
//смена состояния
TCond *wnd;
wnd=new TCond(this-\>Owner,*Tree,MassAction,DB,IcoData,LUser);
wnd-\>ShowModal();
delete wnd;
Obd *bag=0;
TreeRow *Row=0;
//обновить инфорацию о каждой детали в узле
for (vector\<TTreeNode *\>::iterator i=nodes.begin(); i!=nodes.end(); i++)
    {
    UpdateInfo(*i);
    bag=(Obd *)(*i)-\>Data;
    if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
        {
        Row=(TreeRow *)bag;
        (*i)-\>StateIndex=IcoData-\>GetInList(Row-\>Get_state(),Row-\>Get_Accept(),0);
        }
    }
//Tree-\>Repaint();
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::UpdateInfo@TTreeNode *
Description
Функция для обновления данных узла/ветви
C++ Syntax
<code lang="c++">
void              TSpTree::UpdateInfo(TTreeNode *Node)
{     //если массовые действи явыключены то происходит обновление указанного узла и входящих в него деталей
// при вуключенных масс действиях происходит полное перестроение ветви
Obd *bag=(Obd *)Node-\>Data;
if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow *)bag;
    if (!Row-\>UpdateVal())//обновлние информации в ноде
        {
        BranchClear(Node);
        delete Row;                                    //если нод неюзабелен то удаляем и на выход
        Node-\>Delete();
        }else
        {
        if (MassAction)                         //проверка на массовость действий
            {
            bool expand=Node-\>Expanded;         //если массовое действие то выполнить полное перестроение
            UpdateBranch(Node);
            if (expand)
                {
                Node-\>Expand(false);
                }
            }else
            {
            if (Row-\>Get_CanChild()||Row-\>Get_Force())// обновление информации в ноде разделе "документация"
                {
                Node=Node-\>getFirstChild();
                if (Node)
                    {
                    Obd *r=(Obd *)Node-\>Data;
                    if (r&amp;&amp;r-\>TrueClassName()=="Obd")
                        {
                        r-\>UpdateVal();
                        r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация");
                        }
                    }
                }
            if (Node&amp;&amp;Node-\>Count) // обновление информации в файлах
                {
                Node=Node-\>getFirstChild();
                while (Node)
                    {
                    bag=(Obd *)Node-\>Data;
                    if (bag)
                        {
                        if (!bag-\>UpdateVal())    //если нод неюзабелен то он будет удален
                            {
                            delete bag;
                            if (Node-\>getPrevSibling())
                                {
                                Node=Node-\>getPrevSibling();
                                Node-\>getNextSibling()-\>Delete();
                                Node=Node-\>getNextSibling();
                                }else
                                {
                                if (Node-\>getNextSibling())
                                    {
                                    Node=Node-\>getNextSibling();
                                    Node-\>getPrevSibling()-\>Delete();
                                    }else
                                    {
                                    Node-\>Delete();
                                    Node=0;
                                    }
                                }
                            }else
                            {
                            Node=Node-\>getNextSibling();
                            }
                        }else
                        {
                        Node=Node-\>getNextSibling();
                        }
                    }
                }
            }
        }
    }
}
</code>
Type Parameters
Node :  Указатель на узел требующий обновления

@@TSpTree::N41Click@TObject *
Description
Функция обработки нажатия пунктов меню "Заблокировать для
всех" и "Снять блокировку"
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N41Click(TObject *Sender)
{
TTreeView *TV=Tree;
String ids="";
Obd *det=0;
for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
    {
    det=(Obd*)TV-\>Selections[i]-\>Data;
    if (det&amp;&amp;det-\>TrueClassName()=="TreeRow")
        {
        TreeRow *Row=(TreeRow *)det;
        Row-\>UpdateVal();
        if (Row-\>Get_Accept())
            {
            ids=ids+String(Row-\>Get_ID())+",";
            }
        }
    }
if (ids!="")
    {
    ids.Delete(ids.Length(),1);
    if (((TMenuItem*)Sender)-\>Tag)
        {
        UnBlock(ids); //разблокировка
        }else
        {
        Block(ids);  //блокировка
        }
    for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
        {
        UpdateInfo(TV-\>Selections[i]);
        }
    TV-\>Repaint();
    }
}
</code>
Type Parameters
Sender :  Указатель на обект, вызвавший функцию

@@TSpTree::Load@Obd *const
Description
Интерфейсная функция - команда на загрузку узла/детали
C++ Syntax
<code lang="c++">
void  Load (const Obd *const det){LoadTree(det-\>Get_ID());};
</code>
Type Parameters
det :  Указатель на загружаемую деталь

@@TSpTree::LoadDet@Obd *
Description
Функция для отправки команды на загрузку в класс управляющий
загрузкой и историей загрузок.
C++ Syntax
<code lang="c++">
void LoadDet (Obd *det){Selector-\>LoadDet(det);};
</code>
Type Parameters
det :  Указатель на загружаемый объект

@@TSpTree::TechAction@TObject *
Description
Функция для отправки команд программе на действия с
технологией
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::TechAction(TObject *Sender)
{
TTreeNode *node=Tree-\>Selected;
if (node)
    {
    //объект
    TMenuItem *m=(TMenuItem *)Sender;
    Obd *bag=(Obd*)node-\>Data;
    Obd *det=new Obd(*bag);
    switch (m-\>Tag)
        {
        case 1:{AddTexTab(det);break;}     //редактировать новая вкладка
        case 0:{LoadTexToCurrTab(det);break;}           //редактировать текущая вкладка
        case 3:{AddTexViewTab(det);break;}//просмотр новая вкладка
        case 2:{LoadexViewToCurrTab(det);break;}        //просмотр текущая вкладка
        default:break;
        }
    bag-\>UpdateVal();
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::TechDel@TObject *
Description
Фукнция отправки команды на удаление технологии из базы
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::TechDel(TObject *Sender)
{
if (!MessageDlg("Удаление безвозвратно уничтожит всю информацию. Продолжить?",mtWarning,TMsgDlgButtons()\<\<mbYes\<\<mbNo,0)==mrYes){return;}
TTreeView *TV=Tree;
String ids="";
Obd *det=0;
for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
    {
    det=(Obd*)TV-\>Selections[i]-\>Data;
    if (det&amp;&amp;det-\>TrueClassName()=="TreeRow")
        {
        TreeRow *Row=(TreeRow *)det;
        Row-\>UpdateVal();
        if (Row-\>Get_Accept())
            {
            ids=ids+String(Row-\>Get_ID())+",";
            }
        }
    }
if (ids!="")
    {
    ids.Delete(ids.Length(),1);
    DB-\>SendCommand("Call technologic.TechDel('"+ids+"')");
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::N11Click@TObject *
Description
Обработчик пункта меню "Добавить файл"
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N11Click(TObject *Sender)
{
TFileDisigner *wnd=new TFileDisigner(this-\>Owner,DB,LUser,0,false,0);
wnd-\>ShowModal();
delete wnd;
// добавить
if (Tree-\>Items-\>Count)
    {
    N23Click(N23);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSpTree::N4Click@TObject *
Description
Обработчик пункта меню "Получить файлы" функции
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N4Click(TObject *Sender)
{
if (Tree-\>Selected&amp;&amp;Tree-\>Selected-\>Data)
    {
    TFileDisigner *wnd=new TFileDisigner(this-\>Owner,DB,LUser,(Obd *)Tree-\>Selected-\>Data,MassAction,1);
    wnd-\>ShowModal();
    delete wnd;
    }
// получить файлы
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSpTree::N5Click@TObject *
Description
Обработчик пункта меню "Удалить файлы"
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::N5Click(TObject *Sender)
{
if (Tree-\>Selected&amp;&amp;Tree-\>Selected-\>Data)
    {
    TFileDisigner *wnd=new TFileDisigner(this-\>Owner,DB,LUser,(Obd *)Tree-\>Selected-\>Data,MassAction,2);
    wnd-\>ShowModal();
    delete wnd;
    }
if (Tree-\>Items-\>Count)
    {
    N23Click(N23);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSpTree::Init
Description
Инициалицазия /реинициализация подсистем компонента в
зависимости от уровня доступа пользователя (случай с горячей
сменой пользователя)
C++ Syntax
<code lang="c++">
void              TSpTree::Init      (void)
{
bool FileInsert,FileDel,FileEdit,FileView,SpInsert,SpDel,SpEdit,SpView,
TehAdd,TehRead,TehEdit,TehDel,FileGet;
String sql;
sql="SELECT FileInsert,FileDel,FileEdit,FileView,FileGet,SpInsert,SpDel,SpEdit,SpView,TehAdd,TehRead,TehEdit,TehDel
FROM administration.privileges a
inner join administration.logins b on b.LogID='"+String(LUser)+"' and b.Levelacss=a.GroupID";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    FileInsert=rez-\>FieldByName("FileInsert")-\>Value.intVal;
    FileDel=rez-\>FieldByName("FileDel")-\>Value.intVal;
    FileEdit=rez-\>FieldByName("FileEdit")-\>Value.intVal;
    FileView=rez-\>FieldByName("FileView")-\>Value.intVal;
    FileGet=rez-\>FieldByName("FileGet")-\>Value.intVal;
    SpInsert=rez-\>FieldByName("SpInsert")-\>Value.intVal;
    SpDel=rez-\>FieldByName("SpDel")-\>Value.intVal;
    SpEdit=rez-\>FieldByName("SpEdit")-\>Value.intVal;
    SpView=rez-\>FieldByName("SpView")-\>Value.intVal;
    TehAdd=rez-\>FieldByName("TehAdd")-\>Value.intVal;
    TehRead=rez-\>FieldByName("TehRead")-\>Value.intVal;
    TehEdit=rez-\>FieldByName("TehEdit")-\>Value.intVal;
    TehDel=rez-\>FieldByName("TehDel")-\>Value.intVal;
    }
    else
    {
    FileInsert=false;
    FileDel=false;
    FileEdit=false;
    FileView=false;
    FileGet=false;
    SpInsert=false;
    SpDel=false;
    SpEdit=false;
    SpView=false;
    TehAdd=false;
    TehRead=false;
    TehEdit=false;
    TehDel=false;
    }
delete rez;
//файл
N11-\>Enabled=FileInsert+FileEdit;
N4-\>Enabled=FileGet;
N5-\>Enabled=FileDel;
N11-\>Visible=FileInsert+FileEdit;
N4-\>Visible=FileGet;
N5-\>Visible=FileDel;
N3-\>Visible=FileInsert+FileGet+FileDel;
// технология
if (AddTexTab)
    {
    N24-\>Enabled=TehAdd+TehEdit;
    N24-\>Visible=TehAdd+TehEdit;
    }else
    {
    N24-\>Enabled=false;
    N24-\>Visible=false;
    }
if (AddTexViewTab)
    {
    N1-\>Visible=TehRead;
    N1-\>Enabled=TehRead;
    }else
    {
    N1-\>Visible=false;
    N1-\>Enabled=false;
    }
if (LoadTexToCurrTab)
    {
    N31-\>Visible=TehAdd+TehEdit;
    N31-\>Enabled=TehAdd+TehEdit;
    }else
    {
    N31-\>Enabled=false;
    N31-\>Visible=false;
    }
if (LoadexViewToCurrTab)
    {
    N25-\>Enabled=TehRead;
    N25-\>Visible=TehRead;
    }else
    {
    N25-\>Enabled=false;
    N25-\>Visible=false;
    }
N12-\>Enabled=TehDel;
N12-\>Visible=TehDel;
N17-\>Visible=TehAdd+TehEdit+TehRead+TehDel;
// спецификация
N15-\>Enabled=SpInsert;
N16-\>Enabled=SpEdit;
N18-\>Enabled=SpView;
N19-\>Enabled=SpDel;
N15-\>Visible=SpInsert;
N16-\>Visible=SpEdit;
N18-\>Visible=SpView;
N19-\>Visible=SpDel;
N13-\>Visible=SpInsert+SpEdit+SpView+SpDel;
}
</code>


@@TSpTree
Description
Компонент для визуального отображения сотава изделия и
манипуляций над прикрепленными файлами и циклом разработки
изделия

@@BomTree.h
Description
Компонент для визуального отображения сотава изделия и
манипуляций над прикрепленными файлами и циклом разработки
изделия (заголовки)
C++ Syntax
<code lang="c++">

\#ifndef BomTreeH
\#define BomTreeH

\#include \<ActnPopup.hpp\>
\#include \<Buttons.hpp\>
\#include \<Classes.hpp\>
\#include \<ComCtrls.hpp\>
\#include \<Controls.hpp\>
\#include \<ExtCtrls.hpp\>
\#include \<ImgList.hpp\>
\#include \<Menus.hpp\>
\#include \<PlatformDefaultStyleActnCtrls.hpp\>
\#include \<StdCtrls.hpp\>

\#include "DetSelector.h"
\#include "Conditions.h"
\#include "files.h"
typedef void (*Tech)(Obd *Det);
class TSpTree : public TFrame,public ClassConnector
{
__published:
    TPanel *Panel3;
    TTreeView *Tree;
    TPopupActionBar *PAB;
    TMenuItem *N17;
    TMenuItem *N31;
    TMenuItem *N20;
    TMenuItem *N21;
    TMenuItem *N22;
    TMenuItem *N40;
    TMenuItem *N41;
    TMenuItem *N42;
    TMenuItem *N26;
    TMenuItem *N14;
    TMenuItem *N23;
    TMenuItem *N1;
    TMenuItem *N3;
    TMenuItem *N4;
    TMenuItem *N5;
    TMenuItem *N6;
    TMenuItem *N7;
    TMenuItem *N8;
    TMenuItem *N9;
    TMenuItem *N10;
    TMenuItem *N11;
    TMenuItem *N12;
    TMenuItem *N13;
    TMenuItem *N15;
    TMenuItem *N16;
    TMenuItem *N18;
    TMenuItem *N19;
    TMenuItem *N24;
    TMenuItem *N25;
    TImageList *ImageList1;
    void __fastcall TreeExpanding(TObject *Sender, TTreeNode *Node, bool &amp;AllowExpansion);
    void __fastcall TreeMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y);

    void __fastcall N14Click(TObject *Sender);
    void __fastcall N21Click(TObject *Sender);
    void __fastcall N22Click(TObject *Sender);
    void __fastcall N23Click(TObject *Sender);

    void __fastcall SpMaster(TObject *Sender);
    void __fastcall SpDel(TObject *Sender);

    void __fastcall N4Click(TObject *Sender);
    void __fastcall N5Click(TObject *Sender);
    void __fastcall N11Click(TObject *Sender);

    void __fastcall TechAction(TObject *Sender);
    void __fastcall TechDel(TObject *Sender);
    void __fastcall N41Click(TObject *Sender);
    void __fastcall N42Click(TObject *Sender);

    void __fastcall N26Click(TObject *Sender);

    void __fastcall N10Click(TObject *Sender);
    void __fastcall N9Click(TObject *Sender);

    void __fastcall TreeAdvancedCustomDrawItem(TCustomTreeView *Sender, TTreeNode *Node,
          TCustomDrawState State, TCustomDrawStage Stage, bool &amp;PaintImages,
          bool &amp;DefaultDraw);
private:
    void  Init        (void);

       void  TreeClear(void);
    void  BranchClear(TTreeNode *Node);
    void  Selection(TTreeView *TView,TShiftState Shift,int X, int Y);

    void  Load (const Obd *const det){LoadTree(det-\>Get_ID());};
    void  LoadTree (int _id);
    void  LoadTree (TTreeNode *Node);
    void  LoadBranch(TTreeNode *Node);
    void  LoadFiles(TTreeNode *Node);
       void  UpdateBranch(TTreeNode *Node,bool force);

    void  GetInfo(TTreeNode *Node);
       void  UpdateInfo(TTreeNode *Node);

    void  Block(Obd *det);
    void  UnBlock(Obd *det);
    // функции указатели
    Tech AddTexTab;
    Tech AddTexViewTab;
    Tech LoadTexToCurrTab;
    Tech LoadexViewToCurrTab;
    //переменные
    bool  MassAction;
    TMemo *memo;
    TObdSelector *Selector;
    const int &amp;LUser;
    // статики
    static IconsData *IcoData;
    static int count;

    static cSQL *DB;
public:
    __fastcall TSpTree(TComponent* Owner,TWinControl *_p,cSQL *db,const int &amp;_LUser,TMemo *m,IconsData *_IcoData,void* _AddTexTab,
    void* _LoadTexToCurrTab,void* _AddTexViewTab,void* _LoadexViewToCurrTab);
    __fastcall TSpTree::~TSpTree(void);
    void LoadDet (Obd *det){Selector-\>LoadDet(det);};
};
/* Переменная, показывающая количество экземпляров класса. */
int TSpTree::count=0;
IconsData *TSpTree::IcoData=0;
/* указатель на класс для работы с базой данных */
cSQL *TSpTree::DB=0;
\#endif
</code>

@@BomTree.cpp
Description
Компонент для визуального отображения сотава изделия и
манипуляций над прикрепленными файлами и циклом разработки
изделия (описания)
C++ Syntax
<code lang="c++">

\#include \<vcl.h\>
\#pragma hdrstop

\#include "BomTree.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)
\#pragma resource "*.dfm"

__fastcall         TSpTree::TSpTree(TComponent* Owner,TWinControl *_p,cSQL *db,const int &amp;_LUser,TMemo *m,IconsData *_IcoData,void* _AddTexTab,
    void* _LoadTexToCurrTab,void* _AddTexViewTab,void* _LoadexViewToCurrTab)
    \: TFrame(Owner),LUser(_LUser)
{
// получить список доступных компонентов и сделать не активными не доступные
if (count==0)
    {
    DB=db;
    IcoData=_IcoData;
    }
Selector=new TObdSelector(this,(ClassConnector*)this,Panel3,db);
//функции указатели
AddTexTab=Tech(_AddTexTab);
AddTexViewTab=Tech(_AddTexViewTab);
LoadTexToCurrTab=Tech(_LoadTexToCurrTab);
LoadexViewToCurrTab=Tech(_LoadexViewToCurrTab);
// расположение
Align=alClient;
Parent=_p;
Name=Name+String(count);
memo=m;
Init();
Tree-\>Images=IcoData-\>GetImgList();
Tree-\>StateImages=IcoData-\>GetStateList();
count++;
MassAction=false;
N10-\>Checked=!MassAction;
N9-\>Checked=MassAction;
if (Parent-\>ClassNameIs("TTabSheet"))
    {
    ((TTabSheet*)Parent)-\>Caption="Спецификация     ";
    }
}
__fastcall         TSpTree::~TSpTree(void)
{
count--;
if (count==0)
    {
    DB=0;
    IcoData=0;
    }
TreeClear();
}
void              TSpTree::Init      (void)
{
bool FileInsert,FileDel,FileEdit,FileView,SpInsert,SpDel,SpEdit,SpView,TehAdd,TehRead,TehEdit,TehDel,FileGet;
String sql;
sql="SELECT FileInsert,FileDel,FileEdit,FileView,FileGet,SpInsert,SpDel,SpEdit,SpView,TehAdd,TehRead,TehEdit,TehDel FROM privileges a inner join logins b on b.LogID='"+String(LUser)+"' and b.Levelacss=a.GroupID";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    FileInsert=rez-\>FieldByName("FileInsert")-\>Value.intVal;
    FileDel=rez-\>FieldByName("FileDel")-\>Value.intVal;
    FileEdit=rez-\>FieldByName("FileEdit")-\>Value.intVal;
    FileView=rez-\>FieldByName("FileView")-\>Value.intVal;
    FileGet=rez-\>FieldByName("FileGet")-\>Value.intVal;
    SpInsert=rez-\>FieldByName("SpInsert")-\>Value.intVal;
    SpDel=rez-\>FieldByName("SpDel")-\>Value.intVal;
    SpEdit=rez-\>FieldByName("SpEdit")-\>Value.intVal;
    SpView=rez-\>FieldByName("SpView")-\>Value.intVal;
    TehAdd=rez-\>FieldByName("TehAdd")-\>Value.intVal;
    TehRead=rez-\>FieldByName("TehRead")-\>Value.intVal;
    TehEdit=rez-\>FieldByName("TehEdit")-\>Value.intVal;
    TehDel=rez-\>FieldByName("TehDel")-\>Value.intVal;
    }
    else
    {
    FileInsert=false;
    FileDel=false;
    FileEdit=false;
    FileView=false;
    FileGet=false;
    SpInsert=false;
    SpDel=false;
    SpEdit=false;
    SpView=false;
    TehAdd=false;
    TehRead=false;
    TehEdit=false;
    TehDel=false;
    }
delete rez;
//файл
N11-\>Enabled=FileInsert+FileEdit;
N4-\>Enabled=FileGet;
N5-\>Enabled=FileDel;
N11-\>Visible=FileInsert+FileEdit;
N4-\>Visible=FileGet;
N5-\>Visible=FileDel;
N3-\>Visible=FileInsert+FileGet+FileDel;
// технология
if (AddTexTab)
    {
    N24-\>Enabled=TehAdd+TehEdit;
    N24-\>Visible=TehAdd+TehEdit;
    }else
    {
    N24-\>Enabled=false;
    N24-\>Visible=false;
    }
if (AddTexViewTab)
    {
    N1-\>Visible=TehRead;
    N1-\>Enabled=TehRead;
    }else
    {
    N1-\>Visible=false;
    N1-\>Enabled=false;
    }
if (LoadTexToCurrTab)
    {
    N31-\>Visible=TehAdd+TehEdit;
    N31-\>Enabled=TehAdd+TehEdit;
    }else
    {
    N31-\>Enabled=false;
    N31-\>Visible=false;
    }
if (LoadexViewToCurrTab)
    {
    N25-\>Enabled=TehRead;
    N25-\>Visible=TehRead;
    }else
    {
    N25-\>Enabled=false;
    N25-\>Visible=false;
    }
N12-\>Enabled=TehDel;
N12-\>Visible=TehDel;
N17-\>Visible=TehAdd+TehEdit+TehRead+TehDel;
// спецификация
N15-\>Enabled=SpInsert;
N16-\>Enabled=SpEdit;
N18-\>Enabled=SpView;
N19-\>Enabled=SpDel;
N15-\>Visible=SpInsert;
N16-\>Visible=SpEdit;
N18-\>Visible=SpView;
N19-\>Visible=SpDel;
N13-\>Visible=SpInsert+SpEdit+SpView+SpDel;
}

void              TSpTree::TreeClear(void)
{
TTreeNode *node=Tree-\>Items-\>GetFirstNode();
while (node!=0)
    {
    if ((int)node-\>Data)
        {
        delete (Obd *)node-\>Data;
        }
    node=node-\>GetNext();
    }
Tree-\>Items-\>Clear();
}
void              TSpTree::BranchClear(TTreeNode *Node)
{
TTreeNode *node=Node-\>getFirstChild();
while (node)  //перебор детей
    {
    if (node-\>Count) //есть дети которых надо порезать
        {
        BranchClear(node);
        }
    if ((int)node-\>Data)
        {
        delete (Obd *)node-\>Data;
        node-\>Data=0;
        }
    node=node-\>getNextSibling();
    }
Node-\>DeleteChildren();
}
void              TSpTree::LoadTree (int _id)
{
TreeClear();
TTreeNode *node;
TreeRow *row;
TADOQuery *rez;
String sql;
sql="Call LoadDet('"+String(_id)+"','"+String(LUser)+"')";  //загрузка информации о детали формировавние раздела документация
rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    int id,idparent,sprazd,pp,ppp,ei,state,userid;
    String obd,obu,name,sprazdname,format,pos,prim,zona,ppname,einame,user,condname,detcreator,
    detupdater,rowcreator,rowupdater;
    double kol;
    bool arhive,canchild,accept;
    TDateTime  detcreated,detupdated,rowcreated,rowupdated;

    rez-\>First();
    row=new TreeRow(DB,LUser);

    id=rez-\>FieldByName("idchild")-\>Value;
    idparent=rez-\>FieldByName("idparent")-\>Value;
    sprazd=rez-\>FieldByName("razdSPID")-\>Value;
    pp=rez-\>FieldByName("pp")-\>Value.operator UnicodeString().ToInt();
    ppp=rez-\>FieldByName("ppp")-\>Value.operator UnicodeString().ToInt();
    ei=rez-\>FieldByName("ei")-\>Value.operator UnicodeString().ToInt();
    state=rez-\>FieldByName("state")-\>Value;
    userid=rez-\>FieldByName("UserID")-\>Value;
    obd=rez-\>FieldByName("obd")-\>Value;
    obu=rez-\>FieldByName("obu")-\>Value;
    name=rez-\>FieldByName("name")-\>Value;
    sprazdname=rez-\>FieldByName("Razdname")-\>Value;
    format=rez-\>FieldByName("format")-\>Value;
    pos=rez-\>FieldByName("pos")-\>Value;
    prim=rez-\>FieldByName("prim")-\>Value;
    zona=rez-\>FieldByName("zona")-\>Value;
    ppname=rez-\>FieldByName("ppName")-\>Value;
    einame=rez-\>FieldByName("eiName")-\>Value;
    user=rez-\>FieldByName("User")-\>Value;
    condname=rez-\>FieldByName("CondName")-\>Value;
    detcreator=rez-\>FieldByName("DetCreator")-\>Value;
    detupdater=rez-\>FieldByName("DetUpdater")-\>Value;
    rowcreator=rez-\>FieldByName("RowCreator")-\>Value;
    rowupdater=rez-\>FieldByName("RowUpdater")-\>Value;
    kol=rez-\>FieldByName("kol")-\>Value;
    arhive=rez-\>FieldByName("arhive")-\>Value;
    canchild=rez-\>FieldByName("CanChild")-\>Value;
    accept=rez-\>FieldByName("Accept")-\>Value;
    if (!rez-\>FieldByName("DetCreated")-\>Value.IsNull()){detcreated=rez-\>FieldByName("DetCreated")-\>Value.operator TDateTime();}else{detcreated=0;}
    if (!rez-\>FieldByName("DetUpdated")-\>Value.IsNull()){detupdated=rez-\>FieldByName("DetUpdated")-\>Value.operator TDateTime();}else{detupdated=0;}
    if (!rez-\>FieldByName("RowCreated")-\>Value.IsNull()){rowcreated=rez-\>FieldByName("RowCreated")-\>Value.operator TDateTime();}else{rowcreated=0;}
    if (!rez-\>FieldByName("RowUpdated")-\>Value.IsNull()){rowupdated=rez-\>FieldByName("RowUpdated")-\>Value.operator TDateTime();}else{rowupdated=0;}
    row-\>SetData(id,idparent,sprazd,pp,ppp,ei,state,userid,obd,obu,name,
                sprazdname,format,pos,prim,zona,ppname,einame,user,
                condname,detcreator,detupdater,rowcreator,rowupdater,
                kol,arhive,canchild,accept,detcreated,detupdated,rowcreated,
                rowupdated);
    //создание узла
    node=Tree-\>Items-\>AddObject(0,row-\>Get_Text(),(void*)row);
    node-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
    node-\>SelectedIndex=node-\>ImageIndex;
    node-\>ExpandedImageIndex=node-\>ImageIndex;
    node-\>StateIndex=IcoData-\>GetInList(row-\>Get_state(),row-\>Get_Accept(),0);
    if (row-\>Get_CanChild())
        {
        Obd *r=new Obd(*((Obd*)row));
        r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация"); //создание раздела документация, прикрепление к нему фыйлов
        node=Tree-\>Items-\>AddChildObject(node,r-\>Get_SpRazdName(),(void*)r);
        node-\>ImageIndex=IcoData-\>GetInList(r-\>Get_SpRazd(),true,1);
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        }
    LoadFiles(node);
    if (row-\>Get_CanChild())
        {
        LoadBranch(Tree-\>Items-\>GetFirstNode());// если кен чилд то LoadBranch
        }
    }
Tree-\>Items-\>GetFirstNode()-\>Expand(false);
delete rez;
}
void              TSpTree::LoadTree (TTreeNode *Node)
{
Obd* bag=(Obd*)Node-\>Data;
if (!bag) {return;}
if (bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *row=(TreeRow*)bag;
    TTreeNode *node=Node;
    bool force=row-\>Get_Force();
    row-\>UpdateVal();
    node-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
    node-\>SelectedIndex=node-\>ImageIndex;
    node-\>ExpandedImageIndex=node-\>ImageIndex;
    node-\>StateIndex=IcoData-\>GetInList(row-\>Get_state(),row-\>Get_Accept(),0);
    if (row-\>Get_CanChild()||force) //создание раздела документация, прикрепление к нему фaйлов
        {   //добавить в контейнер обд и тут оперировать им
        Obd *r=new Obd(*((Obd*)row));
        r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация"); //создание раздела документация, прикрепление к нему фыйлов
        node=Tree-\>Items-\>AddChildObject(node,r-\>Get_SpRazdName(),(void*)r);
        node-\>ImageIndex=IcoData-\>GetInList(r-\>Get_SpRazd(),true,1);
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        }
    LoadFiles(node);  // если кен чилд то LoadBranch
    if (row-\>Get_CanChild()||force)
        {
        LoadBranch(Node);
        }
    }
}
void              TSpTree::LoadBranch(TTreeNode *Node)
{  // продолжение отдельной функцией получения состава
Obd* t=(Obd*)Node-\>Data;
if (!t) {return;}
if (t-\>TrueClassName()=="TreeRow")
    { //загрузка информации о составе детали формирования остальных разделов
    TreeRow *row=(TreeRow*)t;
    int id=row-\>Get_ID();
    String sql="Call LoadTree('"+String(id)+"','"+String(LUser)+"')";
    TADOQuery *rez=DB-\>SendSQL(sql);
    if (rez&amp;&amp;rez-\>RecordCount)
        {
        rez-\>First();
        String CurRazd="";
        TTreeNode *node,*pnode;
        int id,idparent,sprazd,pp,ppp,ei,state,userid;
        String obd,obu,name,sprazdname,format,pos,prim,zona,ppname,einame,user,condname,detcreator,
        detupdater,rowcreator,rowupdater;
        double kol;
        bool arhive,canchild,accept;
        TDateTime  detcreated,detupdated,rowcreated,rowupdated;
        while (!rez-\>Eof)
            {
            row=new TreeRow(DB,LUser);
            id=rez-\>FieldByName("idchild")-\>Value;
            idparent=rez-\>FieldByName("idparent")-\>Value;
            sprazd=rez-\>FieldByName("razdSPID")-\>Value;
            pp=rez-\>FieldByName("pp")-\>Value.operator UnicodeString().ToInt();
            ppp=rez-\>FieldByName("ppp")-\>Value.operator UnicodeString().ToInt();
            ei=rez-\>FieldByName("ei")-\>Value.operator UnicodeString().ToInt();
            state=rez-\>FieldByName("state")-\>Value;
            userid=rez-\>FieldByName("UserID")-\>Value;
            obd=rez-\>FieldByName("obd")-\>Value;
            obu=rez-\>FieldByName("obu")-\>Value;
            name=rez-\>FieldByName("name")-\>Value;
            sprazdname=rez-\>FieldByName("Razdname")-\>Value;
            format=rez-\>FieldByName("format")-\>Value;
            pos=rez-\>FieldByName("pos")-\>Value;
            prim=rez-\>FieldByName("prim")-\>Value;
            zona=rez-\>FieldByName("zona")-\>Value;
            ppname=rez-\>FieldByName("ppName")-\>Value;
            einame=rez-\>FieldByName("eiName")-\>Value;
            user=rez-\>FieldByName("User")-\>Value;
            condname=rez-\>FieldByName("CondName")-\>Value;
            detcreator=rez-\>FieldByName("DetCreator")-\>Value;
            detupdater=rez-\>FieldByName("DetUpdater")-\>Value;
            rowcreator=rez-\>FieldByName("RowCreator")-\>Value;
            rowupdater=rez-\>FieldByName("RowUpdater")-\>Value;
            kol=rez-\>FieldByName("kol")-\>Value;
            arhive=rez-\>FieldByName("arhive")-\>Value;
            canchild=rez-\>FieldByName("CanChild")-\>Value;
            accept=rez-\>FieldByName("Accept")-\>Value;
            if (!rez-\>FieldByName("DetCreated")-\>Value.IsNull()){detcreated=rez-\>FieldByName("DetCreated")-\>Value.operator TDateTime();}else{detcreated=0;}
            if (!rez-\>FieldByName("DetUpdated")-\>Value.IsNull()){detupdated=rez-\>FieldByName("DetUpdated")-\>Value.operator TDateTime();}else{detupdated=0;}
            if (!rez-\>FieldByName("RowCreated")-\>Value.IsNull()){rowcreated=rez-\>FieldByName("RowCreated")-\>Value.operator TDateTime();}else{rowcreated=0;}
            if (!rez-\>FieldByName("RowUpdated")-\>Value.IsNull()){rowupdated=rez-\>FieldByName("RowUpdated")-\>Value.operator TDateTime();}else{rowupdated=0;}
            row-\>SetData(id,idparent,sprazd,pp,ppp,ei,state,userid,obd,obu,name,
                        sprazdname,format,pos,prim,zona,ppname,einame,user,
                        condname,detcreator,detupdater,rowcreator,rowupdater,
                        kol,arhive,canchild,accept,detcreated,detupdated,rowcreated,
                        rowupdated);
            if (CurRazd!=row-\>Get_SpRazdName())
                {
                pnode=Node-\>Owner-\>AddChildObject(Node,row-\>Get_SpRazdName(),0);
                pnode-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
                pnode-\>SelectedIndex=pnode-\>ImageIndex;
                pnode-\>ExpandedImageIndex=pnode-\>ImageIndex;
                pnode-\>StateIndex=-1;
                CurRazd=row-\>Get_SpRazdName();
                }
            node=Node-\>Owner-\>AddChildObject(pnode,row-\>Get_Text(),(void*)row);
            node-\>ImageIndex=IcoData-\>GetInList(row-\>Get_SpRazd(),true,1);
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=IcoData-\>GetInList(row-\>Get_state(),row-\>Get_Accept(),0);
            if (row-\>Get_CanChild()) //создание раздела документация, прикрепление к нему фaйлов
                {   //добавить в контейнер обд и тут оперировать им
                Obd *r=new Obd(*((Obd*)row));
                r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация"); //создание раздела документация, прикрепление к нему фыйлов
                node=Tree-\>Items-\>AddChildObject(node,r-\>Get_SpRazdName(),(void*)r);
                node-\>ImageIndex=IcoData-\>GetInList(r-\>Get_SpRazd(),true,1);
                node-\>SelectedIndex=node-\>ImageIndex;
                node-\>ExpandedImageIndex=node-\>ImageIndex;
                node-\>StateIndex=-1;
                }
            LoadFiles(node);
            rez-\>Next();
            }
        }
    delete rez;
    }
}
void              TSpTree::UpdateBranch(TTreeNode *Node,bool force=false)
{
Obd *bag=(Obd *)Node-\>Data;
if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow*)bag;
    Row-\>Set_Force(force);
    Node-\>Owner-\>AddChildObject(Node,"",0);
    //Node-\>Expand(false);
    BranchClear(Node);
    LoadTree(Node);
    }
}
void              TSpTree::LoadFiles(TTreeNode *Node)
{
FileRow *file;
TTreeNode *node;
int _id=((Obd*)Node-\>Data)-\>Get_ID();
String sql="Call LoadFiles('"+String(_id)+"','"+String(LUser)+"')";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    int id,sprazd,icoid;
    String obd,name,sprazdname,filename,filepath,creator,updater;
    bool accept;
    TDateTime dateofcreate,dateofupdate;
    while (!rez-\>Eof)
        {
        \file=new FileRow(DB,LUser); //создание ксаса свойств
        //заполнение свойств файла
        id=rez-\>FieldByName("id")-\>Value;
        sprazd=rez-\>FieldByName("razdSPID")-\>Value;
        icoid=rez-\>FieldByName("icoID")-\>Value;
        obd=rez-\>FieldByName("obd")-\>Value;
        name=rez-\>FieldByName("namd")-\>Value;
        sprazdname=rez-\>FieldByName("Razdname")-\>Value;
        filename=rez-\>FieldByName("FileName")-\>Value;
        filepath=rez-\>FieldByName("FilePath")-\>Value;
        creator=rez-\>FieldByName("Creator")-\>Value;
        updater=rez-\>FieldByName("Updater")-\>Value;
        accept=rez-\>FieldByName("Accept")-\>Value;
        if (!rez-\>FieldByName("DateOfCreate")-\>Value.IsNull()){dateofcreate=rez-\>FieldByName("DateOfCreate")-\>Value.operator TDateTime();}else{dateofcreate=0;}
        if (!rez-\>FieldByName("DateOfUpdate")-\>Value.IsNull()){dateofupdate=rez-\>FieldByName("DateOfUpdate")-\>Value.operator TDateTime();}else{dateofupdate=0;}
        \file-\>SetData    (id,sprazd,obd,name,sprazdname,icoid,
                        filename,filepath,creator,updater,accept,
                        dateofcreate,dateofupdate);
        node=Node-\>Owner-\>AddChildObject(Node,file-\>Get_Text(),(void*)file);
        node-\>ImageIndex=IcoData-\>GetInList(file-\>Get_icoID(),true,2);
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        rez-\>Next();
        }
    }
delete rez;
}
void __fastcall TSpTree::TreeExpanding(TObject *Sender, TTreeNode *Node, bool &amp;AllowExpansion)
{
Obd *bag=(Obd *)Node-\>Data;
if (Node-\>Level&amp;&amp;bag&amp;&amp;bag-\>TrueClassName()=="TreeRow"&amp;&amp;!((TreeRow*)bag)-\>Get_Force())
    {
    BranchClear(Node);
    LoadTree(Node);
    }
}
void __fastcall TSpTree::TreeMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y)
{
TTreeView* TV=(TTreeView*)Sender;
Selection(TV,Shift,X,Y);
TTreeNode *node=TV-\>GetNodeAt(X,Y);
if (!node) {return;}
if (node==TV-\>Selected&amp;&amp;memo)
    {
    memo-\>Lines-\>Clear();
    if (node-\>Data)
        {
        Obd *bag=(Obd *)node-\>Data;
        if (bag-\>TrueClassName()=="TreeRow")
            {
            TreeRow* row=(TreeRow*)bag;
            if (row-\>Get_CanChild())
                {
                node=node-\>getFirstChild();
                }
            }
        if (bag-\>TrueClassName()=="FileRow")
            {
            node=node-\>Parent;
            }
        GetInfo(node);
        }
    }
}
void              TSpTree::GetInfo(TTreeNode *Node)
{
Obd *bag=(Obd *)Node-\>Data;
TreeRow *tr(0);
FileRow *fl(0);
if (bag-\>ItTrueClassName())
    {
    tr=(TreeRow *)Node-\>Parent-\>Data;
    }else
    {
    tr=(TreeRow *)Node-\>Data;
    }

// расписать информацию об узле/детали
memo-\>Lines-\>Add("Информация по спецификации");
memo-\>Lines-\>Add("Деталь: "+tr-\>Get_Text());
memo-\>Lines-\>Add("Формат: "+tr-\>Get_format());
memo-\>Lines-\>Add("Зона: "+tr-\>Get_zona());
memo-\>Lines-\>Add("Позиция: "+tr-\>Get_pos());
memo-\>Lines-\>Add("Кол-во: "+String(tr-\>Get_kol())+" "+tr-\>Get_eiName());
memo-\>Lines-\>Add("Признак производства: "+IntToStr(tr-\>Get_pp())+" - "+tr-\>Get_ppName());
memo-\>Lines-\>Add("Примечание: "+tr-\>Get_prim());
memo-\>Lines-\>Add("");
// расписать информацию о блокираторах и создателях
memo-\>Lines-\>Add("Работы c деталью/спецификацией");
memo-\>Lines-\>Add("Текущее состояние: "+tr-\>Get_CondName());
String dat="";
if (tr-\>Get_DetCreated().Val){dat=tr-\>Get_DetCreated();}else{dat="";}
memo-\>Lines-\>Add("Дата создания: "+dat);
memo-\>Lines-\>Add("Создал: "+tr-\>Get_DetCreator());
if (tr-\>Get_DetUpdated().Val){dat=tr-\>Get_DetUpdated();}else{dat="";}
memo-\>Lines-\>Add("Дата редактирования: "+dat);
memo-\>Lines-\>Add("Редактировал: "+tr-\>Get_DetUpdater());
if (tr-\>Get_RowCreated().Val){dat=tr-\>Get_RowCreated();}else{dat="";}
memo-\>Lines-\>Add("Внесена в спец-ю: "+dat);
memo-\>Lines-\>Add("Внес: "+tr-\>Get_RowCreator());
if (tr-\>Get_RowUpdated().Val){dat=tr-\>Get_RowUpdated();}else{dat="";}
memo-\>Lines-\>Add("Редактирование спец-и:"+dat);
memo-\>Lines-\>Add("Редактировал: "+tr-\>Get_RowUpdater());
memo-\>Lines-\>Add("");
memo-\>Lines-\>Add("Занято пользователем: ");
memo-\>Lines-\>Add(tr-\>Get_User());
memo-\>Lines-\>Add("");
// расписать информацию о входящих файлах
if (Node-\>Count)
    {
    memo-\>Lines-\>Add("Количество прикрепленных файлов: "+IntToStr(Node-\>Count));
    TTreeNode *node=Node-\>getFirstChild();
    while (node)
        {
        bag=(Obd *)node-\>Data;
        if (bag&amp;&amp;bag-\>TrueClassName()=="FileRow")
            {
            FileRow *fl=(FileRow*)bag;
            if (fl)
                {
                memo-\>Lines-\>Add("Файл: "+fl-\>Get_FileName());//данные о файле
                //memo-\>Lines-\>Add("Текущее состояние: "+fl-\>CondName);
                if (fl-\>Get_DateOfCreate().Val){dat=fl-\>Get_DateOfCreate();}else{dat="";}
                memo-\>Lines-\>Add("Дата добавления: "+dat);
                memo-\>Lines-\>Add("Добавил: "+fl-\>Get_Creator());
                if (fl-\>Get_DateOfUpdate().Val){dat=fl-\>Get_DateOfUpdate();}else{dat="";}
                memo-\>Lines-\>Add("Обновлен: "+dat);
                memo-\>Lines-\>Add("Обновил: "+fl-\>Get_Updater());
               //    memo-\>Lines-\>Add("Занято пользователем: "+fl-\>User);
                memo-\>Lines-\>Add("");
                }
            }
        node=node-\>getNextSibling();
        }
    }
// расписать  инфо о дате последнего запуска в производство;
}

void __fastcall TSpTree::N14Click(TObject *Sender)
{
UpdateBranch(Tree-\>Selected,true);
Tree-\>Selected-\>Expand(false);
}
void __fastcall TSpTree::N23Click(TObject *Sender)
{
int id=((Obd*)Tree-\>Items-\>GetFirstNode()-\>Data)-\>Get_ID();
LoadTree(id);
}
void __fastcall TSpTree::N21Click(TObject *Sender)
{
TTreeNode *node=Tree-\>Selected;
if (node)
    {
    node-\>Expand(true);
    }
}
void __fastcall TSpTree::N22Click(TObject *Sender)
{
TTreeNode *node=Tree-\>Selected;
if (node)
    {
    node-\>Collapse(true);
    }
}

void __fastcall TSpTree::N41Click(TObject *Sender)
{
TTreeView *TV=Tree;
for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
    {
    Block((Obd*)TV-\>Selections[i]-\>Data);
    UpdateInfo(TV-\>Selections[i]);
    }
TV-\>Repaint();
}
void __fastcall TSpTree::N42Click(TObject *Sender)
{
TTreeView *TV=Tree;
for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
    {
    UnBlock((Obd*)TV-\>Selections[i]-\>Data);
    UpdateInfo(TV-\>Selections[i]);
    }
TV-\>Repaint();
}void              TSpTree::Block(Obd *det)
{
if (det&amp;&amp;det-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow *)det;
    Row-\>UpdateVal();
    if (Row-\>Get_Accept())
        {
        String sql;
        if (!MassAction)
            {
            sql="Call block('"+String(Row-\>Get_ID())+"','"+String(LUser)+"')";
            } else
            {
            sql="Call blockALL('"+String(Row-\>Get_ID())+"','"+String(LUser)+"')";
            }
        if (!DB-\>SendCommand(sql)){return;}
        }
    }
}
void              TSpTree::UnBlock(Obd *det)
{
if (det&amp;&amp;det-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow *)det;
    Row-\>UpdateVal();
    if (Row-\>Get_Accept())
        {
        String sql;
        if (!MassAction)
            {
            sql="Call unblock('"+String(Row-\>Get_ID())+"','"+String(LUser)+"')";
            } else
            {
            sql="Call unblockALL('"+String(Row-\>Get_ID())+"','"+String(LUser)+"')";
            }
        if (!DB-\>SendCommand(sql)){return;}
        }
    }
}

void __fastcall TSpTree::N11Click(TObject *Sender)
{
TFileDisigner *wnd=new TFileDisigner(this-\>Owner,DB,LUser,0,false,0);
wnd-\>ShowModal();
delete wnd;
// добавить
if (Tree-\>Items-\>Count)
    {
    N23Click(N23);
    }
}
void __fastcall TSpTree::N4Click(TObject *Sender)
{
if (Tree-\>Selected&amp;&amp;Tree-\>Selected-\>Data)
    {
    TFileDisigner *wnd=new TFileDisigner(this-\>Owner,DB,LUser,(Obd *)Tree-\>Selected-\>Data,MassAction,1);
    wnd-\>ShowModal();
    delete wnd;
    }
// получить файлы
}
void __fastcall TSpTree::N5Click(TObject *Sender)
{
if (Tree-\>Selected&amp;&amp;Tree-\>Selected-\>Data)
    {
    TFileDisigner *wnd=new TFileDisigner(this-\>Owner,DB,LUser,(Obd *)Tree-\>Selected-\>Data,MassAction,2);
    wnd-\>ShowModal();
    delete wnd;
    }
if (Tree-\>Items-\>Count)
    {
    N23Click(N23);
    }
}

void __fastcall TSpTree::TechAction(TObject *Sender)
{
if (Tree-\>Selected)
    {
    //объект
    TMenuItem *m=(TMenuItem *)Sender;
    Obd *bag=(Obd*)Tree-\>Selected-\>Data;
    Obd *det=new Obd(*bag);
    switch (m-\>Tag)
        {
        case 1:{AddTexTab(det);break;}     //редактировать новая вкладка
        case 0:{LoadTexToCurrTab(det);break;}           //редактировать текущая вкладка
        case 3:{AddTexViewTab(det);break;}//просмотр новая вкладка
        case 2:{LoadexViewToCurrTab(det);break;}        //просмотр текущая вкладка
        default:break;
        }
    }
}
void __fastcall TSpTree::TechDel(TObject *Sender)
{
TTreeView *TV=Tree;
for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
    {
    int id=((Obd*)TV-\>Selections[i]-\>Data)-\>Get_ID();
    DB-\>SendCommand("Call TechDel('"+String(id)+"')");
    }
}

void __fastcall TSpTree::SpMaster(TObject *Sender)
{
int id=-1;
if (Tree-\>Selected)
    {
    id=((Obd*)Tree-\>Selected-\>Data)-\>Get_ID();
    }
TMenuItem *m=(TMenuItem *)Sender;
switch (m-\>Tag)
    {
    case 0:{break;}     //добавить
    case 1:{break;}     //редактировать
    case 2:{break;}        //просмотр
    default:break;
    }
}
void __fastcall TSpTree::SpDel(TObject *Sender)
{
//удалить
}

void __fastcall TSpTree::N26Click(TObject *Sender)
{
//смена состояния
TCond *wnd;
wnd=new TCond(this-\>Owner,*Tree,MassAction,DB,IcoData,LUser);
wnd-\>ShowModal();
delete wnd;
Obd *bag=0;
TreeRow *Row=0;
//обновить инфорацию о каждой детали в узле
for (unsigned int i=0; i \< Tree-\>SelectionCount; i++)
    {
    UpdateInfo(Tree-\>Selections[i]);
    bag=(Obd *)Tree-\>Selections[i]-\>Data;
    if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
        {
        Row=(TreeRow *)bag;
        Tree-\>Selections[i]-\>StateIndex=IcoData-\>GetInList(Row-\>Get_state(),Row-\>Get_Accept(),0);
        }
    }
//Tree-\>Repaint();
}

void __fastcall TSpTree::N10Click(TObject *Sender)
{
MassAction=false;
N10-\>Checked=!MassAction;
N9-\>Checked=MassAction;
}
void __fastcall TSpTree::N9Click(TObject *Sender)
{
MassAction=true;
N10-\>Checked=!MassAction;
N9-\>Checked=MassAction;
}

void              TSpTree::UpdateInfo(TTreeNode *Node)
{     //если массовые действи явыключены то происходит обновление указанного узла и входящих в него деталей
// при вуключенных масс действиях происходит полное перестроение ветви
FileRow *file=0;
Obd *bag=(Obd *)Node-\>Data;
if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow *)bag;
    Row-\>UpdateVal();
    if (MassAction)
        {
        bool expand=Node-\>Expanded;
        UpdateBranch(Node);
        if (expand)
            {
            Node-\>Expand(false);
            }
        }else
        {
        if (Row-\>Get_CanChild()||Row-\>Get_Force())// обновление информации в ноде разделе "документация"
            {
            Node=Node-\>getFirstChild();
            if (Node)
                {
                Obd *r=(Obd *)Node-\>Data;
                if (r&amp;&amp;r-\>TrueClassName()=="Obd")
                    {
                    r-\>UpdateVal();
                    r-\>SetData(r-\>Get_ID(),1,r-\>Get_Obd(false),r-\>Get_Name(),"Документация");
                    }
                }
            }
        if (Node&amp;&amp;Node-\>Count) // обновление информации в файлах
            {
            Node=Node-\>getFirstChild();
            while (Node)
                {
                bag=(Obd *)Node-\>Data;
                if (bag)
                    {
                    bag-\>UpdateVal();
                    }
                Node=Node-\>getNextSibling();
                }
            }
        }
    }
}

void __fastcall TSpTree::TreeAdvancedCustomDrawItem(TCustomTreeView *Sender, TTreeNode *Node,
          TCustomDrawState State, TCustomDrawStage Stage, bool &amp;PaintImages,
          bool &amp;DefaultDraw)
{
TTreeView *TV=(TTreeView *)Sender;
DefaultDraw=true;
Obd *bag=(Obd *)Node-\>Data;
if (bag&amp;&amp;bag-\>TrueClassName()=="TreeRow")
    {
    TreeRow *Row=(TreeRow *)bag;
    if (Node-\>Selected&amp;&amp;TV-\>Focused())   // В зависимости от того, выделен узел или нет
        {                                // Используются разные цветовые схемы
        if (LUser==Row-\>Get_UserID()&amp;&amp;Row-\>Get_Accept())
            {
            Sender-\>Canvas-\>Font-\>Color=clYellow; // разрешонный узел
            }else Sender-\>Canvas-\>Font-\>Color=clWhite;  // а это остальные
        }else
        {
        if (LUser==Row-\>Get_UserID()&amp;&amp;Row-\>Get_Accept())
            {
            Sender-\>Canvas-\>Font-\>Color=clGreen; // разрешонный узел
            }else Sender-\>Canvas-\>Font-\>Color=clBlack;  // а это остальные
        }
    }
}

void              TSpTree::Selection(TTreeView *TView,TShiftState Shift,int X, int Y)
{
if (!TView-\>Items-\>Count||!TView-\>GetNodeAt(X,Y)) {return;}
if (Shift.ToInt()!=17&amp;&amp;Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=20&amp;&amp;Shift.ToInt()!=9)
    {
    TView-\>ClearSelection();
    }
if (Shift.ToInt()!=12&amp;&amp;Shift.ToInt()!=9)
    {
    TView-\>Select(TView-\>GetNodeAt(X,Y),Shift);
    TView-\>GetNodeAt(X,Y)-\>Focused=true;
    }
TView-\>Repaint();
}

</code>

@@TFileDisigner::~TFileDisigner
Description
Деструктор.
C++ Syntax
<code lang="c++">
__fastcall TFileDisigner::~TFileDisigner(void)
{
ClearData();
}
</code>

@@TFileDisigner::ClearData
Description
Функция для очистки рабочих данных компонента
C++ Syntax
<code lang="c++">
void             TFileDisigner::ClearData(void)
{
grid.clear();
SGClear(SG,0);
}
</code>

@@TFileDisigner::TFileDisigner@TComponent*@cSQL *const@int &@Obd *const@bool@char &
Description
Конструктор. Опционально настраивает компонент на то или иное
действие.
C++ Syntax
<code lang="c++">
__fastcall TFileDisigner::TFileDisigner(TComponent* Owner,cSQL *const _DB,const int &amp;_LUser,
                                        const Obd *const det,bool MassAction,const char &amp;_type):
                                        TForm(Owner),LUser(_LUser),type(_type),DB(_DB)
{
//получение ссылки на хранилище файлов
TADOQuery *rez=DB-\>SendSQL("Select trim(value)as value from administration.settings where property='base'");
base=rez-\>FieldByName("value")-\>Value;
// инициализация сетки
SGClear(SG,0);
SG-\>Cells[1][0]="Файл";
SG-\>Cells[2][0]="Деталь";
SG-\>Cells[3][0]="Наличие в базе";
SG-\>Cells[4][0]="Действие";
SG-\>Cells[5][0]="Добавлено";
SG-\>Cells[6][0]="Добавил";
SG-\>Cells[7][0]="Изменено";
SG-\>Cells[8][0]="Изменил";
AutoWidthSG(SG);
//инициализация интерфейса
switch (type)
    {
    case 0:    {
            Caption="Добавление файлов к базе";
            N2-\>Enabled=true;
            save-\>Enabled=N2-\>Enabled;
            N1-\>Caption="Открыть";
            N1-\>ImageIndex=2;
            open-\>ImageIndex=N1-\>ImageIndex;
            break;
            }//загрузка файлов в базу
    case 1:    {
            N2-\>Enabled=false;
            save-\>Enabled=N2-\>Enabled;
            N1-\>Caption="Сохранить";
            N1-\>ImageIndex=3;
            open-\>ImageIndex=N1-\>ImageIndex;
            this-\>Caption="Получение файлов из базы";
            break;
            }//получение файлов из базы
    case 2:    {
            N2-\>Enabled=false;
            save-\>Enabled=N2-\>Enabled;
            N1-\>Caption="Удалить";
            N1-\>ImageIndex=9;
            open-\>ImageIndex=N1-\>ImageIndex;
            this-\>Caption="Удаление файлов из базы";
            break;
            }//удаление файлов из базы
    default:break;
    }
if ((type==1||type==2)&amp;&amp;det)
    {
    LoadFiles(det,MassAction);
    ShowData();
    }
}
</code>
Type Parameters
Owner :       Указатель на компонет\-хозяин
_DB :         Указатель на класс для работы с базой данных
_LUser :      Ссылка на идентификатор пользователя
det :         Указатель на объект данных о детали
MassAction :  Индикатор массовых действий
_type :       тип запуска компонента
              * 0&#45; загрузка файлов в базу
              * 1&#45; скачивание файлов из базы
              * 2&#45; удаление файлов из базы

@@TFileDisigner::LoadFiles@Obd *const@bool
Description
Функция для загрузки информации о файлах из базы
C++ Syntax
<code lang="c++">
void             TFileDisigner::LoadFiles(const Obd *const det,bool MassAction)
{
if (det)
    {
    if (det-\>TrueClassName()!="FileRow")
        {
        String sql="";
        if (MassAction) // проанализировать мас акчион
            {// если масс акшен то получить все пары файл-обозначение из узла
            sql="Call constructions.GetFilesForTree('"+String(det-\>Get_ID())+"')";
            }else
            {// иначе получить только пары файл-обозначение из текущего узла
            sql="Call constructions.GetFiles('"+String(det-\>Get_ID())+"')";
            }
            // наполниить массив
        TADOQuery *rez=DB-\>SendSQL(sql);
        if (rez&amp;&amp;rez-\>RecordCount)
            {
            rez-\>First();
            while (!rez-\>Eof)
                {
                FRowData *row=new FRowData(DB,LUser,rez-\>FieldByName("Name")-\>Value,rez-\>FieldByName("idDet")-\>Value,base,type);
                grid.push_back(*row);
                delete row;
                rez-\>Next();
                }
            }
        delete rez;
        }else
        {
        FRowData *row=new FRowData(DB,LUser,((FileRow*)det)-\>Get_FileName(),det-\>Get_ID(),base,type);
        grid.push_back(*row);
        delete row;
        }
    }
}

</code>
Type Parameters
det :         Указатель на объект данных детали
MassAction :  Индикатор необходимомти загрузки файлов из
              входящих в состав узлов/деталей

@@FRowData::init
Description
Функция инициализации переменных класса данных
C++ Syntax
<code lang="c++">
void     FRowData::init(void)
{
inBaseFileName="";
FilePath="";
Action="Нет";
inbase=false;
}
</code>

@@FRowData::UpdateVal@int
Description
Функция обновления данных на основе идентификатора детали
C++ Syntax
<code lang="c++">
void     FRowData::UpdateVal(int id)
{
SetData(DB-\>SendSQL("Call constructions.GetDataForFileAndID('"+String(id)+"','"+FileName+"','"+String(LUser)+"')"));
}
</code>

Type Parameters
id :  Идентификатор детали/узла для которого загружается
      список файлов

@@FRowData::SetData@TADOQuery *
Description
Функция наполнения переменных класса из результата запроса
C++ Syntax
<code lang="c++">
void     FRowData::SetData (TADOQuery *rez)
{
if (rez&amp;&amp;rez-\>RecordCount)
    {
    //данные для сетки
    SetId(rez-\>FieldByName("id")-\>Value);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SetObd(rez-\>FieldByName("obd")-\>Value);
    Name=rez-\>FieldByName("DetName")-\>Value;
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    Accept=rez-\>FieldByName("Accept")-\>Value;
    FilePath=rez-\>FieldByName("FileInBase")-\>Value.operator UnicodeString();
    inBaseFileName=rez-\>FieldByName("InBaseName")-\>Value.operator UnicodeString();
    String _FileName=rez-\>FieldByName("InProjName")-\>Value;
    String _inProjectPath=rez-\>FieldByName("FileInProj")-\>Value;
    if (FilePath==""&amp;&amp;inBaseFileName=="")
        {
        inbase=false;
        }else
        {
        FileName=_FileName;
        if (type)
            {
            inProjectPath=_inProjectPath;
            }
        inbase=true;
        }
    icoID=rez-\>FieldByName("icoID")-\>Value;
    //информация о добавлении
    Creator=rez-\>FieldByName("Creator")-\>Value;
    Updater=rez-\>FieldByName("Updater")-\>Value;
    if (rez-\>FieldByName("DateOfCreate")-\>Value.IsNull())
        {
        DateOfCreate=0;
        }else
        {
        DateOfCreate=rez-\>FieldByName("DateOfCreate")-\>Value.operator TDateTime();
        }
    if (rez-\>FieldByName("DateOfUpdate")-\>Value.IsNull())
        {
        DateOfUpdate=0;
        }else
        {
        DateOfUpdate=rez-\>FieldByName("DateOfUpdate")-\>Value.operator TDateTime();
        }
    SetAction();
    }
delete rez;
}
</code>

Type Parameters
rez :  результат выполнения запроса

@@FRowData::FRowData@cSQL *const@int &@String &@int &@String &@char &
Description
Конструктор. Первоначальная инициализация класса данных
C++ Syntax
<code lang="c++">
 FRowData::FRowData(cSQL *const _DB,const int &amp;_LUser,const String &amp;File,const int &amp;id,const String &amp;_base,const char &amp;_type)
\:FileRow(_DB,_LUser),type(_type),base(_base)
{
count++;
init();
FileName=ExtractFileName(File);
inProjectPath=ExtractFilePath(File);
switch (type)
    {
    case 0:{UpdateVal(FileName);break;}//загрузка файлов в базу
    case 1:{UpdateVal(id);break;}//получение файлов из базы
    case 2:{UpdateVal(id);break;}//удаление файлов из базы
    default:{UpdateVal(FileName);break;}
    }
}
</code>
Type Parameters
_DB :     Указатель на класс для работы с базой данных
_LUser :  Ссылка на идентификатор пользователя
File\ :   Строка адреса файла. 
id :      Идентификатор детали для которого загружается список
          файлов
_base :   Строка адреса хранилища.
_type :   ссылка на тип запуска класса данных

@@FRowData::SetAction
Description
Функция назначение действия по умолчанию.
C++ Syntax
<code lang="c++">
void     FRowData::SetAction(void)//public???
{
switch (type)
    {
    case 0: {
            if (Accept)
                {
                if (inbase)
                    {
                    Action="Обновить";
                    }else
                    {
                    Action="Добавить";
                    }
                }else
                {
                Action="Нет";
                }
            break;
            }
    case 1: {
            if (Accept)
                {
                if (inbase)
                    {
                    Action="Получить";
                    }else
                    {
                    Action="Нет";
                    }
                }else
                {
                Action="Нет";
                }
            break;
            }
    case 2: {
            if (Accept)
                {
                if (inbase)
                    {
                    Action="Удалить";
                    }else
                    {
                    Action="Нет";
                    }
                }else
                {
                Action="Нет";
                }
            break;
            }
    default:break;
    }
} 
</code>

@@FRowData::FRowData@FRowData &
Description
Конструктор копировщик.
C++ Syntax
<code lang="c++">
 FRowData::FRowData(const FRowData &amp;r):FileRow(r),type(r.type),base(r.base)
{
count++;
inBaseFileName=r.inBaseFileName;
inProjectPath=r.inProjectPath;
Action=r.Action;
inbase=r.inbase;
}
</code>
Type Parameters
r :  Ссылка на копируемый экземпляр класса

@@FRowData::~FRowData
Description
Деструктор.
C++ Syntax
<code lang="c++">
 FRowData::~FRowData(void)
{
count--;
}
</code>

@@TFileDisigner::ShowData
Description
Функция отображения данных.
C++ Syntax
<code lang="c++">
void TFileDisigner::ShowData (void)
{
SGClear(SG,0);
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    SG-\>Cells[1][SG-\>RowCount-1]=i-\>Get_FileName();
    SG-\>Cells[2][SG-\>RowCount-1]=i-\>Get_Text();
    if (i-\>Get_inbase())
        {
        SG-\>Cells[3][SG-\>RowCount-1]="Есть в базе";
        }else
        {
        SG-\>Cells[3][SG-\>RowCount-1]="Нет в базе";
        }
    SG-\>Cells[4][SG-\>RowCount-1]=i-\>Get_Action();
    if (i-\>Get_DateOfCreate().Val!=0)
        {
        SG-\>Cells[5][SG-\>RowCount-1]=i-\>Get_DateOfCreate().DateString();
        }else
        {
        SG-\>Cells[5][SG-\>RowCount-1]="";
        }
    SG-\>Cells[6][SG-\>RowCount-1]=i-\>Get_Creator();
    if (i-\>Get_DateOfUpdate().Val!=0)
        {
        SG-\>Cells[7][SG-\>RowCount-1]=i-\>Get_DateOfUpdate().DateString();
        }else
        {
        SG-\>Cells[7][SG-\>RowCount-1]="";
        }
    SG-\>Cells[8][SG-\>RowCount-1]=i-\>Get_Updater();
      //    i-\>Get_Accept();
    SG-\>RowCount++;
    }
if (SG-\>RowCount\>2)
    {
    SG-\>RowCount--;
    }
AutoWidthSG(SG);
}
</code>

@@TFileDisigner::SGDrawCell@TObject *@int@int@TRect &@TGridDrawState
Description
Функция отрисовки сетки.
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::SGDrawCell(TObject *Sender, int ACol, int ARow, TRect &amp;Rect,
          TGridDrawState State)
{
TStringGrid *sg=(TStringGrid *)Sender;
if (ARow&amp;&amp;ACol&amp;&amp;grid.size())
    {
    if (grid[ARow-1].Get_Accept())
        {
        if (grid[ARow-1].Get_inbase())
            {
            sg-\>Canvas-\>Brush-\>Color=0x00DDFFFF; //clYellow разрешонный узел
            }else
            {
            sg-\>Canvas-\>Brush-\>Color=0x00DDFFDD;//clGreen; // разрешонный узел
            }
        }else
        {
        sg-\>Canvas-\>Brush-\>Color=0x00DDDDFF;// clRed нет доступа
        }
    sg-\>Canvas-\>Font-\>Color=clBlack;
if (ACol\>=sg-\>Selection.Left&amp;&amp;ACol\<=sg-\>Selection.Right&amp;&amp;ARow\>=sg-\>Selection.Top&amp;&amp;ARow\<=sg-\>Selection.Bottom)                                     //выделение
    {
    sg-\>Canvas-\>Brush-\>Color=0x00FFDDDD;//clBlue;
    sg-\>Canvas-\>Font-\>Color=clBlack;
    }
    sg-\>Canvas-\>FillRect(Rect);
    sg-\>Canvas-\>TextOutW(Rect.left+2,Rect.top+1,sg-\>Cells[ACol][ARow]);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию
ACol :    Номер колонки отрисовываемой ячейки
ARow :    Номер строки отрисовываемой ячейки
Rect :    Границы отрисовываемой ячейки
State :   Состояние отрисовываемой ячейки

@@TFileDisigner::SGFixedCellClick@TObject *@int@int
Description
Обработчик клика нажатия заголовка сетки
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::SGFixedCellClick(TObject *Sender, int ACol, int ARow)
{
switch (ACol)
    {
    case 1:{FileAsc=!FileAsc;        SortByFile(FileAsc);break;}
    case 2:{ObdAsc=!ObdAsc;          SortByObd(ObdAsc);break;}
    case 3:{InBaseAsc=!InBaseAsc;     SortByInBase(InBaseAsc);break;}
    case 4:{ActionAsc=!ActionAsc;     SortByAction(ActionAsc);break;}
    default:break;
    }
ShowData();
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию
ACol :    Номер колонки отрисовываемой ячейки
ARow :    Номер строки отрисовываемой ячейки

@@TFileDisigner::SortByObd@bool
Description
Функция сортировки по обозначению
C++ Syntax
<code lang="c++">
void TFileDisigner::SortByObd    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Obd(true) \> grid.operator [](j+inc).Get_Obd(true)); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Obd(true) \< grid.operator [](j+inc).Get_Obd(true)); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
</code>
Type Parameters
asc :  Признак сортировки по обозначению

@@TFileDisigner::increment@long@long
Description
Вспомогательная функция для сортировки
C++ Syntax
<code lang="c++">
int             TFileDisigner::increment    (long inc[], long size)
{
int p1, p2, p3, s;
p1 = p2 = p3 = 1;
s = -1;
do
    {
    if (++s % 2)
        {
        inc[s] = 8*p1 - 6*p2 + 1;
        } else
        {
        inc[s] = 9*p1 - 9*p3 + 1;
        p2 *= 2;
        p3 *= 2;
        }
    p1 *= 2;
    }
while(3*inc[s] \< size);
return s \> 0 ? --s : 0;
}
</code>
Type Parameters
inc :   Массив 
size :  Размер массива

@@TFileDisigner::SortByFile@bool
Description
Функция сортировки по имени файла
C++ Syntax
<code lang="c++">
void TFileDisigner::SortByFile    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_FileName() \> grid.operator [](j+inc).Get_FileName()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_FileName() \< grid.operator [](j+inc).Get_FileName()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
</code>

Type Parameters
asc :  Признак сортировки по обозначению

@@FRowData::=@FRowData &
Description
Оператор присваивания
C++ Syntax
<code lang="c++">
FRowData &amp;     FRowData::operator =(const FRowData &amp;r)
{
if (this==&amp;r) {return *this;}
id=r.id;
SpRazd=r.SpRazd;
icoID=r.icoID;
//const int &amp;LUser;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
FileName=r.FileName;
FilePath=r.FilePath;
Creator=r.Creator;
Updater=r.Updater;
DateOfCreate=r.DateOfCreate;
DateOfUpdate=r.DateOfUpdate;
inBaseFileName=r.inBaseFileName;
inProjectPath=r.inProjectPath;
Action=r.Action;
//const String &amp;base;
inbase=r.inbase;
Accept=r.Accept;
//const char &amp; type;
return *this;
}
</code>

@@TFileDisigner::SortByInBase@bool
Description
Функция сортировки по наличию в базе
C++ Syntax
<code lang="c++">
void TFileDisigner::SortByInBase    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_inbase() \> grid.operator [](j+inc).Get_inbase()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_inbase() \< grid.operator [](j+inc).Get_inbase()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
</code>

Type Parameters
asc :  Признак сортировки по обозначению

@@TFileDisigner::SortByAction@bool
Description
Функция сортировки по предлагаему действию
C++ Syntax
<code lang="c++">
void TFileDisigner::SortByAction    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Action() \> grid.operator [](j+inc).Get_Action()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Action() \< grid.operator [](j+inc).Get_Action()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
</code>

Type Parameters
asc :  Признак сортировки по обозначению

@@TFileDisigner::ClearClick@TObject *
Description
Функция-обработчик удаления строки из очереди
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::ClearClick(TObject *Sender)
{
if (grid.size())
    {
    vector \<FRowData\>::iterator i,j;
    i=grid.begin()+SG-\>Selection.Top-1;
    j=grid.begin()+SG-\>Selection.Bottom;
    grid.erase(i,j);
    ShowData();
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TFileDisigner::OpenClick@TObject *
Description
Обработчик нажатия кнопки главного действия
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::OpenClick(TObject *Sender)
{
switch (type)
    {
    case 0:    {
            OpenFiles();
            break;
            }
    case 1:    {
            SaveToPc();
            if (!grid.size())
                {
                ShowMessage("Файлы получены успешно.");
                this-\>Close();
                }
            break;
            }
    case 2:    {
            //удаление
            Delete();
            if (!grid.size())
                {
                ShowMessage("Файлы удалены успешно.");
                this-\>Close();
                }
            break;
            }
    default:break;
    }
}
</code>
Note
  * 0 &#45; диалог открытия файлов
  * 1 &#45; диалог сохранения файлов на компьютер
  * 2 &#45; удаление файлов из хранилища
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TFileDisigner::SaveToPc
Description
Процедура сохранения файлов на компьютер
C++ Syntax
<code lang="c++">
void            TFileDisigner::SaveToPc(void)
{
SD-\>FileName="_";
bool result=SD-\>Execute();
//диалог сохранения

// само сохраненние
if (SD-\>FileName.Length()&amp;&amp;result)
    {
    String path=ExtractFilePath(SD-\>FileName);
    for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
        {
        if (i-\>Get_Action()=="Получить")
            {
            if (i-\>SaveToPC(path))
                {
                i=grid.erase(i);
                i--;
                }
            }
        }
    }
ShowData();
}
</code>

@@TFileDisigner::OpenFiles
Description
Функция для получения информации о загружаемых в базу файлах
C++ Syntax
<code lang="c++">
void TFileDisigner::OpenFiles(void)
{
OD-\>Files-\>Clear();
OD-\>FileName="";
OD-\>Execute();
if (OD-\>Files-\>Count)
    {
    for (int i=0; i\<OD-\>Files-\>Count; i++)
        {
        FRowData *row=new FRowData(DB,LUser,OD-\>Files-\>operator [](i),0,base,type);
        if (!CheckData(row))     // проверка на наличие пары деталь файл в массиве
            {
            grid.push_back(*row);
            }
        delete row;
        }
    ShowData();
    }
}
</code>

@@FRowData::UpdateVal@String
Description
Функция обновления данных на основе обозначения детали
C++ Syntax
<code lang="c++">
void     FRowData::UpdateVal(String obd)
{
SetData(DB-\>SendSQL("Call constructions.FindObdForFile('"+GostToVin(obd)+"','"+FileName+"','"+String(LUser)+"')"));
}
</code>

Type Parameters
obd :  Обозначение детали

@@TFileDisigner::CheckData@FRowData *
Description
Функция проверки на дублирование класса данных в массиве
C++ Syntax
<code lang="c++">
bool            TFileDisigner::CheckData(FRowData *row)
{
for (unsigned int i=0; i!=grid.size(); i++)
    {
    if (grid[i]==*row)
        {
        return true;
        }
    }
return false;
}
</code>
Type Parameters
row :  указатель на класс данных наличие которых необходимо
       проверить с массиве

@@FRowData::==@FRowData &
Description
Прямой оператор сравнения
C++ Syntax
<code lang="c++">
bool FRowData::operator ==(const FRowData &amp;r)
{
if (this==&amp;r) {return true;}
if (
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    icoID==r.icoID&amp;&amp;
    LUser==r.LUser&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    FileName==r.FileName&amp;&amp;
    FilePath==r.FilePath&amp;&amp;
    Creator==r.Creator&amp;&amp;
    Updater==r.Updater&amp;&amp;
    DateOfCreate==r.DateOfCreate&amp;&amp;
    DateOfUpdate==r.DateOfUpdate&amp;&amp;
    inBaseFileName==r.inBaseFileName&amp;&amp;
    inProjectPath==r.inProjectPath&amp;&amp;
    Action==r.Action&amp;&amp;
    base==r.base&amp;&amp;
    inbase==r.inbase&amp;&amp;
    Accept==r.Accept&amp;&amp;
    type==r.type
    )
    {
    return true;
    }else
    {
    return false;
    }
}
</code>

@@TFileDisigner::ClearAllClick@TObject *
Description
Функция обработчик команды "очистить все"
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::ClearAllClick(TObject *Sender)
{
//очистка вектора
ClearData();
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TFileDisigner::SaveClick@TObject *
Description
функция обработки команды "сохранить"
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::SaveClick(TObject *Sender)
{
SaveToBase();
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TFileDisigner::SaveToBase
Description
функция сохранения файлов в базу данных
C++ Syntax
<code lang="c++">
void TFileDisigner::SaveToBase(void)
{
bool allow_change=ChangeFiles();
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    if (i-\>Get_Accept()&amp;&amp;((i-\>Get_Action()=="Обновить"&amp;&amp;allow_change)||i-\>Get_Action()=="Добавить"))
        {
        if (i-\>SaveToBase())
            {
            i=grid.erase(i);
            i--;
            }
        }
    }
ShowData();
}
</code>

@@TFileDisigner::ChangeFiles
Description
Функция опроса пользователя на подтверждения действий
C++ Syntax
<code lang="c++">
bool TFileDisigner::ChangeFiles(void)
{
String act,msg;
switch (type)
    {
    case 0:{act="Обновить";msg="Подтвердить замену файлов";break;}
    case 1:{act="";msg="";break;}
    case 2:{act="Удалить";msg="Подтвердить удаление файлов";break;}
    default:break;
    }
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    if (i-\>Get_Action()==act)
        {
        if (MessageDlg(msg,mtWarning,TMsgDlgButtons()\<\<mbYes\<\<mbNo,0)==mrYes)
        {return true;}else
        {return false;}
        }
    }
return false;
}
</code>

@@TFileDisigner::Delete
Description
Функция удаления файлов из базы
C++ Syntax
<code lang="c++">
void TFileDisigner::Delete(void)
{
bool allow_change=ChangeFiles();
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    if (i-\>Get_Action()=="Удалить"&amp;&amp;allow_change)
        {
        if (i-\>Delete())
            {
            i=grid.erase(i);
            i--;
            }
        }
    }
ShowData();
}
</code>

@@FRowData::Delete
Description
Функция удаления файла из базы
C++ Syntax
<code lang="c++">
bool     FRowData::Delete(void)
{
//удалить файл
String from="",sql="";
from=base+FilePath+inBaseFileName;
if(DeleteFile(from.c_str()))
    {
    sql="Call constructions.DelFile('"+ekran(FilePath)+"','"+ekran(inBaseFileName)+"','"+String(LUser)+"')";
    return DB-\>SendCommand(sql);  // при ошибке запроса файл останется в базе потому должен остаться и в списке
    }else
    {
    return false;  // вероятно ошибка связи возвращаем фолс чтоб файл остался в списке
    }
}
</code>

@@TFileDisigner::SGDblClick@TObject *
Description
Функция обработки двойного нажатия на сетку
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::SGDblClick(TObject *Sender)
{
if (!grid.size()) {return;} //проверка заполненности массива
TStringGrid *sg=(TStringGrid *)Sender;
int ACol,ARow;
TPoint s;                  //вычисление кликнутой ячейки
GetCursorPos(&amp;s);
s=sg-\>ScreenToClient(s);
sg-\>MouseToCell(s.X,s.Y,ACol,ARow);
if (ARow\<=0) {return;}    //проверка клика
switch (ACol)
    {
    case 2:{SetNewObd(ACol,ARow);break;}
    case 4:{SetNewAction(ACol,ARow);break;}
    default:return;
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию
Note
  * Ячейка 2 &#45; вызов компонента ввода текста
  * Ячейка 4 &#45; вызов компонента выбота текста

@@TFileDisigner::SetNewObd@int@int
Description
Функция инициализации компонента ввода текста
C++ Syntax
<code lang="c++">
void            TFileDisigner::SetNewObd(int ACol,int ARow)
{
if (type) {return;}//отключение обоих функций для режима восстановления/удаления файлов
//if (!grid[ARow-1].Get_Accept()&amp;&amp;grid[ARow-1].Get_inbase()) {return;}    //проверка на наличие доступа к детали и файла в базе
TRect R=SG-\>CellRect(ACol,ARow);
// проверка на наличие мыши в зоне
R.Left=R.Left+SG-\>Left;
R.Right=R.Right+SG-\>Left;
R.Top=R.Top+SG-\>Top;
R.Bottom=R.Bottom+SG-\>Top;
ED-\>Left=R.Left+1;
ED-\>Top=R.Top+1;
ED-\>Width=(R.Right+1)-R.Left;
ED-\>Height=(R.Bottom+1)-R.Top;
ED-\>Visible=true;
ED-\>SetFocus();
}
</code>
Type Parameters
ACol :  Номер колонки ячейки
ARow :  Номер смтроки ячейки
Note
<code>
if (!grid[ARow-1].Get_Accept()&amp;&amp;grid[ARow-1].Get_inbase()) {return;}
разрешает вносить изменение в строку только в случае
разрешения на изменение и при наличии файла в базе
</code>

@@TFileDisigner::EDKeyPress@TObject *@wchar_t &
Description
Обработчик события нажатия кнопки.
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::EDKeyPress(TObject *Sender, wchar_t &amp;Key)
{
TEdit *ed=(TEdit *)Sender;
if (Key==13)
    {
    int pos=SG-\>Selection.Top-1;
    grid[pos].UpdateVal(ed-\>Text);
    UpdRow(pos+1);
    ed-\>Hide();
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию
Key :     Код надатой клавиши

@@TFileDisigner::UpdRow@int
Description
Функция обновления данных в строке сетки.
C++ Syntax
<code lang="c++">
void TFileDisigner::UpdRow(int ARow)
{
SG-\>Cells[1][ARow]=grid[ARow-1].Get_FileName();
SG-\>Cells[2][ARow]=grid[ARow-1].Get_Text();
if (grid[ARow-1].Get_inbase())
    {
    SG-\>Cells[3][ARow]="Есть в базе";
    }else
    {
    SG-\>Cells[3][ARow]="Нет в базе";
    }
SG-\>Cells[4][ARow]=grid[ARow-1].Get_Action();
if (grid[ARow-1].Get_DateOfCreate().Val!=0)
    {
    SG-\>Cells[5][ARow]=grid[ARow-1].Get_DateOfCreate().DateString();
    }else
    {
    SG-\>Cells[5][ARow]="";
    }
SG-\>Cells[6][ARow]=grid[ARow-1].Get_Creator();
if (grid[ARow-1].Get_DateOfUpdate().Val!=0)
    {
    SG-\>Cells[7][ARow]=grid[ARow-1].Get_DateOfUpdate().DateString();
    }else
    {
    SG-\>Cells[7][ARow]="";
    }
SG-\>Cells[8][ARow]=grid[ARow-1].Get_Updater();
}
</code>
Type Parameters
ARow :  номер обновляемой строки

@@TFileDisigner::EDExit@TObject *
Description
Обработчик события выхода из компонента ввода текста
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::EDExit(TObject *Sender)
{
TEdit *ed=(TEdit *)Sender;
ed-\>Text="";
ed-\>Hide();
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TFileDisigner::SetNewAction@int@int
Description
Функция инициализации компонента выбора текста
C++ Syntax
<code lang="c++">
void TFileDisigner::SetNewAction(int ACol,int ARow)
{
if (!grid[ARow-1].Get_Accept()) {return;}
TRect R=SG-\>CellRect(ACol,ARow);
R.Left=R.Left+SG-\>Left;
R.Right=R.Right+SG-\>Left;
R.Top=R.Top+SG-\>Top;
R.Bottom=R.Bottom+SG-\>Top;
CB-\>Left=R.Left+1;
CB-\>Top=R.Top+1;
CB-\>Width=(R.Right+1)-R.Left;
CB-\>Height=(R.Bottom+1)-R.Top;
FillCombo(ARow-1);
CB-\>Visible=true;
CB-\>SetFocus();
}
</code>
Type Parameters
ACol :  Номер колонки ячейки
ARow :  Номер строки ячейки

Note
<code>
if (!grid[ARow-1].Get_Accept()) {return;}
разрешает вносить изменение в строку только в случае
разрешения на изменение
</code>

@@TFileDisigner::FillCombo@int
Description
Функция заполнения спсика выбора.
C++ Syntax
<code lang="c++">
void TFileDisigner::FillCombo(int pos)
{
CB-\>Clear();
CB-\>Items-\>Add("Нет");
switch (type)
    {
    case 0:    {
            if (grid[pos].Get_inbase())
                {
                CB-\>Items-\>Add("Обновить");
                }else
                {
                CB-\>Items-\>Add("Добавить");
                }
            break;
            }
    case 1:    {
            if (grid[pos].Get_inbase())
                {
                CB-\>Items-\>Add("Получить");
                }
            break;
            }
    case 2:    {
            if (grid[pos].Get_inbase())
                {
                CB-\>Items-\>Add("Удалить");
                }
            break;
            }
    default:break;
    }
}
</code>
Type Parameters
pos :  Номер строки в массиве

@@TFileDisigner::CBChange@TObject *
Description
Обработчик события выбора текста
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::CBChange(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
int pos=SG-\>Selection.Top-1;
grid[pos].SetAction(CB-\>Text);
UpdRow(pos+1);
cb-\>Hide();
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TFileDisigner::CBExit@TObject *
Description
Обработчик события выхода из компонента выбора текста
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::CBExit(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
cb-\>Clear();
cb-\>Text="";
cb-\>Hide();
}
</code>

Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@FRowData::SaveToBase
Description
функция сохранения детали в базе
C++ Syntax
<code lang="c++">
bool     FRowData::SaveToBase(void)
{
String from="",to="",sql="";
if (Action=="Обновить")
    {
    from=inProjectPath+FileName;
    to=base+FilePath+inBaseFileName;
    if(CopyFile(from.c_str(),to.c_str(),false))//false=замена существующего   //замена файла в архиве
        {
        sql="Call constructions.UpdateFile('"+ekran(FilePath)+"','"+ekran(inBaseFileName)+"','"+ekran(String(LUser))+"')";    //нет корректировки базы только корректировка даты обновления файла в базе
        return DB-\>SendCommand(sql);
        }else
        {
        return false;  // вероятно ошибка связи возвращаем фолс чтоб файл остался в списке
        }
    }else
    {
    inBaseFileName=GetFileName();
    FilePath=GetDirName();
    from=inProjectPath+FileName;
    to=base+FilePath+inBaseFileName;
    MkPjDir(FilePath,base);
    int i=0;                        //добавление файла к архиву
    while (!CopyFile(from.c_str(),to.c_str(),true)&amp;&amp;i\<1000) /// обработака случая когда идет свопадение имен и файл не копируется
        {
        inBaseFileName=GetFileName();
        if (FilePath.Length()\<20)   FilePath=FilePath+GetDirName(); else FilePath=GetDirName();
        inBaseFileName=String(inBaseFileName.ToIntDef(0)+1);
        to=base+FilePath+inBaseFileName;
        MkPjDir(FilePath,base);
        i++;
        }
    if (i\>=1000)
        {
        return false;
        }else
        {  //добавление строки в базу заполнени упд и адд дат
        sql="Call constructions.AddFile('"+String(id)+"','"+ekran(FilePath)+"','"+ekran(inProjectPath)+"','"+ekran(FileName)+"','"+ekran(inBaseFileName)+"','"+String(LUser)+"')";
        return DB-\>SendCommand(sql);
        }
    }
}
</code>

@@TFileDisigner::ActionAsc
Description
Индикатор сортировки по возрастанию. (колонка действие)

@@TFileDisigner::InBaseAsc
Description
Индикатор сортировки по возрастанию. (колонка наличие в базе)

@@TFileDisigner::ObdAsc
Description
Индикатор сортировки по возрастанию. (колонка обозначение)

@@TFileDisigner::FileAsc
Description
Индикатор сортировки по возрастанию. (колонка имя файла)

@@TFileDisigner::base
Description
Строка адреса хранилища файлов

@@TFileDisigner::type
Description
Тип запуска компонента.


Note
  * 0 &#45; загрузка/замена файлов
  * 1 &#45; сохранение файлов на компьютер
  * 2 &#45; удаление файлов из базы

@@TFileDisigner::grid
Description
Массив данных для сетки.

@@TFileDisigner::ImageList1
Description
Коллекция иконок для компонента.

@@TFileDisigner::LUser
Description
Ссылка на идентификатор пользователя.

@@TFileDisigner::CB
Description
Компонент для выбора текста.

@@TFileDisigner::ED
Description
Компонент для ввода текста в строки сетки.

@@TFileDisigner::DB
Description
Указатель на компонент для работы с базой данных

@@TFileDisigner::SG
Description
Сетка для отображения информации пользователю

@@TFileDisigner::OD
Description
Компонент диалога для указывания файла для отрытия в
программе.

@@TFileDisigner::SD
Description
Компонент диалога для сохранения файлов на компьютере.

@@TFileDisigner::open
Description
Кнопка главного действия.(открыть)

@@TFileDisigner::save
\ \ 
Description
Кнопка второстепенного действия(Save) 

@@TFileDisigner::clear
Description
Кнопка удаления сетки выделенных строк.

@@TFileDisigner::ClearAll
Description
Кнопка удаления всех данных из сетки(очистка массива данных)

@@TFileDisigner::ToolBar1
Description
Панель инструментров

@@TFileDisigner::PAB
Description
Контекстное меню

@@TFileDisigner::N1
Description
Команда "Открыть"

@@TFileDisigner::N2
Description
Команда "сохранить в базе"

@@TFileDisigner::N3
Description
Команда удаления строк из массива данных

@@TFileDisigner::N4
Description
Команда очистки данных из массива.

@@TFileDisigner
Description
Компонент для работы с файлами в базе
(добавление/удаление/возврат/изменение)

@@FRowData::!=@FRowData &
Description
Оператор сравнения (проверка на неравенство)
C++ Syntax
<code lang="c++">
bool FRowData::operator !=(const FRowData &amp;r)
{
if (this==&amp;r) {return false;}
if     (
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    icoID==r.icoID&amp;&amp;
    LUser==r.LUser&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    FileName==r.FileName&amp;&amp;
    FilePath==r.FilePath&amp;&amp;
    Creator==r.Creator&amp;&amp;
    Updater==r.Updater&amp;&amp;
    DateOfCreate==r.DateOfCreate&amp;&amp;
    DateOfUpdate==r.DateOfUpdate&amp;&amp;
    inBaseFileName==r.inBaseFileName&amp;&amp;
    inProjectPath==r.inProjectPath&amp;&amp;
    Action==r.Action&amp;&amp;
    base==r.base&amp;&amp;
    inbase==r.inbase&amp;&amp;
    Accept==r.Accept&amp;&amp;
    type==r.type
    )
    {
    return false;
    }else
    {
    return true;
    }
}
</code>

@@FRowData::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code lang="c++">
String TrueClassName     (void)const
{
return "FRowData";
};
</code>

@@FRowData::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code lang="c++">
bool ItTrueClassName    (void)const
{
return (TrueClassName()=="FRowData")?true:false;
};
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@FRowData::SetAction@String &
Description
Функция назначение действия по умолчанию.
C++ Syntax
<code lang="c++">
void SetAction (const String &amp;act)
{
Action=act;
}
</code>

@@FRowData::SetData@int &@int &@String &@String &@String &@int &@String &@String &@String &@String &@bool &@TDateTime &@TDateTime &@String &@String &
Description
Функция внесения данных извне
C++ Syntax
<code lang="c++">
bool FRowData::SetData     (
                const int &amp;_id,        const int &amp;_SpRazd,
                const String &amp;_Obd,    const String &amp;_Name,
                const String &amp;_SpRazdName,
                const int &amp;_icoID,        const String &amp;_FileName,    const String &amp;_FilePath,
                const String &amp;_Creator,    const String &amp;_Updater,    const bool &amp;_Accept,
                const TDateTime &amp;_DateOfCreate,    const TDateTime &amp;_DateOfUpdate,

                String &amp;_inBaseFileName,    String &amp;_inProjectPath
                )
{
    //данные для сетки
id=_id;
SpRazd=_SpRazd;
SetObd(_Obd);
Name=_Name;
SpRazdName=_SpRazdName;
Accept=_Accept;
FilePath=_FilePath;
inBaseFileName=_inBaseFileName;
FileName=_FileName;
inProjectPath=_inProjectPath;
if (FilePath==""&amp;&amp;inBaseFileName=="")
    {
    inbase=false;
    }else
    {
    inbase=true;
    }
icoID=_icoID;
    //информация о добавлении
Creator=_Creator;
Updater=_Updater;
DateOfCreate=_DateOfCreate;
DateOfUpdate=_DateOfUpdate;
SetAction();
}
</code>
Type Parameters
_id :              Идентификатор детали
_SpRazd :          Идентификатор раздела спецификации
_Obd :             Обозначение детали
_Name :            Наименование детали
_SpRazdName :      Название раздела спецификации
_icoID :           Идентификатор иконки
_FileName :        Наименование файла
_FilePath :        Расположение файла в архиве
_Creator :         Имя пользователя внесшего файл в базу
_Updater :         Имя пользователя обновившего файл в базе
_Accept :          Индикатор доступа к детали
_DateOfCreate :    Дата внесения файла в архив
_DateOfUpdate :    Дата обновления файла в архиве
_inBaseFileName :  Имя файла в базе
_inProjectPath :   Размещение файла в проекте (изначальное
                   расположение)

@@FRowData::Get_Action@const
Description
Функция доступа. Возвращает индикатор доступа.
C++ Syntax
<code lang="c++">
String Get_Action (void)const{return Action;}; 
</code>

@@FRowData::Get_inbase@const
Description
Функция доступа. Возвращает индикатор нахождения в базе
C++ Syntax
<code lang="c++">
bool Get_inbase (void)const
{
return inbase;
};
</code>

@@FRowData::Get_inBaseFileName@const
Description
Функция возврата. Возвращает имя файла в хранилище базы
данных
C++ Syntax
<code lang="c++">
bool Get_inbase (void)const{return inbase;};
</code>

@@FRowData::Get_inProjectPath@const
Description
Функция возврата. Возвращает изначальный путь к файлу.
C++ Syntax
<code lang="c++">
String Get_inProjectPath (void)const{return inProjectPath;};
</code>

@@FRowData::Get_Text@const
Description
Функция возврата. Возвращает текст для показа пользователю.
C++ Syntax
<code lang="c++">
String Get_Text (void)const{return Get_Obd(true)+"-"+Name;}
</code>

@@FRowData::Count@const
Description
Функция возврата. Возвращает количество созданных экземпляров
класса.
C++ Syntax
<code lang="c++">
int Count(void)const{return count;};
</code>

@@FRowData::Action
Description
Переменная содержащая действие которое будет сделано со
строкой дных.

@@FRowData::base
Description
Указатель на расположение хранилища файлов

@@FRowData::count
Description
Переменная, показывающая количество экземпляров класса.

@@FRowData::inbase
Description
Индикатор нахождение файла в базе данных

@@FRowData::inBaseFileName
Description
Переменная содержащая имя файла в хранилище базы данных.

@@FRowData::inProjectPath
Description
Переменная содержащая исходное расположение файла

@@FRowData::type
Ссылка на тип запуска компонента.

@@FRowData::SaveToPC@String &
Description
Функция возврата файла из базы данных
C++ Syntax
<code lang="c++">
bool     FRowData::SaveToPC(const String &amp;path)
{
String from="",to="";
from=base+FilePath+inBaseFileName;
to=path+FileName;
if(CopyFile(from.c_str(),to.c_str(),true))//false=замена существующего
    {
    return true;
    }else
    {
    return false;  // вероятно ошибка связи возвращаем фолс чтоб файл остался в списке
    }
}
</code>
Type Parameters
path :  Ссылка на новое расположение файла

@@FRowData
Description
Класс данных. Компонент для манипулирования файлом и его
данными

@@FRowData.cpp
Description
Класс данных. Компонент для манипулирования файлом и его
данными. (Файл описания)
C++ Syntax
<code lang="c++">

\#pragma hdrstop
\#include "FRowData.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)

        FRowData::FRowData(cSQL *const _DB,const int &amp;_LUser,const String &amp;File,const int &amp;id,const String &amp;_base,const char &amp;_type)
\:FileRow(_DB,_LUser),type(_type),base(_base)
{
count++;
init();
FileName=ExtractFileName(File);
inProjectPath=ExtractFilePath(File);
switch (type)
    {
    case 0:{UpdateVal(FileName);break;}//загрузка файлов в базу
    case 1:{UpdateVal(id);break;}//получение файлов из базы
    case 2:{UpdateVal(id);break;}//удаление файлов из базы
    default:{UpdateVal(FileName);break;}
    }
}
        FRowData::FRowData(const FRowData &amp;r):FileRow(r),type(r.type),base(r.base)
{
count++;
inBaseFileName=r.inBaseFileName;
inProjectPath=r.inProjectPath;
Action=r.Action;
inbase=r.inbase;
}
        FRowData::~FRowData(void)
{
count--;
}
void     FRowData::init(void)
{
inBaseFileName="";
FilePath="";
Action="Нет";
inbase=false;
}
void     FRowData::UpdateVal(String obd)
{
SetData(DB-\>SendSQL("Call FindObdForFile('"+GostToVin(obd)+"','"+FileName+"','"+String(LUser)+"')"));
}
void     FRowData::UpdateVal(int id)
{
SetData(DB-\>SendSQL("Call GetDataForFileAndID('"+String(id)+"','"+FileName+"','"+String(LUser)+"')"));
}
void     FRowData::SetData (TADOQuery *rez)
{
if (rez&amp;&amp;rez-\>RecordCount)
    {
    //данные для сетки
    SetId(rez-\>FieldByName("id")-\>Value);
    SpRazd=rez-\>FieldByName("razdSPID")-\>Value;
    SetObd(rez-\>FieldByName("obd")-\>Value);
    Name=rez-\>FieldByName("DetName")-\>Value;
    SpRazdName=rez-\>FieldByName("Razdname")-\>Value;
    Accept=rez-\>FieldByName("Accept")-\>Value;
    FilePath=rez-\>FieldByName("FileInBase")-\>Value.operator UnicodeString();
    inBaseFileName=rez-\>FieldByName("InBaseName")-\>Value.operator UnicodeString();
    String _FileName=rez-\>FieldByName("InProjName")-\>Value;
    String _inProjectPath=rez-\>FieldByName("FileInProj")-\>Value;
    if (FilePath==""&amp;&amp;inBaseFileName=="")
        {
        inbase=false;
        }else
        {
        FileName=_FileName;
        inProjectPath=_inProjectPath;
        inbase=true;
        }
    icoID=rez-\>FieldByName("icoID")-\>Value;
    //информация о добавлении
    Creator=rez-\>FieldByName("Creator")-\>Value;
    Updater=rez-\>FieldByName("Updater")-\>Value;
    if (rez-\>FieldByName("DateOfCreate")-\>Value.IsNull())
        {
        DateOfCreate=0;
        }else
        {
        DateOfCreate=rez-\>FieldByName("DateOfCreate")-\>Value.operator TDateTime();
        }
    if (rez-\>FieldByName("DateOfUpdate")-\>Value.IsNull())
        {
        DateOfUpdate=0;
        }else
        {
        DateOfUpdate=rez-\>FieldByName("DateOfUpdate")-\>Value.operator TDateTime();
        }
    SetAction();
    }
delete rez;
}
bool     FRowData::SetData     (
                const int &amp;_id,        const int &amp;_SpRazd,
                const String &amp;_Obd,    const String &amp;_Name,
                const String &amp;_SpRazdName,
                const int &amp;_icoID,        const String &amp;_FileName,    const String &amp;_FilePath,
                const String &amp;_Creator,    const String &amp;_Updater,    const bool &amp;_Accept,
                const TDateTime &amp;_DateOfCreate,    const TDateTime &amp;_DateOfUpdate,

                String &amp;_inBaseFileName,    String &amp;_inProjectPath
                )
{
    //данные для сетки
id=_id;
SpRazd=_SpRazd;
SetObd(_Obd);
Name=_Name;
SpRazdName=_SpRazdName;
Accept=_Accept;
FilePath=_FilePath;
inBaseFileName=_inBaseFileName;
FileName=_FileName;
inProjectPath=_inProjectPath;
if (FilePath==""&amp;&amp;inBaseFileName=="")
    {
    inbase=false;
    }else
    {
    inbase=true;
    }
icoID=_icoID;
    //информация о добавлении
Creator=_Creator;
Updater=_Updater;
DateOfCreate=_DateOfCreate;
DateOfUpdate=_DateOfUpdate;
SetAction();
}
bool     FRowData::SaveToBase(void)
{
String from="",to="",sql="";
if (Action=="Обновить")
    {
    from=inProjectPath+FileName;
    to=base+FilePath+inBaseFileName;
    if(CopyFile(from.c_str(),to.c_str(),false))//false=замена существующего   //замена файла в архиве
        {
        sql="Call UpdateFile('"+ekran(FilePath)+"','"+ekran(inBaseFileName)+"','"+ekran(String(LUser))+"')";    //нет корректировки базы только корректировка даты обновления файла в базе
        return DB-\>SendCommand(sql);
        }else
        {
        return false;  // вероятно ошибка связи возвращаем фолс чтоб файл остался в списке
        }
    }else
    {
    inBaseFileName=GetFileName();
    FilePath=GetDirName();
    from=inProjectPath+FileName;
    to=base+FilePath+inBaseFileName;
    MkPjDir(FilePath,base);
    int i=0;                        //добавление файла к архиву
    while (!CopyFile(from.c_str(),to.c_str(),true)&amp;&amp;i\<1000) /// обработака случая когда идет свопадение имен и файл не копируется
        {
        inBaseFileName=GetFileName();
        if (FilePath.Length()\<20)   FilePath=FilePath+GetDirName(); else FilePath=GetDirName();
        to=base+FilePath+inBaseFileName;
        MkPjDir(FilePath,base);
        i++;
        }
    if (i\>=1000)
        {
        return false;
        }else
        {  //добавление строки в базу заполнени упд и адд дат
        sql="Call AddFile('"+String(id)+"','"+ekran(FilePath)+"','"+ekran(inProjectPath)+"','"+ekran(FileName)+"','"+ekran(inBaseFileName)+"','"+String(LUser)+"')";
        return DB-\>SendCommand(sql);
        }
    }
return false;
}
bool     FRowData::SaveToPC(const String &amp;path)
{
String from="",to="";
from=base+FilePath+inBaseFileName;
to=path+FileName;
if(CopyFile(from.c_str(),to.c_str(),true))//false=замена существующего
    {
    return true;
    }else
    {
    return false;  // вероятно ошибка связи возвращаем фолс чтоб файл остался в списке
    }
}
bool     FRowData::Delete(void)
{
//удалить файл
String from="",sql="";
from=base+FilePath+inBaseFileName;
if(DeleteFile(from.c_str()))
    {
    sql="Call DelFile('"+ekran(FilePath)+"','"+ekran(inBaseFileName)+"','"+String(LUser)+"')";
    return DB-\>SendCommand(sql);  // при ошибке запроса файл останется в базе потому должен остаться и в списке
    }else
    {
    return false;  // вероятно ошибка связи возвращаем фолс чтоб файл остался в списке
    }
}
void     FRowData::SetAction(void)//public???
{
switch (type)
    {
    case 0: {
            if (Accept)
                {
                if (inbase)
                    {
                    Action="Обновить";
                    }else
                    {
                    Action="Добавить";
                    }
                }else
                {
                Action="Нет";
                }
            break;
            }
    case 1: {
            if (Accept)
                {
                if (inbase)
                    {
                    Action="Получить";
                    }else
                    {
                    Action="Нет";
                    }
                }else
                {
                Action="Нет";
                }
            break;
            }
    case 2: {
            if (Accept)
                {
                if (inbase)
                    {
                    Action="Удалить";
                    }else
                    {
                    Action="Нет";
                    }
                }else
                {
                Action="Нет";
                }
            break;
            }
    default:break;
    }
}

FRowData &amp;     FRowData::operator =(const FRowData &amp;r)
{
if (this==&amp;r) {return *this;}
id=r.id;
SpRazd=r.SpRazd;
icoID=r.icoID;
//const int &amp;LUser;
G_Obd=r.G_Obd;
V_Obd=r.V_Obd;
Name=r.Name;
SpRazdName=r.SpRazdName;
FileName=r.FileName;
FilePath=r.FilePath;
Creator=r.Creator;
Updater=r.Updater;
DateOfCreate=r.DateOfCreate;
DateOfUpdate=r.DateOfUpdate;
inBaseFileName=r.inBaseFileName;
inProjectPath=r.inProjectPath;
Action=r.Action;
//const String &amp;base;
inbase=r.inbase;
Accept=r.Accept;
//const char &amp; type;
return *this;
}
bool         FRowData::operator ==(const FRowData &amp;r)
{
if (this==&amp;r) {return true;}
if     (
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    icoID==r.icoID&amp;&amp;
    LUser==r.LUser&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    FileName==r.FileName&amp;&amp;
    FilePath==r.FilePath&amp;&amp;
    Creator==r.Creator&amp;&amp;
    Updater==r.Updater&amp;&amp;
    DateOfCreate==r.DateOfCreate&amp;&amp;
    DateOfUpdate==r.DateOfUpdate&amp;&amp;
    inBaseFileName==r.inBaseFileName&amp;&amp;
    inProjectPath==r.inProjectPath&amp;&amp;
    Action==r.Action&amp;&amp;
    base==r.base&amp;&amp;
    inbase==r.inbase&amp;&amp;
    Accept==r.Accept&amp;&amp;
    type==r.type
    )
    {
    return true;
    }else
    {
    return false;
    }
}
bool         FRowData::operator !=(const FRowData &amp;r)
{
if (this==&amp;r) {return false;}
if     (
    id==r.id&amp;&amp;
    SpRazd==r.SpRazd&amp;&amp;
    icoID==r.icoID&amp;&amp;
    LUser==r.LUser&amp;&amp;
    G_Obd==r.G_Obd&amp;&amp;
    V_Obd==r.V_Obd&amp;&amp;
    Name==r.Name&amp;&amp;
    SpRazdName==r.SpRazdName&amp;&amp;
    FileName==r.FileName&amp;&amp;
    FilePath==r.FilePath&amp;&amp;
    Creator==r.Creator&amp;&amp;
    Updater==r.Updater&amp;&amp;
    DateOfCreate==r.DateOfCreate&amp;&amp;
    DateOfUpdate==r.DateOfUpdate&amp;&amp;
    inBaseFileName==r.inBaseFileName&amp;&amp;
    inProjectPath==r.inProjectPath&amp;&amp;
    Action==r.Action&amp;&amp;
    base==r.base&amp;&amp;
    inbase==r.inbase&amp;&amp;
    Accept==r.Accept&amp;&amp;
    type==r.type
    )
    {
    return false;
    }else
    {
    return true;
    }
}
</code>

@@FRowData.h
Description
Класс данных. Компонент для манипулирования файлом и его
данными

(файл заголовков)
C++ Syntax
<code lang="c++">
\#ifndef FRowDataH
\#define FRowDataH
\#include "FileRow.h"
class FRowData:public FileRow
{
public:
    FRowData(cSQL *const _DB,const int &amp;_LUser,const String &amp;File,const int &amp;id,const String &amp;_base,const char &amp;_type);
    FRowData(const FRowData &amp;r);
    ~FRowData(void);
    void init(void);
    void UpdateVal(String obd);
    void UpdateVal(int id);
    bool SaveToBase(void);
    bool SaveToPC(const String &amp;path);
    bool Delete(void);


    bool ItTrueClassName    (void)const{return (TrueClassName()=="FRowData")?true:false;};
    String TrueClassName     (void)const{return "FRowData";};
    String Get_Text         (void)const{return Get_Obd(true)+"-"+Name;}
    String Get_inBaseFileName    (void)const{return inBaseFileName;};
    String Get_inProjectPath    (void)const{return inProjectPath;};
    String Get_Action            (void)const{return Action;};
    bool Get_inbase                (void)const{return inbase;};


    bool SetData     (
                    const int &amp;_id,        const int &amp;_SpRazd,
                    const String &amp;_Obd,    const String &amp;_Name,
                    const String &amp;_SpRazdName,
                    const int &amp;_icoID,        const String &amp;_FileName,    const String &amp;_FilePath,
                    const String &amp;_Creator,    const String &amp;_Updater,    const bool &amp;_Accept,
                    const TDateTime &amp;_DateOfCreate,    const TDateTime &amp;_DateOfUpdate,
                    String &amp;_inBaseFileName,    String &amp;_inProjectPath
                    );
    void SetAction    (const String &amp;act)        {Action=act;}

    FRowData &amp; operator =(const FRowData &amp;);
    bool operator ==(const FRowData &amp;);
    bool operator !=(const FRowData &amp;);
    int Count(void)const{return count;};
protected:

private:
    static int count;
    String inBaseFileName;
    String inProjectPath;
    String Action;
    const String &amp;base;
    bool inbase;
    const char &amp;type;

    void SetData (TADOQuery *rez);
    void SetAction(void);
};

int FRowData::count=0;
\#endif
</code>

@@files.h
Description
Компонент для работы с файлами в базе
(добавление/удаление/возврат/изменение)(файл заголовков)
C++ Syntax
<code lang="c++">
\#ifndef filesH
\#define filesH

\#include "FRowData.h"

\#include \<ActnPopup.hpp\>
\#include \<Classes.hpp\>
\#include \<ComCtrls.hpp\>
\#include \<Controls.hpp\>
\#include \<Dialogs.hpp\>
\#include \<Grids.hpp\>
\#include \<ImgList.hpp\>
\#include \<Menus.hpp\>
\#include \<PlatformDefaultStyleActnCtrls.hpp\>
\#include \<StdCtrls.hpp\>
\#include \<ToolWin.hpp\>

class TFileDisigner : public TForm
{
__published:
    TStringGrid *SG;
    TComboBox *CB;
    TOpenDialog *OD;
    TEdit *ED;
    TToolBar *ToolBar1;
    TToolButton *open;
    TToolButton *clear;
    TToolButton *save;
    TImageList *ImageList1;
    TToolButton *ClearAll;
    TPopupActionBar *PAB;
    TMenuItem *N1;
    TMenuItem *N2;
    TMenuItem *N3;
    TMenuItem *N4;
    TSaveDialog *SD;
    void __fastcall ClearAllClick(TObject *Sender);
    void __fastcall OpenClick(TObject *Sender);
    void __fastcall SGDrawCell(TObject *Sender, int ACol, int ARow, TRect &amp;Rect, TGridDrawState State);
    void __fastcall SaveClick(TObject *Sender);
    void __fastcall SGFixedCellClick(TObject *Sender, int ACol, int ARow);
    void __fastcall SGDblClick(TObject *Sender);
    void __fastcall CBExit(TObject *Sender);
    void __fastcall CBChange(TObject *Sender);
    void __fastcall EDExit(TObject *Sender);
    void __fastcall EDKeyPress(TObject *Sender, wchar_t &amp;Key);
    void __fastcall ClearClick(TObject *Sender);

private:
vector \<FRowData\> grid;
cSQL  *const     DB;
const int    &amp;LUser;
const char type;

bool FileAsc;
bool ObdAsc;
bool InBaseAsc;
bool ActionAsc;
String base;

bool    ChangeFiles(void);
bool    CheckData(FRowData *row);
void    ClearData(void);
void     ShowData (void);
void    SetNewObd(int ACol,int ARow);
void    SetNewAction(int ACol,int ARow);
void    FillCombo(int pos);
void    UpdRow(int ARow);

void     LoadFiles(const Obd *const det,bool MassAction);
void    SaveToBase(void);
void    SaveToPc(void);
void    Delete(void);
void    OpenFiles(void);

void    SortByObd(bool asc);
void    SortByFile(bool asc);
void    SortByInBase(bool asc);
void    SortByAction(bool asc);
int     increment(long inc[], long size);

public:
    __fastcall TFileDisigner(TComponent* Owner,cSQL *const _DB,const int &amp;_LUser,const Obd *const det,bool MassAction,const char &amp;_type);
    __fastcall ~TFileDisigner(void);
};
//---------------------------------------------------------------------------
\#endif
</code>

@@files.cpp
Description
Компонент для работы с файлами в базе
(добавление/удаление/возврат/изменение) (файл описания)
C++ Syntax
<code lang="c++">
\#include \<vcl.h\>
\#pragma hdrstop

\#include "files.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)
\#pragma resource "*.dfm"

__fastcall TFileDisigner::TFileDisigner(TComponent* Owner,cSQL *const _DB,const int &amp;_LUser,
                                        const Obd *const det,bool MassAction,const char &amp;_type):
                                        TForm(Owner),LUser(_LUser),type(_type),DB(_DB)
{
//получение ссылки на хранилище файлов
TADOQuery *rez=DB-\>SendSQL("Select trim(value)as value from settings where property='base'");
base=rez-\>FieldByName("value")-\>Value;
// инициализация сетки
SGClear(SG,0);
SG-\>Cells[1][0]="Файл";
SG-\>Cells[2][0]="Деталь";
SG-\>Cells[3][0]="Наличие в базе";
SG-\>Cells[4][0]="Действие";
SG-\>Cells[5][0]="Добавлено";
SG-\>Cells[6][0]="Добавил";
SG-\>Cells[7][0]="Изменено";
SG-\>Cells[8][0]="Изменил";
AutoWidthSG(SG);
//инициализация интерфейса
switch (type)
    {
    case 0:    {
            Caption="Добавление файлов к базе";
            N2-\>Enabled=true;
            save-\>Enabled=N2-\>Enabled;
            N1-\>Caption="Открыть";
            N1-\>ImageIndex=2;
            open-\>ImageIndex=N1-\>ImageIndex;
            break;
            }//загрузка файлов в базу
    case 1:    {
            N2-\>Enabled=false;
            save-\>Enabled=N2-\>Enabled;
            N1-\>Caption="Сохранить";
            N1-\>ImageIndex=3;
            open-\>ImageIndex=N1-\>ImageIndex;
            this-\>Caption="Получение файлов из базы";
            break;
            }//получение файлов из базы
    case 2:    {
            N2-\>Enabled=false;
            save-\>Enabled=N2-\>Enabled;
            N1-\>Caption="Удалить";
            N1-\>ImageIndex=9;
            open-\>ImageIndex=N1-\>ImageIndex;
            this-\>Caption="Удаление файлов из базы";
            break;
            }//удаление файлов из базы
    default:break;
    }
if ((type==1||type==2)&amp;&amp;det)
    {
    LoadFiles(det,MassAction);
    ShowData();
    }
}
__fastcall TFileDisigner::~TFileDisigner(void)
{
ClearData();
}

void __fastcall TFileDisigner::ClearAllClick(TObject *Sender)
{
//очистка вектора
ClearData();
}
void __fastcall TFileDisigner::OpenClick(TObject *Sender)
{
switch (type)
    {
    case 0:    {
            OpenFiles();
            break;
            }
    case 1:    {
            SaveToPc();
            if (!grid.size())
                {
                ShowMessage("Файлы получены успешно.");
                this-\>Close();
                }
            break;
            }
    case 2:    {
            //удаление
            Delete();
            if (!grid.size())
                {
                ShowMessage("Файлы удалены успешно.");
                this-\>Close();
                }
            break;
            }
    default:break;
    }
}
void __fastcall TFileDisigner::SaveClick(TObject *Sender)
{
SaveToBase();
}
void __fastcall TFileDisigner::ClearClick(TObject *Sender)
{
if (grid.size())
    {
    vector \<FRowData\>::iterator i,j;
    i=grid.begin()+SG-\>Selection.Top-1;
    j=grid.begin()+SG-\>Selection.Bottom;
    grid.erase(i,j);
    ShowData();
    }
}

bool            TFileDisigner::ChangeFiles(void)
{
String act,msg;
switch (type)
    {
    case 0:{act="Обновить";msg="Подтвердить замену файлов";break;}
    case 1:{act="";msg="";break;}
    case 2:{act="Удалить";msg="Подтвердить удаление файлов";break;}
    default:break;
    }
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    if (i-\>Get_Action()==act)
        {
        if (MessageDlg(msg,mtWarning,TMsgDlgButtons()\<\<mbYes\<\<mbNo,0)==mrYes)
        {return true;}else
        {return false;}
        }
    }
return false;
}
bool            TFileDisigner::CheckData(FRowData *row)
{
for (int i=0; i!=grid.size(); i++)
    {
    if (grid[i]==*row)
        {
        return true;
        }
    }
return false;
}

void            TFileDisigner::OpenFiles(void)
{
OD-\>Files-\>Clear();
OD-\>FileName="";
OD-\>Execute();
if (OD-\>Files-\>Count)
    {
    for (int i=0; i\<OD-\>Files-\>Count; i++)
        {
        FRowData *row=new FRowData(DB,LUser,OD-\>Files-\>operator [](i),0,base,type);
        if (!CheckData(row))     // проверка на наличие пары деталь файл в массиве
            {
            grid.push_back(*row);
            }
        delete row;
        }
    ShowData();
    }
}
void             TFileDisigner::LoadFiles(const Obd *const det,bool MassAction)
{
if (det)
    {
    if (det-\>TrueClassName()!="FileRow")
        {
        String sql="";
        if (MassAction) // проанализировать мас акчион
            {// если масс акшен то получить все пары файл-обозначение из узла
            sql="Call GetFilesForTree('"+String(det-\>Get_ID())+"')";
            }else
            {// иначе получить только пары файл-обозначение из текущего узла
            sql="Call GetFiles('"+String(det-\>Get_ID())+"')";
            }
            // наполниить массив
        TADOQuery *rez=DB-\>SendSQL(sql);
        if (rez&amp;&amp;rez-\>RecordCount)
            {
            rez-\>First();
            while (!rez-\>Eof)
                {
                FRowData *row=new FRowData(DB,LUser,rez-\>FieldByName("Name")-\>Value,rez-\>FieldByName("idDet")-\>Value,base,type);
                grid.push_back(*row);
                delete row;
                rez-\>Next();
                }
            }
        delete rez;
        }else
        {
        FRowData *row=new FRowData(DB,LUser,((FileRow*)det)-\>Get_FileName(),det-\>Get_ID(),base,type);
        grid.push_back(*row);
        delete row;
        }
    }
}
void            TFileDisigner::SaveToBase(void)
{
bool allow_change=ChangeFiles();
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    if (i-\>Get_Accept()&amp;&amp;((i-\>Get_Action()=="Обновить"&amp;&amp;allow_change)||i-\>Get_Action()=="Добавить"))
        {
        if (i-\>SaveToBase())
            {
            i=grid.erase(i);
            i--;
            }
        }
    }
ShowData();
}
void            TFileDisigner::SaveToPc(void)
{
SD-\>FileName="_";
SD-\>Execute();
//диалог сохранения
// само сохраненние
if (SD-\>FileName.Length())
    {
    String path=ExtractFilePath(SD-\>FileName);
    for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
        {
        if (i-\>Get_Action()=="Получить")
            {
            if (i-\>SaveToPC(path))
                {
                i=grid.erase(i);
                i--;
                }
            }
        }
    }
ShowData();
}
void            TFileDisigner::Delete(void)
{
bool allow_change=ChangeFiles();
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    if (i-\>Get_Action()=="Удалить"&amp;&amp;allow_change)
        {
        if (i-\>Delete())
            {
            i=grid.erase(i);
            i--;
            }
        }
    }
ShowData();
}

void             TFileDisigner::ShowData (void)
{
SGClear(SG,0);
for (vector \<FRowData\>::iterator i=grid.begin(); i!=grid.end(); i++)
    {
    SG-\>Cells[1][SG-\>RowCount-1]=i-\>Get_FileName();
    SG-\>Cells[2][SG-\>RowCount-1]=i-\>Get_Text();
    if (i-\>Get_inbase())
        {
        SG-\>Cells[3][SG-\>RowCount-1]="Есть в базе";
        }else
        {
        SG-\>Cells[3][SG-\>RowCount-1]="Нет в базе";
        }
    SG-\>Cells[4][SG-\>RowCount-1]=i-\>Get_Action();
    if (i-\>Get_DateOfCreate().Val!=0)
        {
        SG-\>Cells[5][SG-\>RowCount-1]=i-\>Get_DateOfCreate().DateString();
        }else
        {
        SG-\>Cells[5][SG-\>RowCount-1]="";
        }
    SG-\>Cells[6][SG-\>RowCount-1]=i-\>Get_Creator();
    if (i-\>Get_DateOfUpdate().Val!=0)
        {
        SG-\>Cells[7][SG-\>RowCount-1]=i-\>Get_DateOfUpdate().DateString();
        }else
        {
        SG-\>Cells[7][SG-\>RowCount-1]="";
        }
    SG-\>Cells[8][SG-\>RowCount-1]=i-\>Get_Updater();
      //    i-\>Get_Accept();
    SG-\>RowCount++;
    }
if (SG-\>RowCount\>2)
    {
    SG-\>RowCount--;
    }
AutoWidthSG(SG);
}
void             TFileDisigner::ClearData(void)
{
grid.clear();
SGClear(SG,0);
}
void __fastcall TFileDisigner::SGDrawCell(TObject *Sender, int ACol, int ARow, TRect &amp;Rect,
          TGridDrawState State)
{
TStringGrid *sg=(TStringGrid *)Sender;
if (ARow&amp;&amp;ACol&amp;&amp;grid.size())
    {
    if (grid[ARow-1].Get_Accept())
        {
        if (grid[ARow-1].Get_inbase())
            {
            sg-\>Canvas-\>Brush-\>Color=0x00DDFFFF; //clYellow разрешонный узел
            }else
            {
            sg-\>Canvas-\>Brush-\>Color=0x00DDFFDD;//clGreen; // разрешонный узел
            }
        }else
        {
        sg-\>Canvas-\>Brush-\>Color=0x00DDDDFF;// clRed нет доступа
        }
    sg-\>Canvas-\>Font-\>Color=clBlack;
if (ACol\>=sg-\>Selection.Left&amp;&amp;ACol\<=sg-\>Selection.Right&amp;&amp;ARow\>=sg-\>Selection.Top&amp;&amp;ARow\<=sg-\>Selection.Bottom)                                     //выделение
    {
    sg-\>Canvas-\>Brush-\>Color=0x00FFDDDD;//clBlue;
    sg-\>Canvas-\>Font-\>Color=clBlack;
    }
    sg-\>Canvas-\>FillRect(Rect);
    sg-\>Canvas-\>TextOutW(Rect.left+2,Rect.top+1,sg-\>Cells[ACol][ARow]);
    }
}

void __fastcall TFileDisigner::SGFixedCellClick(TObject *Sender, int ACol, int ARow)
{
switch (ACol)
    {
    case 1:{FileAsc=!FileAsc;        SortByFile(FileAsc);break;}
    case 2:{ObdAsc=!ObdAsc;          SortByObd(ObdAsc);break;}
    case 3:{InBaseAsc=!InBaseAsc;     SortByInBase(InBaseAsc);break;}
    case 4:{ActionAsc=!ActionAsc;     SortByAction(ActionAsc);break;}
    default:break;
    }
ShowData();
}
void            TFileDisigner::SortByObd    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Obd(true) \> grid.operator [](j+inc).Get_Obd(true)); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Obd(true) \< grid.operator [](j+inc).Get_Obd(true)); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
void            TFileDisigner::SortByFile    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_FileName() \> grid.operator [](j+inc).Get_FileName()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_FileName() \< grid.operator [](j+inc).Get_FileName()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
void            TFileDisigner::SortByInBase    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_inbase() \> grid.operator [](j+inc).Get_inbase()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_inbase() \< grid.operator [](j+inc).Get_inbase()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
void            TFileDisigner::SortByAction    (bool asc)
{
\long inc,i,j,seq[40],size=grid.size();
int s;
FRowData TmpRow(DB,LUser,"",0,base,type);
// вычисление последовательности приращений
s = increment(seq, size);
while (s \>= 0)
    {
    // сортировка вставками с инкрементами inc[]
    inc = seq[s--];
    for (i = inc; i \< size; i++)
        {
        if (asc)
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Action() \> grid.operator [](j+inc).Get_Action()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }else
            {
            for (j = i-inc; (j \>= 0) &amp;&amp; (grid.operator [](j).Get_Action() \< grid.operator [](j+inc).Get_Action()); j -= inc)
                {
                TmpRow=grid.operator [](j);
                grid.operator [](j)=grid.operator [](j+inc);
                grid.operator [](j+inc)=TmpRow;
                }
            }

        }
    }
}
int             TFileDisigner::increment    (long inc[], long size)
{
int p1, p2, p3, s;
p1 = p2 = p3 = 1;
s = -1;
do
    {
    if (++s % 2)
        {
        inc[s] = 8*p1 - 6*p2 + 1;
        } else
        {
        inc[s] = 9*p1 - 9*p3 + 1;
        p2 *= 2;
        p3 *= 2;
        }
    p1 *= 2;
    }
while(3*inc[s] \< size);
return s \> 0 ? --s : 0;
}

void __fastcall TFileDisigner::SGDblClick(TObject *Sender)
{
if (!grid.size()) {return;} //проверка заполненности массива
TStringGrid *sg=(TStringGrid *)Sender;
int ACol,ARow;
TPoint s;                  //вычисление кликнутой ячейки
GetCursorPos(&amp;s);
s=sg-\>ScreenToClient(s);
sg-\>MouseToCell(s.X,s.Y,ACol,ARow);
if (ARow\<=0) {return;}    //проверка клика
switch (ACol)
    {
    case 2:{SetNewObd(ACol,ARow);break;}
    case 4:{SetNewAction(ACol,ARow);break;}
    default:return;
    }
}
void            TFileDisigner::SetNewObd(int ACol,int ARow)
{
if (type) {return;}//отключение обоих функций для режима восстановления/удаления файлов
if (!grid[ARow-1].Get_Accept()&amp;&amp;grid[ARow-1].Get_inbase()) {return;}
TRect R=SG-\>CellRect(ACol,ARow);
// проверка на наличие мыши в зоне
R.Left=R.Left+SG-\>Left;
R.Right=R.Right+SG-\>Left;
R.Top=R.Top+SG-\>Top;
R.Bottom=R.Bottom+SG-\>Top;
ED-\>Left=R.Left+1;
ED-\>Top=R.Top+1;
ED-\>Width=(R.Right+1)-R.Left;
ED-\>Height=(R.Bottom+1)-R.Top;
ED-\>Visible=true;
ED-\>SetFocus();
}
void            TFileDisigner::SetNewAction(int ACol,int ARow)
{
if (!grid[ARow-1].Get_Accept()) {return;}
TRect R=SG-\>CellRect(ACol,ARow);
R.Left=R.Left+SG-\>Left;
R.Right=R.Right+SG-\>Left;
R.Top=R.Top+SG-\>Top;
R.Bottom=R.Bottom+SG-\>Top;
CB-\>Left=R.Left+1;
CB-\>Top=R.Top+1;
CB-\>Width=(R.Right+1)-R.Left;
CB-\>Height=(R.Bottom+1)-R.Top;
FillCombo(ARow-1);
CB-\>Visible=true;
CB-\>SetFocus();
}

void            TFileDisigner::FillCombo(int pos)
{
CB-\>Clear();
CB-\>Items-\>Add("Нет");
switch (type)
    {
    case 0:    {
            if (grid[pos].Get_inbase())
                {
                CB-\>Items-\>Add("Обновить");
                }else
                {
                CB-\>Items-\>Add("Добавить");
                }
            break;
            }
    case 1:    {
            if (grid[pos].Get_inbase())
                {
                CB-\>Items-\>Add("Получить");
                }
            break;
            }
    case 2:    {
            if (grid[pos].Get_inbase())
                {
                CB-\>Items-\>Add("Удалить");
                }
            break;
            }
    default:break;
    }
}
void __fastcall TFileDisigner::CBExit(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
cb-\>Clear();
cb-\>Text="";
cb-\>Hide();
}
void __fastcall TFileDisigner::CBChange(TObject *Sender)
{
TComboBox *cb=(TComboBox *)Sender;
int pos=SG-\>Selection.Top-1;
grid[pos].SetAction(CB-\>Text);
UpdRow(pos+1);
cb-\>Hide();
}

void __fastcall TFileDisigner::EDExit(TObject *Sender)
{
TEdit *ed=(TEdit *)Sender;
ed-\>Text="";
ed-\>Hide();
}
void __fastcall TFileDisigner::EDKeyPress(TObject *Sender, wchar_t &amp;Key)
{
TEdit *ed=(TEdit *)Sender;
if (Key==13)
    {
    int pos=SG-\>Selection.Top-1;
    grid[pos].UpdateVal(ed-\>Text);
    UpdRow(pos+1);
    ed-\>Hide();
    }
}

void            TFileDisigner::UpdRow(int ARow)
{
SG-\>Cells[1][ARow]=grid[ARow-1].Get_FileName();
SG-\>Cells[2][ARow]=grid[ARow-1].Get_Text();
if (grid[ARow-1].Get_inbase())
    {
    SG-\>Cells[3][ARow]="Есть в базе";
    }else
    {
    SG-\>Cells[3][ARow]="Нет в базе";
    }
SG-\>Cells[4][ARow]=grid[ARow-1].Get_Action();
if (grid[ARow-1].Get_DateOfCreate().Val!=0)
    {
    SG-\>Cells[5][ARow]=grid[ARow-1].Get_DateOfCreate().DateString();
    }else
    {
    SG-\>Cells[5][ARow]="";
    }
SG-\>Cells[6][ARow]=grid[ARow-1].Get_Creator();
if (grid[ARow-1].Get_DateOfUpdate().Val!=0)
    {
    SG-\>Cells[7][ARow]=grid[ARow-1].Get_DateOfUpdate().DateString();
    }else
    {
    SG-\>Cells[7][ARow]="";
    }
SG-\>Cells[8][ARow]=grid[ARow-1].Get_Updater();
}

void __fastcall TFileDisigner::SGKeyPress(TObject *Sender, wchar_t &amp;Key)
{
if (Key=13)
    {
    SGDblClick(Sender);
    }
}
//---------------------------------------------------------------------------

</code>

@@TSearch::MainTree
Description
Дерево для отображения результатов поиска

@@TSearch::SupportTree
Description
Дерево для отображения вспомогательной информации (узлы и
заказы в которые входит выбранный узел)

@@TFileDisigner::SGKeyPress@TObject *@wchar_t &
Description
Обработчик нажатия кнопки на сетке
C++ Syntax
<code lang="c++">
void __fastcall TFileDisigner::SGKeyPress(TObject *Sender, wchar_t &amp;Key)
{
if (Key==13)
    {
    SGDblClick(Sender);
    }
}
</code>

@@TSearch::M2
Description
Поле отображения текста запроса пользователя

@@TSearch::SearchParams
Description
Компонент управления параметрами поиска. (Направление поиска)

@@TSearch::RazdParams
Description
Графический компонент - контейнер для отображения тригеров
разрешающих отображение тех или иных разделов спецификации

@@TSearch::assemblies
Description
Триггер, разрешающий отображать сборки  в результатах поиска

@@TSearch::details
Description
Триггер, разрешающий отображать детали в результатах поиска

@@TSearch::products
Description
Триггер, разрешающий отображать изделия в результатах поиска.

@@TSearch::stdelements
Description
Триггер, разрешающий отображать стандартные элементы в
результатах поиска

@@TSearch::RG2
Description
Компонент для управления формированием запроса (управление
логикой и/или)

@@TSearch::StartSearch
Description
Кнопка начала поиска.

@@TSearch::Label3
Description
Надпись "Ищем"

@@TSearch::GroupBox1
Description
Контейнер с триггерами управления уровнями личного доступа в
результатах поиска

@@TSearch::CB1
Description
Триггер включения отображения только результатов, находящихся
в работе у пользователя.

@@TSearch::CB3
Description
Триггер включения отображения только результатов, доступных
пользователю

@@TSearch::E1
Description
Строка ввода запроса на поиск.

@@TSearch::AddCond
Description
Кнопка для добавления условия поиска в запрос.

@@TSearch::Panel1
Description
Панель с графическими компонентами для инициализации поиска
по базе.

@@TSearch::Panel2
Description
Панель с графическими компонентами для отображения
результатов поиска.

@@TSearch::Panel6
Description
Панель с графическими компонентами для управления
отображаемыми страницами

@@TSearch::Label1
Description
Текстовый графический компонент - текст"Результаты поиска"

@@TSearch::Panel7
Description
Прозрачный компонент для заполнения пустого пространства.

@@TSearch::Panel8
Description
Панель с инструментами для навигации по страницам поиска.

@@TSearch::GroupBox2
Description
Графический компонент -рамка для оформления функциональных
компонент. 

@@TSearch::E2
Description
Текстовый компонет для ввода номера просматриваемой страницы

@@TSearch::E3
Description
Текстовый компонет для утправления количеством отображаемый
строк на одном листе.

@@TSearch::next
Description
Кнопка переключения на следующую страницу результатов.

@@TSearch::prev
Description
Кнопка переключения на предыдущую страницу результатов.

@@TSearch::Panel3
Description
Панель с графическими компонентами для отображения узлов и
заказов в которые входит узел/деталь из результатов поиска.

@@TSearch::Label2
Description
Текстовый графический компонент - текст"Используется в:"

@@TSearch::Panel4
Description
Панель с графическими компонентами для управления
отображаемыми страницами

@@TSearch::Panel5
Description
Панель с инструментами для навигации по страницам поиска.

@@TSearch::GroupBox3
Description
Графический компонент -рамка для оформления функциональных
компонент.

@@TSearch::SE2
Description
Текстовый компонет для ввода номера просматриваемой страницы

@@TSearch::SE3
Description
Текстовый компонет для утправления количеством отображаемый
строк на одном листе.

@@TSearch::Sprev
Description
Кнопка переключения на предыдущую страницу результатов.

@@TSearch::Snext
Description
Кнопка переключения на следующую страницу результатов.

@@TSearch::OpenTree
Description
Указатель на функцию открытия выбранного элемента в дереве
спецификаций

@@TSearch::LastChild
Description
Указатель на объект данных последнего выбранного объекта.

@@TSearch::conditions
Description
Переменная содержащая условия для поиска по базе.

@@TSearch::Splitter1
Description
Сплиттер для управления размерами графических компонентов.

@@TSpTree::count
Description
Переменная, показывающая количество экземпляров класса.

@@TSpTree::DB
Description
Указатель на класс для работы с базой данных

@@TSpTree::Tree
Description
Дерево для отображения узлов и деталей.

@@TSpTree::Selector
Description
Компонент для выбора и ввода обозначений загружаемых узлов и
деталей.

@@TSpTree::Panel3
Description
Панель для размещения компонента для выбора/ввода загружаемой
детали/узла

@@TSpTree::PAB
Description
Контекстное меню.

@@TSpTree::memo
Description
Указатель на компонент для вывода детальной информации.

@@TSpTree::MassAction
Description
Индикатор массовых действий.

@@TSpTree::LUser
Description
Ссылка на идентификатор пользователя, вошедшего в программу.

@@TSpTree::IcoData
Description
Указатель на компонент для работы с иконками.

@@TSpTree::ImageList1
Description
Контейнер с иконками для оформления контекстного меню.

@@TSpTree::AddTexTab
Description
Указатель на функцию загрузки детали в новую вкладку для
редактирования технологии

@@TSpTree::AddTexViewTab
Указатель на функцию загрузки детали в новую вкладку для
просмотра технологии

@@TSpTree::LoadTexToCurrTab
Description
Указатель на функцию загрузки детали в существующую вкладку
для редактирования технологии.

@@TSpTree::LoadexViewToCurrTab
Description
Указатель на функцию загрузки детали в существующую вкладку
для просмотра технологии.

@@TSpTree::N1
Description
Компонент - комaнда контекстного меню "Просмотр (открыть в
новой вкладке)"

@@TSpTree::N10
Description
Компонент - комaнда контекстного меню "Над деталью"

@@TSpTree::N11
Description
Компонент - комaнда контекстного меню "Добавить/Заменить"

@@TSpTree::N12
Description
Компонент - комaнда контекстного меню "Удалить"

@@TSpTree::N13
Description
Компонент - комaнда контекстного меню "Спецификация"

@@TSpTree::N14
Description
Компонент - комaнда контекстного меню "Показать состав"

@@TSpTree::N15
Description
Компонент - комaнда контекстного меню "Добавить"

@@TSpTree::N16
Description
Компонент - комaнда контекстного меню "Редактировать"

@@TSpTree::N17
Description
Компонент - комaнда контекстного меню "Технология"

@@TSpTree::N18
Description
Компонент - комaнда контекстного меню "Просмотр"

@@TSpTree::N19
Description
Компонент - комaнда контекстного меню "Удалить"

@@TSpTree::N20
Description
Компонент - комaнда контекстного меню "Узел"

@@TSpTree::N21
Description
Компонент - комaнда контекстного меню "Раскрыть"

@@TSpTree::N22
Description
Компонент - комaнда контекстного меню "Свернуть"

@@TSpTree::N23
Description
Компонент - комaнда контекстного меню "Обновить"

@@TSpTree::N24
Description
Компонент - комaнда контекстного меню "Редактировать (открыть
в новой вкладке)"

@@TSpTree::N25
Description
Компонент - комaнда контекстного меню "Просмотр (открыть в
текущей вкладке)"

@@TSpTree::N26
Description
Компонент - комaнда контекстного меню "Изменить состояние"

@@TSpTree::N3
Description
Компонент - комaнда контекстного меню "Файл"

@@TSpTree::N31
Description
Компонент - комaнда контекстного меню "Редактировать (открыть
в текущей вкладке)"

@@TSpTree::N4
Description
Компонент - комaнда контекстного меню "Получить файл (файлы)"

@@TSpTree::N40
Description
Компонент - комaнда контекстного меню "Блокировка"

@@TSpTree::N41
Description
Компонент - комaнда контекстного меню "Заблокировать для
остальных"

@@TSpTree::N42
Description
Компонент - команда контекстного меню "Снять блокировку"

@@TSpTree::N5
Description
Компонент - команда контекстного меню "Удалить файл (файлы)"

@@TSpTree::N6
Description
Компонент - разделитель в контекстном меню

@@TSpTree::N7
Description
Компонент - разделитель в контекстном меню

@@TSpTree::N8
Description
Компонент - комaнда контекстного меню "Действия"

@@TSpTree::N9
Description
Компонент - комaнда контекстного меню "Над деталью и всем в
нее входящими"

@@TSearch::LUser
Description
Ссылка на идентификатор пользователя, вошедшего в программу.



@@TSearch::RepaintPannels@TObject *
Description
Обработчик команды перерисовки компонента
C++ Syntax
<code lang="c++">
void __fastcall TSearch::RepaintPannels(TObject *Sender)
{
TPanel * pn=(TPanel *)Sender;
pn-\>Repaint();
Label2-\>Repaint();
Label1-\>Repaint();
Splitter1-\>Width=5;
Panel3-\>Constraints-\>MaxWidth=this-\>Width-Panel2-\>Constraints-\>MinWidth-Splitter1-\>Width;
Panel2-\>Constraints-\>MaxWidth=this-\>Width-Panel3-\>Constraints-\>MinWidth-Splitter1-\>Width;
Panel2-\>Width=this-\>Width-Panel3-\>Width-Splitter1-\>Width;
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::TreeClear@TTreeView *
Description
Функция очистки дерева для отображения данных пользователю
C++ Syntax
<code lang="c++">
void TSearch::TreeClear(TTreeView *tv)
{
TTreeNode *node=tv-\>Items-\>GetFirstNode();
while (node!=0)
    {
    if ((int)node-\>Data)
        {
        delete ((Obd *)node-\>Data);
        }
    node=node-\>GetNext();
    }
tv-\>Items-\>Clear();
}
</code>
Type Parameters
tv :  Указатель на компонент \- дерево

@@TSearch::BranchClear@TTreeNode *
Description
Функция для очистки ветки дерева.
C++ Syntax
<code lang="c++">
void TSearch::BranchClear(TTreeNode *Node)
{
TTreeNode *node=Node-\>getFirstChild();
while (node)  //перебор детей
    {
    if (node-\>Count) //есть дети которых надо порезать
        {
        BranchClear(node);
        }
    if ((int)node-\>Data)
        {
        delete ((Obd *)node-\>Data);
        node-\>Data=0;
        }
    node=node-\>getNextSibling();
    }
Node-\>DeleteChildren();
}
</code>
Type Parameters
Node :  Указатель на узел\-вершину ветви

@@TSearch::ChgListClick@TObject *
Description
Обработчик нажатия кнопок навигации по страницы.
C++ Syntax
<code lang="c++">
void __fastcall TSearch::ChgListClick(TObject *Sender)
{
TSpeedButton *bt=(TSpeedButton *)Sender;
switch (bt-\>Tag)
    {
    case  1:{E2-\>Text=String(E2-\>Text.ToInt()+1);break;}
    case -1:{if (E2-\>Text.ToInt()\>1) {E2-\>Text=String(E2-\>Text.ToInt()-1);}break;}
    default:return;
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию.

@@TSearch::ChgSListClick@TObject *
Description
Обработчик нажатия кнопок навигации по страницы.
C++ Syntax
<code>
void __fastcall TSearch::ChgSListClick(TObject *Sender)
{
TSpeedButton *bt=(TSpeedButton *)Sender;
switch (bt-\>Tag)
    {
    case  1:{SE2-\>Text=String(SE2-\>Text.ToInt()+1);break;}
    case -1:{if (SE2-\>Text.ToInt()\>1) {SE2-\>Text=String(SE2-\>Text.ToInt()-1);}break;}
    default:return;
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию.

@@TSearch::E3Change@TObject *
Description
Обработчик события изменения количества строк на листе
C++ Syntax
<code lang="c++">
void __fastcall TSearch::E3Change(TObject *Sender)
{
if (E3-\>Text==""||E3-\>Text=="0")
    {
    E3-\>Text="1";
    }
if (E2-\>Text!="1") {E2-\>Text="1";} else {Find();}
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::SE3Change@TObject *
Description
Обработчик события изменения количества строк на листе
C++ Syntax
<code>
void __fastcall TSearch::SE3Change(TObject *Sender)
{
if (SE3-\>Text==""||SE3-\>Text=="0")
    {
    SE3-\>Text="1";
    }
if (SE2-\>Text!="1") {SE2-\>Text="1";} else {TreeClear(SupportTree);GetParents(LastChild,0);}
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::E2Change@TObject *
Description
Обработчик события изменения номера отображаемой страници
C++ Syntax
<code>
void __fastcall TSearch::E2Change(TObject *Sender)
{
if (E2-\>Text==""||E2-\>Text=="0")
    {
    E2-\>Text="1";
    }
Find();
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::SE2Change@TObject *
Description
Обработчик события изменения номера отображаемой страници
C++ Syntax
<code>
void __fastcall TSearch::SE2Change(TObject *Sender)
{
if (SE2-\>Text==""||SE2-\>Text=="0")
    {
    SE2-\>Text="1";
    }
TreeClear(SupportTree);
if (LastChild)
    {
    GetParents(LastChild,0);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::AddCondClick@TObject *
Description
Обработчик нажатия на кнопку AddCond - составляет текст для
сложных запросов
C++ Syntax
<code lang="c++">
void __fastcall TSearch::AddCondClick(TObject *Sender)
{
if (M2-\>Lines-\>Count!=0 &amp;&amp; Trim(M2-\>Lines-\>Strings[M2-\>Lines-\>Count-1])!="" &amp;&amp; Trim(M2-\>Lines-\>Strings[M2-\>Lines-\>Count-1])!="и" &amp;&amp; Trim(M2-\>Lines-\>Strings[M2-\>Lines-\>Count-1])!="или")
    {
    M2-\>Lines-\>Add(RG2-\>Items-\>Strings[RG2-\>ItemIndex]);
    }
String COLUMN;
switch (SearchParams-\>ItemIndex)
    {
    case 0: {COLUMN="Обозначение содержит";break;}
    case 1: {COLUMN="Наименование содержит";break;}
    case 2: {COLUMN="Заказ содержит";break;}
    case 3: {COLUMN="Код материала содержит";break;}
    default: break;
    }
if (Trim(E1-\>Text)!="") {M2-\>Lines-\>Add(COLUMN+" "+Trim(E1-\>Text));}
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::E1KeyPress@TObject *@wchar_t &
Description
Обработчик нажатия кнопки клавиатуры.
C++ Syntax
<code lang="c++">
void __fastcall TSearch::E1KeyPress(TObject *Sender, wchar_t &amp;Key)
{
if (Key==13)
    {
    StartSearchClick(StartSearch);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию
Key :     Код нажатой клавиши клавиатуры

@@TSearch::StartSearchClick@TObject *
Description
Обработчик нажатия кнопки "Отобрать"
C++ Syntax
<code lang="c++">
void __fastcall TSearch::StartSearchClick(TObject *Sender)
{
\conditions="";
String COLUMN="COLUMN",cond;
if (M2-\>Lines-\>Count)
    {
    if (conditions=="") {conditions="Where ";}
    int i=0;
    M2-\>WordWrap=false;
    for (i = 0; i \<M2-\>Lines-\>Count; i++)
        {
        if (Trim(M2-\>Lines-\>Strings[i])!="")
            {
            if (Trim(M2-\>Lines-\>Strings[i])=="и")
                {
                \conditions=conditions+" and ";
                }else
            if (Trim(M2-\>Lines-\>Strings[i])=="или")
                {
                \conditions=conditions+" or ";
                } else
                {
                cond=Trim(M2-\>Lines-\>Strings[i]);
                if (cond.Pos("Обозначение содержит"))
                    {
                    COLUMN="obd";
                    cond.Delete(cond.Pos("Обозначение содержит"),21);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+GostToInt(cond)+"%'";
                    }
                if (cond.Pos("Наименование содержит"))
                    {
                    COLUMN="namd";
                    cond.Delete(cond.Pos("Наименование содержит"),22);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+cond.Trim()+"%'";
                    }
                if (cond.Pos("Заказ содержит"))
                    {
                    COLUMN="zaka";
                    cond.Delete(cond.Pos("Заказ содержит"),15);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+cond.Trim()+"%'";
                    }
                if (cond.Pos("Изготавливается из"))
                    {
                    COLUMN="obmid";
                    cond.Delete(cond.Pos("Изготавливается из"),22);
                    \conditions=conditions+" "+COLUMN+" in (select id from constructions.det_names where obd like '%"+cond.Trim()+"%')";
                    }
                }
            }
        }
    M2-\>WordWrap=true;
    } else
    {
    String val="";
    if (E1-\>Text.Trim()!="")
        {
        switch (SearchParams-\>ItemIndex)
            {
            case 0: {
                    COLUMN="obd";val=GostToInt(E1-\>Text.Trim());
                    \conditions="Where "+COLUMN+" LIKE '%"+val+"%'";
                    break;}
            case 1: {
                    COLUMN="namd";val=E1-\>Text.Trim();
                    \conditions="Where "+COLUMN+" LIKE '%"+val+"%'";
                    break;}
            case 2: {
                    COLUMN="zaka";val=E1-\>Text.Trim();
                    \conditions="Where "+COLUMN+" LIKE '%"+val+"%'";
                    break;}
            case 3: {
                    COLUMN="obmid";val=E1-\>Text.Trim();
                    \conditions="Where "+COLUMN+" in (select id from constructions.det_names where obd like '%"+val+"%')";
                    break;}
            default: return;
            }
        }
    }
M2-\>Clear();
if (E2-\>Text=="1")
    {
    Find();
    }else
    {
    E2-\>Text="1";  //срабатывет onChange а ссылка который и вызывает Find
    }
//E1-\>Text="";
M2-\>Lines-\>Clear();
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::Find
Description
Функция финальной сборки запроса на поиск в базе по ранее
построенным параметрам запроса
C++ Syntax
<code lang="c++">
void             TSearch::Find    (void)
{
TreeClear(MainTree);
String condition=conditions;
String sql="select a.id,a.obd,a.namd,a.razdSPID,b.Razdname from constructions.det_names a  join administration.sprazd b on b.RazdID=a.razdSPID ";
if (condition.Pos(" zaka "))
    {
    //добавить вхождение в заказы
    sql+="right join market.zakaz c on c.id=a.id ";
    }
if (condition.Pos(" obmid "))
    {
    //добавить вхождение в технологии
    sql+="join technologic.det_info d on d.id=a.id " ;
    }
//разделы поиска
String razd=" razdSPID in(";
if (products-\>Checked)
    {
    razd+="'0',";
    }
if (assemblies-\>Checked)
    {
    razd+="'2','3','8',";
    }
if (details-\>Checked)
    {
    razd+="'4',";
    }
if (stdelements-\>Checked)
    {
    razd+="'5','6','7',";
    }
razd.Delete(razd.Length(),1);
razd+=")";
if (razd.Length()==13)
    {
    razd=" razdSPID in('999')";
    }
if (condition.Length())
    {
    condition="Where ("+condition.Delete(condition.Pos("Where"),5)+" ) and"+razd;
    }else
    {
    condition="Where "+razd;
    }
if (Combo-\>ItemIndex)
    {
    condition=condition+" and a.state="+(String)((int)Combo-\>Items-\>Objects[Combo-\>ItemIndex]);
    }
if (CB1-\>Checked)
    {
    if (!condition.Length())
        {
        condition="Where UserID='"+String(LUser)+"'";
        }else
        {
        condition="Where ("+condition.Delete(condition.Pos("Where"),5)+" ) and UserID='"+String(LUser)+"'";
        }
    }
if (CB3-\>Checked)
    {
    if (!condition.Length())
        {
        condition="Where state in ("+GetConditions(LUser)+")";
        } else
        {
        condition="Where ("+condition.Delete(condition.Pos("Where"),5)+" ) and state in ("+GetConditions(LUser)+")";
        }
    }
if (conditions.Length())
    {
    sql=sql+condition+" order by a.razdSPID,a.obd,a.namd  limit "+String(E2-\>Text.ToInt()*E3-\>Text.ToInt()-E3-\>Text.ToInt())+","+E3-\>Text;
    }else
    {
    sql=sql+condition+"  limit "+String(E2-\>Text.ToInt()*E3-\>Text.ToInt()-E3-\>Text.ToInt())+","+E3-\>Text;
    }
TreeClear(SupportTree);
FillTV(MainTree,0,sql);
}
</code>

@@TSearch::FillTV@TTreeView *@TTreeNode *@String@bool@bool
Description
Функция построения дерева результатов на основе запроса
C++ Syntax
<code lang="c++">
void TSearch::FillTV(TTreeView *tv,TTreeNode *StartNode,String sql,bool AsChild,bool CanChild)
{
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    //наполнение сетки
    String name,obd,razd_name;
    int id,razd;
    rez-\>First();
    Obd *data;
    TTreeNode *node=StartNode;
    while (!rez-\>Eof)
        {
        data=new Obd(DB);
        name=rez-\>FieldByName("namd")-\>Value;
        obd=rez-\>FieldByName("obd")-\>Value;
        id=rez-\>FieldByName("id")-\>Value;
        razd=rez-\>FieldByName("razdSPID")-\>Value;
        razd_name=rez-\>FieldByName("Razdname")-\>Value;
        if (data-\>SetData(id,razd,obd,name,razd_name))
            {
            if (node==StartNode&amp;&amp;AsChild)
                {
                node=tv-\>Items-\>AddChildObject(node,data-\>Get_Text(),(void *)data);
                }else
                {
                node=tv-\>Items-\>AddObject(node,data-\>Get_Text(),(void *)data);
                }
            if (CanChild)
                {
                tv-\>Items-\>AddChildObject(node,"",0);
                }
            node-\>ImageIndex=IcoData-\>GetInList(razd,true,1);
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=0;
            }else
            {
            delete data;
            }
        rez-\>Next();
        }
    }
delete rez;
}
</code>
Type Parameters
tv :         Дерево для отображения элементов.
StartNode :  Указатель на стартовый узел построения.
sql :        Заспрос для получения данных.
AsChild :    Индикатор добавления дочерних объектов к узлу
CanChild :   Индикатор создания пустого дочернего узла для
             возможности раскрытия

@@TSearch::refindClick@TObject *
Description
Обработчик нажатия на комбо боксы (обновление поиска при
изменении значений комбо боксов) и отрисовки картинки
выбранного состояния по которому идет поиск
C++ Syntax
<code lang="c++">
void __fastcall TSearch::refindClick(TObject *Sender)
{
if (Sender-\>ClassNameIs("TComboBox"))
    {
    TComboBox *cb=(TComboBox *)Sender;
    int id=(int)cb-\>Items-\>Objects[cb-\>ItemIndex];
    IMG-\>Picture-\>Bitmap=0;
    TImageList *ico=IcoData-\>GetStateList();
    ico-\>GetBitmap(IcoData-\>GetInList(id,true,0),IMG-\>Picture-\>Bitmap);
    }
if (E2-\>Text=="1")
    {
    Find();
    }else
    {
    E2-\>Text="1";
    }

}
</code>

@@TSearch::MainTreeClick@TObject *
Description
Обработчик клика на дереве отображения результатов поиска.
(поиск списка вхождения.)
C++ Syntax
<code lang="c++">
void __fastcall TSearch::MainTreeClick(TObject *Sender)
{
// найти вхождения
TTreeView *tv=(TTreeView *)Sender;
TPoint s;                  //вычисление кликнутой ячейки
GetCursorPos(&amp;s);
s=tv-\>ScreenToClient(s);
TTreeNode *node=tv-\>GetNodeAt(s.X,s.Y);
if (node&amp;&amp;node==tv-\>Selected)
    {
    LastChild=(Obd *)node-\>Data;
    TreeClear(SupportTree);
    GetParents(LastChild,0);
    }
TreeClick(Sender);
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::SupportTreeExpanding@TObject *@TTreeNode *@bool &
Description
Обработчик события раскрытия узла.
C++ Syntax
<code lang="c++">
void __fastcall TSearch::SupportTreeExpanding(TObject *Sender, TTreeNode *Node, bool &amp;AllowExpansion)
{
BranchClear(Node);
Obd *data=(Obd *)Node-\>Data;
GetParents(data,Node,true);
}
</code>
Type Parameters
Sender :          Указатель на объект, вызвавший функцию
Node :            Указатель на раскрываемый узел
AllowExpansion :  Разрешение на раскрытие

@@TSearch::MainTreeDblClick@TObject *
Description
Обработчик двойного щелчка в основном и вспомогательном
дереве
C++ Syntax
<code lang="c++">
void __fastcall TSearch::MainTreeDblClick(TObject *Sender)
{
// передать объект на спецификацию
TTreeView *tv=(TTreeView *)Sender;
TPoint s;                  //вычисление кликнутой ячейки
GetCursorPos(&amp;s);
s=tv-\>ScreenToClient(s);
TTreeNode *node=tv-\>GetNodeAt(s.X,s.Y);
if (node&amp;&amp;node==tv-\>Selected)
    {
    Obd *data=(Obd *)node-\>Data;
    if (data)
        {
        OpenTree(data);
        }
    }
//вызов обратной функции
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSearch::GetParents@Obd *@TTreeNode *@bool
Description
Функция получения вхождения для детали.
C++ Syntax
<code lang="c++">
void             TSearch::GetParents(Obd *data,TTreeNode *Node,bool AsChild)
{
if (data)
    {
    int id=data-\>Get_ID();
    String sql="call constructions.GetParents('"+String(id)+"','"+String(SE2-\>Text.ToInt()*SE3-\>Text.ToInt()-SE3-\>Text.ToInt())+"','"+SE3-\>Text+"')";
    FillTV(SupportTree,Node,sql,AsChild,true);
    sql="select a.zaka from market.zakaz a where a.id="+String(id)+" limit "+String(SE2-\>Text.ToInt()*SE3-\>Text.ToInt()-SE3-\>Text.ToInt())+","+SE3-\>Text;
    TADOQuery *rez=DB-\>SendSQL(sql);
    if (rez&amp;&amp;rez-\>RecordCount)
        {
        rez-\>First();
        TTreeNode *node=0;
        while (!rez-\>Eof)
            {
            if (AsChild)
                {
                node=SupportTree-\>Items-\>AddChildObject(Node,rez-\>FieldByName("zaka")-\>Value,0);
                }else
                {
                node=SupportTree-\>Items-\>AddObject(Node,rez-\>FieldByName("zaka")-\>Value,0);
                }
            node-\>ImageIndex=-1;
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=-1;
            rez-\>Next();
            }
        }
    delete rez;
    }
}
</code>
Type Parameters
data :     Указатель на объект данных детали
Node :     Указатель на узел для построения ветви
AsChild :  Индикатор на построение ветви как дочерней от узла

@@TSearch
Description
Модуль для поиска деталей/узлов по базе данных

@@SearchModule.cpp
Description
Модуль для поиска деталей/узлов по базе данных (файл
реализации)
C++ Syntax
<code lang="c++">
\#include \<vcl.h\>
\#pragma hdrstop

\#include "SearchModule.h"
//---------------------------------------------------------------------------
\#pragma package(smart_init)
\#pragma resource "*.dfm"

__fastcall TSearch::TSearch(TComponent* Owner,TWinControl *_p, int &amp;_LUser,cSQL *db,IconsData *_IcoData,void *_OpenTree)
    \: TFrame(Owner),LUser(_LUser)
{
if (count==0)
    {
    DB=db;
    IcoData=_IcoData;
    }
count++;
// расположение
Align=alClient;
Parent=_p;
Name=Name+String(count);
//деревья
MainTree-\>Images=IcoData-\>GetImgList();
MainTree-\>StateImages=IcoData-\>GetStateList();
SupportTree-\>Images=IcoData-\>GetImgList();
SupportTree-\>StateImages=IcoData-\>GetStateList();
//функция возврата
OpenTree=(void (*)(Obd *det))_OpenTree;
if (Parent-\>ClassNameIs("TTabSheet"))
    {
    ((TTabSheet*)Parent)-\>Caption="Поиск     ";
    }
}
__fastcall         TSearch::~TSearch(void)
{
count--;
if (count==0)
    {
    DB=0;
    IcoData=0;
    }
}
void __fastcall TSearch::RepaintPannels(TObject *Sender)
{
TPanel * pn=(TPanel *)Sender;
pn-\>Repaint();
Label2-\>Repaint();
Label1-\>Repaint();
Splitter1-\>Width=5;
Panel3-\>Constraints-\>MaxWidth=this-\>Width-Panel2-\>Constraints-\>MinWidth-Splitter1-\>Width;
Panel2-\>Constraints-\>MaxWidth=this-\>Width-Panel3-\>Constraints-\>MinWidth-Splitter1-\>Width;
Panel2-\>Width=this-\>Width-Panel3-\>Width-Splitter1-\>Width;
}
void              TSearch::TreeClear(TTreeView *tv)
{
TTreeNode *node=tv-\>Items-\>GetFirstNode();
while (node!=0)
    {
    if ((int)node-\>Data)
        {
        delete ((Obd *)node-\>Data);
        }
    node=node-\>GetNext();
    }
tv-\>Items-\>Clear();
}
void              TSearch::BranchClear(TTreeNode *Node)
{
TTreeNode *node=Node-\>getFirstChild();
while (node)  //перебор детей
    {
    if (node-\>Count) //есть дети которых надо порезать
        {
        BranchClear(node);
        }
    if ((int)node-\>Data)
        {
        delete ((Obd *)node-\>Data);
        node-\>Data=0;
        }
    node=node-\>getNextSibling();
    }
Node-\>DeleteChildren();
}

void __fastcall TSearch::ChgListClick(TObject *Sender)
{
TSpeedButton *bt=(TSpeedButton *)Sender;
switch (bt-\>Tag)
    {
    case  1:{E2-\>Text=String(E2-\>Text.ToInt()+1);break;}
    case -1:{if (E2-\>Text.ToInt()\>1) {E2-\>Text=String(E2-\>Text.ToInt()-1);}break;}
    default:return;
    }
}
void __fastcall TSearch::ChgSListClick(TObject *Sender)
{
TSpeedButton *bt=(TSpeedButton *)Sender;
switch (bt-\>Tag)
    {
    case  1:{SE2-\>Text=String(SE2-\>Text.ToInt()+1);break;}
    case -1:{if (SE2-\>Text.ToInt()\>1) {SE2-\>Text=String(SE2-\>Text.ToInt()-1);}break;}
    default:return;
    }
}
void __fastcall TSearch::E3Change(TObject *Sender)
{
if (E3-\>Text==""||E3-\>Text=="0")
    {
    E3-\>Text="1";
    }
if (E2-\>Text!="1") {E2-\>Text="1";} else {Find();}
}
void __fastcall TSearch::E2Change(TObject *Sender)
{
if (E2-\>Text==""||E2-\>Text=="0")
    {
    E2-\>Text="1";
    }
Find();
}
void __fastcall TSearch::SE3Change(TObject *Sender)
{
if (SE3-\>Text==""||SE3-\>Text=="0")
    {
    SE3-\>Text="1";
    }
if (SE2-\>Text!="1") {SE2-\>Text="1";} else {TreeClear(SupportTree);GetParents(LastChild,0);}
}
void __fastcall TSearch::SE2Change(TObject *Sender)
{
if (SE2-\>Text==""||SE2-\>Text=="0")
    {
    SE2-\>Text="1";
    }
TreeClear(SupportTree);
if (LastChild)
    {
    GetParents(LastChild,0);
    }
}

void __fastcall TSearch::AddCondClick(TObject *Sender)
{
if (M2-\>Lines-\>Count!=0 &amp;&amp; Trim(M2-\>Lines-\>Strings[M2-\>Lines-\>Count-1])!="" &amp;&amp; Trim(M2-\>Lines-\>Strings[M2-\>Lines-\>Count-1])!="и" &amp;&amp; Trim(M2-\>Lines-\>Strings[M2-\>Lines-\>Count-1])!="или")
    {
    M2-\>Lines-\>Add(RG2-\>Items-\>Strings[RG2-\>ItemIndex]);
    }
String COLUMN;
switch (SearchParams-\>ItemIndex)
    {
    case 0: {COLUMN="Обозначение содержит";break;}
    case 1: {COLUMN="Наименование содержит";break;}
    case 2: {COLUMN="Заказ содержит";break;}
    case 3: {COLUMN="Код материала содержит";break;}
    default: break;
    }
if (Trim(E1-\>Text)!="") {M2-\>Lines-\>Add(COLUMN+" "+Trim(E1-\>Text));}
}

void __fastcall TSearch::E1KeyPress(TObject *Sender, wchar_t &amp;Key)
{
if (Key==13)
    {
    StartSearchClick(StartSearch);
    }
}
void __fastcall TSearch::StartSearchClick(TObject *Sender)
{
E2-\>Text=1;
\conditions="";
String COLUMN="COLUMN",cond;
if (M2-\>Lines-\>Count)
    {
    if (conditions=="") {conditions="Where ";}
    int i=0;
    M2-\>WordWrap=false;
    for (i = 0; i \<M2-\>Lines-\>Count; i++)
        {
        if (Trim(M2-\>Lines-\>Strings[i])!="")
            {
            if (Trim(M2-\>Lines-\>Strings[i])=="и")
                {
                \conditions=conditions+" and ";
                }else
            if (Trim(M2-\>Lines-\>Strings[i])=="или")
                {
                \conditions=conditions+" or ";
                } else
                {
                cond=Trim(M2-\>Lines-\>Strings[i]);
                if (cond.Pos("Обозначение содержит"))
                    {
                    COLUMN="obd";
                    cond.Delete(cond.Pos("Обозначение содержит"),21);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+GostToInt(cond)+"%'";
                    }
                if (cond.Pos("Наименование содержит"))
                    {
                    COLUMN="namd";
                    cond.Delete(cond.Pos("Наименование содержит"),22);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+cond.Trim()+"%'";
                    }
                if (cond.Pos("Заказ содержит"))
                    {
                    COLUMN="zaka";
                    cond.Delete(cond.Pos("Заказ содержит"),15);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+cond.Trim()+"%'";
                    }
                if (cond.Pos("Код материала содержит"))
                    {
                    COLUMN="obm";
                    cond.Delete(cond.Pos("Код материала содержит"),22);
                    \conditions=conditions+" "+COLUMN+" LIKE '%"+cond.Trim()+"%'";
                    }
                }
            }
        }
    M2-\>WordWrap=true;
    } else
    {
    String val="";
    if (E1-\>Text.Trim()!="")
        {
        switch (SearchParams-\>ItemIndex)
            {
            case 0: {COLUMN="obd";val=GostToInt(E1-\>Text.Trim());break;}
            case 1: {COLUMN="namd";val=E1-\>Text.Trim();break;}
            case 2: {COLUMN="zaka";val=E1-\>Text.Trim();break;}
            case 3: {COLUMN="obm";val=E1-\>Text.Trim();break;}
            default: return;
            }
        \conditions="Where "+COLUMN+" LIKE '%"+val+"%'";
        }
    }
if (CB1-\>Checked)
    {
    if (conditions=="")
        {
        \conditions="Where UserID='"+String(LUser)+"'";
        }else
        {
        \conditions="Where ("+conditions.Delete(conditions.Pos("Where"),5)+" ) and UserID='"+String(LUser)+"'";
        }
    }
if (CB3-\>Checked)
    {
    if (conditions=="")
        {
        \conditions="Where state in ("+GetCongitions(LUser)+")";
        } else
        {
        \conditions="Where ("+conditions.Delete(conditions.Pos("Where"),5)+" ) and state in ("+GetCongitions(LUser)+")";
        }
    }
M2-\>Clear();
Find();
E1-\>Text="";
M2-\>Lines-\>Clear();
}
String          TSearch::GetCongitions(int User_ID)
{
String result="'0',";
String sql="select a.idCond from gtucond a inner join conditions b on b.idsost=a.idCond inner join logins c on c.Levelacss=a.IdGroup where c.LogID='"+String(User_ID)+"' and b.arhive=0";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    while (!rez-\>Eof)
        {
        \result=result+"'"+rez-\>FieldByName("idcond")-\>Value+"',";
        rez-\>Next();
        }
    }
delete rez; rez=0;
\result.Delete(result.Length(),1);
return result;
}
void             TSearch::Find    (void)
{
TreeClear(MainTree);
String condition=conditions;
String sql="select a.id,a.obd,a.namd,a.razdSPID,b.Razdname from det_names a left join sprazd b on b.RazdID=a.razdSPID ";
if (condition.Pos(" zaka "))
    {
    //добавить вхождение в заказы
    sql+="right join zakaz c on c.id=a.id ";
    }
if (condition.Pos(" obm "))
    {
    //добавить вхождение в технологии
    sql+="left join det_info d on d.id=a.id" ;
    }
//разделы поиска
String razd=" razdSPID in(";
if (products-\>Checked)
    {
    razd+="'0',";
    }
if (assemblies-\>Checked)
    {
    razd+="'2','3','8',";
    }
if (details-\>Checked)
    {
    razd+="'4',";
    }
if (stdelements-\>Checked)
    {
    razd+="'5','6','7',";
    }
razd.Delete(razd.Length(),1);
razd+=")";
if (razd.Length()==13)
    {
    razd=" razdSPID in('999')";
    }
if (condition.Length())
    {
    condition="Where ("+condition.Delete(condition.Pos("Where"),5)+" ) and"+razd;
    }else
    {
    condition="Where "+razd;
    }

sql=sql+condition+" order by a.razdSPID,a.obd,a.namd limit "+String(E2-\>Text.ToInt()*E3-\>Text.ToInt()-E3-\>Text.ToInt())+","+E3-\>Text;
FillTV(MainTree,0,sql);
}
void             TSearch::FillTV(TTreeView *tv,TTreeNode *StartNode,String sql,bool AsChild,bool CanChild)
{
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    //наполнение сетки
    String name,obd,razd_name;
    int id,razd;
    rez-\>First();
    Obd *data;
    TTreeNode *node=StartNode;
    while (!rez-\>Eof)
        {
        data=new Obd(DB);
        name=rez-\>FieldByName("namd")-\>Value;
        obd=rez-\>FieldByName("obd")-\>Value;
        id=rez-\>FieldByName("id")-\>Value;
        razd=rez-\>FieldByName("razdSPID")-\>Value;
        razd_name=rez-\>FieldByName("Razdname")-\>Value;
        if (data-\>SetData(id,razd,obd,name,razd_name))
            {
            if (node==StartNode&amp;&amp;AsChild)
                {
                node=tv-\>Items-\>AddChildObject(node,data-\>Get_Text(),(void *)data);
                }else
                {
                node=tv-\>Items-\>AddObject(node,data-\>Get_Text(),(void *)data);
                }
            if (CanChild)
                {
                tv-\>Items-\>AddChildObject(node,"",0);
                }
            node-\>ImageIndex=IcoData-\>GetInList(razd,true,1);
            node-\>SelectedIndex=node-\>ImageIndex;
            node-\>ExpandedImageIndex=node-\>ImageIndex;
            node-\>StateIndex=0;
            }else
            {
            delete data;
            }
        rez-\>Next();
        }
    }
delete rez;
}
void __fastcall TSearch::refindClick(TObject *Sender)
{
Find();
}

void __fastcall TSearch::MainTreeClick(TObject *Sender)
{
// найти вхождения
TTreeView *tv=(TTreeView *)Sender;
TPoint s;                  //вычисление кликнутой ячейки
GetCursorPos(&amp;s);
s=tv-\>ScreenToClient(s);
TTreeNode *node=tv-\>GetNodeAt(s.X,s.Y);
if (node&amp;&amp;node==tv-\>Selected)
    {
    LastChild=(Obd *)node-\>Data;
    TreeClear(SupportTree);
    GetParents(LastChild,0);
    }
}
void __fastcall TSearch::SupportTreeExpanding(TObject *Sender, TTreeNode *Node, bool &amp;AllowExpansion)
{
BranchClear(Node);
Obd *data=(Obd *)Node-\>Data;
GetParents(data,Node,true);
}
void             TSearch::GetParents(Obd *data,TTreeNode *Node,bool AsChild)
{
int id=data-\>Get_ID();
String sql="select a.id,a.obd,a.namd,a.razdSPID,c.Razdname from det_names a inner join det_tree b on b.idparent=a.id left join sprazd c on c.RazdID=a.razdSPID WHERE b.idchild="+String(id)+" limit "+String(SE2-\>Text.ToInt()*SE3-\>Text.ToInt()-SE3-\>Text.ToInt())+","+SE3-\>Text;
FillTV(SupportTree,Node,sql,AsChild,true);
sql="select a.zaka from zakaz a where a.id="+String(id)+" limit "+String(SE2-\>Text.ToInt()*SE3-\>Text.ToInt()-SE3-\>Text.ToInt())+","+SE3-\>Text;
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    TTreeNode *node=0;
    while (!rez-\>Eof)
        {
        if (AsChild)
            {
            node=SupportTree-\>Items-\>AddChildObject(Node,rez-\>FieldByName("zaka")-\>Value,0);
            }else
            {
            node=SupportTree-\>Items-\>AddObject(Node,rez-\>FieldByName("zaka")-\>Value,0);
            }
        node-\>ImageIndex=-1;
        node-\>SelectedIndex=node-\>ImageIndex;
        node-\>ExpandedImageIndex=node-\>ImageIndex;
        node-\>StateIndex=-1;
        rez-\>Next();
        }
    }
delete rez;
}
void __fastcall TSearch::MainTreeDblClick(TObject *Sender)
{
// передать объект на спецификацию
TTreeView *tv=(TTreeView *)Sender;
TPoint s;                  //вычисление кликнутой ячейки
GetCursorPos(&amp;s);
s=tv-\>ScreenToClient(s);
TTreeNode *node=tv-\>GetNodeAt(s.X,s.Y);
if (node&amp;&amp;node==tv-\>Selected)
    {
    Obd *data=(Obd *)node-\>Data;
    if (data)
        {
        OpenTree(data);
        }
    }
//вызов обратной функции
}

</code>

@@SearchModule.h
Description
Модуль для поиска деталей/узлов по базе данных (Файл
описания)
C++ Syntax
<code lang="c++">
\#ifndef SearchModuleH
\#define SearchModuleH
//---------------------------------------------------------------------------
\#include "Obd.h"
\#include "IconsData.h"

\#include \<Buttons.hpp\>
\#include \<Classes.hpp\>
\#include \<ComCtrls.hpp\>
\#include \<Controls.hpp\>
\#include \<ExtCtrls.hpp\>
\#include \<StdCtrls.hpp\>


class TSearch : public TFrame
{
__published:
    TPanel *Panel1;
    TTreeView *SupportTree;
    TTreeView *MainTree;
    TSplitter *Splitter1;
    TGroupBox *RazdParams;
    TCheckBox *products;
    TCheckBox *assemblies;
    TCheckBox *details;
    TCheckBox *stdelements;
    TPanel *Panel2;
    TPanel *Panel3;
    TLabel *Label1;
    TLabel *Label2;
    TRadioGroup *SearchParams;
    TPanel *Panel4;
    TLabel *Label3;
    TEdit *E1;
    TRadioGroup *RG2;
    TMemo *M2;
    TButton *AddCond;
    TButton *StartSearch;
    TLabeledEdit *E3;
    TSpeedButton *next;
    TSpeedButton *prev;
    TCheckBox *CB3;
    TCheckBox *CB1;
    TGroupBox *GroupBox1;
    TLabeledEdit *E2;
    TGroupBox *GroupBox2;
    TPanel *Panel6;
    TPanel *Panel7;
    TGroupBox *GroupBox3;
    TSpeedButton *Snext;
    TSpeedButton *Sprev;
    TLabeledEdit *SE2;
    TLabeledEdit *SE3;
    TPanel *Panel5;
    TPanel *Panel8;

    void __fastcall RepaintPannels(TObject *Sender);

    void __fastcall ChgListClick(TObject *Sender);
    void __fastcall ChgSListClick(TObject *Sender);
    void __fastcall E3Change(TObject *Sender);
    void __fastcall E2Change(TObject *Sender);
    void __fastcall SE3Change(TObject *Sender);
    void __fastcall SE2Change(TObject *Sender);

    void __fastcall AddCondClick(TObject *Sender);
    void __fastcall E1KeyPress(TObject *Sender, wchar_t &amp;Key);
    void __fastcall StartSearchClick(TObject *Sender);
    void __fastcall refindClick(TObject *Sender);

    void __fastcall MainTreeClick(TObject *Sender);
    void __fastcall MainTreeDblClick(TObject *Sender);
    void __fastcall SupportTreeExpanding(TObject *Sender, TTreeNode *Node, bool &amp;AllowExpansion);

private:
    String conditions;
    Obd *LastChild;

    void              TreeClear(TTreeView *tv);
    void              BranchClear(TTreeNode *Node);
    String          GetCongitions(int User_ID);
    void             Find(void);
    void             FillTV(TTreeView *tv,TTreeNode *StartNode,String sql,bool AsChild=false,bool CanChild=false);
    void             GetParents(Obd *data,TTreeNode *Node,bool AsChild=false);

    const int &amp;LUser;
    static IconsData *IcoData;
    static int count;
    static cSQL *DB;

    void (*OpenTree)(Obd *det);
public:
    __fastcall TSearch(TComponent* Owner,TWinControl *_p, int &amp;_LUser,cSQL *db,IconsData *_IcoData,void *_OpenTree);
    __fastcall TSearch::~TSearch(void);
};
int TSearch::count=0;
IconsData *TSearch::IcoData=0;
cSQL *TSearch::DB=0;
\#endif

</code>

@@TreeTab::module
Description
Указатель на прикрепленный объект класса TSpTree

@@TechViewTab::module
Description
Указатель на прикрепленный объект класса TTechView

@@TechTab::module
Description
Указатель на прикрепленный объект класса TTechWnd

@@SearchTab::module
Description
Указатель на прикрепленный объект класса TSearch

@@Tab::last_tab
Description
Индикатор последней используемой вкладки.

@@Tab::tab
Description
Указатель на объект вкладки.

@@SearchTab::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code>
bool ItTrueClassName (void)const
{
return TrueClassName()=="SearchTab"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@SearchTab::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code>
String TrueClassName (void)const{return "SearchTab";};
</code>

@@Tab::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code>
bool ItTrueClassName (void)const
{
return TrueClassName()=="Tab"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@Tab::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code>
String TrueClassName (void)const{return "Tab";};
</code>

@@TechTab::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code>
bool ItTrueClassName (void)const
{
return TrueClassName()=="TechTab"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@TechTab::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code>
String TrueClassName (void)const{return "TechTab";};
</code>

@@TechViewTab::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code>
bool ItTrueClassName (void)const
{
return TrueClassName()=="TechViewTab"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@TechViewTab::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code>
String TrueClassName (void)const{return "TechViewTab";};
</code>

@@TreeTab::ItTrueClassName@const
Description
Функция, проверяющая принадлежность указателя созданному
изначально классу
C++ Syntax
<code>
bool ItTrueClassName (void)const
{
return TrueClassName()=="TreeTab"?true:false;
}
</code>
Return Value List
True :   Указатель того же типа что и экземпляр класса
False :  Тип указателя отличается от созданного класса

@@TreeTab::TrueClassName@const
Description
Виртуальная функция, возвращающая настоящий тип класса
C++ Syntax
<code>
String TrueClassName (void)const{return "TreeTab";};
</code>

@@SearchTab::SearchTab
Description
Конструктор
C++ Syntax
<code lang="c++">
        SearchTab::SearchTab    (void):Tab(),module(0)
{}
</code>

@@SearchTab::SearchTab@SearchTab &
Description
Конструктор копировщик
C++ Syntax
<code lang="c++">
        SearchTab::SearchTab    (const SearchTab &amp;r):Tab(r)
{
module=r.module;
}
</code>

@@SearchTab::~SearchTab
Description
Деструктор
C++ Syntax
<code lang="c++">
        SearchTab::~SearchTab    (void)
{
if (module)
    {
    module-\>Parent=0;
    delete module;
    }
}
</code>

@@SearchTab
Description
Класс - контейнер для связывания вкладки с компонентом
поиска.

@@Tab::Tab
Description
Конструктор.
C++ Syntax
<code lang="c++">
        Tab::Tab    (void)
{
tab=0;
last_tab=false;
}
</code>

@@Tab::Tab@Tab &
Description
Конструктор копировщик.
C++ Syntax
<code lang="c++">
        Tab::Tab    (const Tab &amp;r)
{
tab=r.tab;
last_tab=r.last_tab;
}
</code>

@@Tab::~Tab
Description
Деструктор.
C++ Syntax
<code lang="c++">
        Tab::~Tab    (void)
{
if (tab)
    {
    tab-\>Tag=-1;
    delete tab;
    }
}
</code>

@@Tab
Description
Базовый класс для классов контейнеров -связок вкладок с
модулями.

@@TechTab::TechTab
Description
Конструктор.
C++ Syntax
<code lang="c++">
        TechTab::TechTab    (void):Tab(),module(0)
{
}
</code>

@@TechTab::TechTab@TechTab &
Description
Конструктор копировщик
C++ Syntax
<code lang="c++">
        TechTab::TechTab    (const TechTab &amp;r):Tab(r)
{
module=r.module;
}
</code>

@@TechTab::~TechTab
Description
Деструктор.
C++ Syntax
<code lang="c++">
        TechTab::~TechTab    (void)
{
if (module)
    {
    module-\>Parent=0;
    delete module;
    }
}
</code>

@@TechTab
Description
Класс - контейнер для связывания вкладки с компонентом
редактирования технологии.

@@TechViewTab::TechViewTab
Description
Конструктор.
C++ Syntax
<code lang="c++">
        TechViewTab::TechViewTab    (void):Tab(),module(0)
{}
</code>

@@TechViewTab::TechViewTab@TechViewTab &
Description
Конструктор копировщик.
C++ Syntax
<code lang="c++">
        TechViewTab::TechViewTab    (const TechViewTab &amp;r):Tab(r)
{
module=r.module;
}
</code>

@@TechViewTab::~TechViewTab
Description
Деструктор.
C++ Syntax
<code lang="c++">
        TechViewTab::~TechViewTab    (void)
{
if (module)
    {
    module-\>Parent=0;
    delete module;
    }
}
</code>

@@TechViewTab
Description
Класс - контейнер для связывания вкладки с компонентом
просмотра технологии.

@@TreeTab::TreeTab
Description
Конструктор.
C++ Syntax
<code lang="c++">
        TreeTab::TreeTab    (void):Tab(),module(0)
{
}
</code>

@@TreeTab::TreeTab@TreeTab &
Description
Конструктор копировщик.
C++ Syntax
<code lang="c++">
        TreeTab::TreeTab    (const TreeTab &amp;r):Tab(r)
{
module=r.module;
}
</code>

@@TreeTab::~TreeTab
Description
Деструктор.
C++ Syntax
<code lang="c++">
        TreeTab::~TreeTab    (void)
{
if (module)
    {
    module-\>Parent=0;
    delete module;
    }
}
</code>

@@TreeTab
Description
Класс - контейнер для связывания вкладки с компонентом
отображения дерева спецификации.

@@Tabs.cpp
Description
Классы контейнеры-связки для привязки вкладок к загружаемым
модулям. (файл реализиции)
C++ Syntax
<code lang="c++">
\#pragma hdrstop

\#include "Tabs.h"
\#pragma package(smart_init)

        Tab::Tab    (void)
{
tab=0;
last_tab=false;
}
        Tab::Tab    (const Tab &amp;r)
{
tab=r.tab;
last_tab=r.last_tab;
}
        Tab::~Tab    (void)
{
if (tab)
    {
    delete tab;
    }
}

        TreeTab::TreeTab    (void):Tab(),module(0)
{
}
        TreeTab::TreeTab    (const TreeTab &amp;r):Tab(r)
{
module=r.module;
}
        TreeTab::~TreeTab    (void)
{
if (module)
    {
    delete module;
    }
}

        TechTab::TechTab    (void):Tab(),module(0)
{
}
        TechTab::TechTab    (const TechTab &amp;r):Tab(r)
{
module=r.module;
}
        TechTab::~TechTab    (void)
{
if (module)
    {
    delete module;
    }
}

        TechViewTab::TechViewTab    (void):Tab(),module(0)
{}
        TechViewTab::TechViewTab    (const TechViewTab &amp;r):Tab(r)
{
module=r.module;
}
        TechViewTab::~TechViewTab    (void)
{
if (module)
    {
    delete module;
    }
}

        SearchTab::SearchTab    (void):Tab(),module(0)
{}
        SearchTab::SearchTab    (const SearchTab &amp;r):Tab(r)
{
module=r.module;
}
        SearchTab::~SearchTab    (void)
{
if (module)
    {
    delete module;
    }
}
</code>

@@Tabs.h
Description
Классы контейнеры-связки для привязки вкладок к загружаемым
модулям. (файл Описания)
C++ Syntax
<code lang="c++">
\#ifndef TabsH
\#define TabsH

\#include "BomTree.h"
\#include "technology.h"
\#include "TechnologyView.h"
\#include "SearchModule.h"

class Tab
    {
    public:
    Tab(void);
    Tab(const Tab &amp;);
    virtual ~Tab(void);
    virtual String TrueClassName (void)const{return "Tab";};
    bool ItTrueClassName (void)const{return TrueClassName()=="Tab"?true:false;}

    TTabSheet     *tab;
    bool         last_tab;
    };
class TreeTab:public Tab
    {
    public:
    TreeTab(void);
    TreeTab(const TreeTab &amp;);
    ~TreeTab(void);
    String TrueClassName (void)const{return "TreeTab";};
    bool ItTrueClassName (void)const{return TrueClassName()=="TreeTab"?true:false;}

    TSpTree        *module;
    };
class TechTab:public Tab
    {
    public:
    TechTab(void);
    TechTab(const TechTab &amp;);
    ~TechTab(void);
    String TrueClassName (void)const{return "TechTab";};
    bool ItTrueClassName (void)const{return TrueClassName()=="TechTab"?true:false;}

    TTechWnd    *module;
    };
class TechViewTab:public Tab
    {
    public:
    TechViewTab(void);
    TechViewTab(const TechViewTab &amp;);
    ~TechViewTab(void);
    String TrueClassName (void)const{return "TechViewTab";};
    bool ItTrueClassName (void)const{return TrueClassName()=="TechViewTab"?true:false;}

    TTechView   *module;
    };
class SearchTab:public Tab
    {
    public:
    SearchTab(void);
    SearchTab(const SearchTab &amp;);
    ~SearchTab(void);
    String TrueClassName (void)const{return "SearchTab";};
    bool ItTrueClassName (void)const{return TrueClassName()=="SearchTab"?true:false;}

    TSearch   *module;
    };
\#endif
</code>

@@TmForm::TmForm@TComponent*
Description
Конструктор. НЕДОПИСАН.
C++ Syntax
<code lang="c++">
__fastcall TmForm::TmForm(TComponent* Owner)
    \: TForm(Owner),UserID(0)
{
DB= new cSQL(ADC);
TLogIn *wnd=new TLogIn(this,DB);
wnd-\>ShowModal();
selected=0;
if (wnd-\>ModalResult==mrOk)
    {
    Tabs.clear();
    IcoData=new IconsData(this);
    LoadIL();
    UserID=wnd-\>Get_UserID();
    Obd *d;
        d=new Obd(DB,"971171000000000");
        if (d-\>CanUse())
            {
            AddTree(LeftPC,d,Info);
            }else
            {
            delete d;
            }
    }else
    {
    Application-\>Terminate();
    }
}
</code>

@@TmForm::LoadIL
Description
Функция считывания изображений из базы данных.
C++ Syntax
<code lang="c++">
void              TmForm::LoadIL   (void)
{
TImageList *il=IcoData-\>GetImgList();
TImageList *st=IcoData-\>GetStateList();
//обьявить переменные для считывания
TMemoryStream *str= new TMemoryStream();
Graphics::TBitmap *bmp= new Graphics::TBitmap();
        //считывание состояний
TADOQuery *rez=DB-\>SendSQL("Select `idsost`,`imgt`,`imgf` from administration.conditions");
if (rez)
    {
    rez-\>First();
    while (!rez-\>Eof)
        {
      //считать в поток блоб поле
        str=(TMemoryStream*)rez-\>CreateBlobStream(rez-\>FieldByName("imgt"),bmRead);
        str-\>Position=0;
        bmp-\>LoadFromStream(str);
        if (!st-\>Count)
            {
            st-\>Add(bmp,0); // забивка нулевой позиции в целом юзлесс нужно т.к нумерация начинается с 1 а не с 0
            }
        IcoData-\>LoadCollation(rez-\>FieldByName("idsost")-\>Value,st-\>Add(bmp,0),true,0);   // добавить запись в массив сопоставления
        IcoData-\>LoadCollation(rez-\>FieldByName("idsost")-\>Value,il-\>Add(bmp,0),true,3);   // добавить запись в массив сопоставления
        str=(TMemoryStream*)rez-\>CreateBlobStream(rez-\>FieldByName("imgf"),bmRead);
        str-\>Position=0;
        bmp-\>LoadFromStream(str);
        //il-\>Add(bmp,0);   //возвращает позицию?                                           //тип 0 состояния
        IcoData-\>LoadCollation(rez-\>FieldByName("idsost")-\>Value,st-\>Add(bmp,0),false,0);   // добавить запись в массив сопоставления
        IcoData-\>LoadCollation(rez-\>FieldByName("idsost")-\>Value,il-\>Add(bmp,0),false,3);   // добавить запись в массив сопоставления
        rez-\>Next();
        }
    }
delete rez;
     //считывание иконок файлов
rez=DB-\>SendSQL("Select `id`,`Ico` from administration.files_and_types");
if (rez)
    {
    rez-\>First();
    while (!rez-\>Eof)
        {
        //считать в поток блоб поле
        str=(TMemoryStream*)rez-\>CreateBlobStream(rez-\>FieldByName("Ico"),bmRead);
        str-\>Position=0;
        bmp-\>LoadFromStream(str);
        //il-\>Add(bmp,0);   возвращает позицию?                                            //тип 2 иконки файлов
        IcoData-\>LoadCollation(rez-\>FieldByName("id")-\>Value,il-\>Add(bmp,0),true,2);   // добавить запись в массив сопоставления
        rez-\>Next();
        }
    }
delete rez;
     //считывание разделов разделов спецификации
rez=DB-\>SendSQL("Select `RazdID`,`Icon` from administration.sprazd");
if (rez)
    {
    rez-\>First();
    while (!rez-\>Eof)
        {
        //считать в поток блоб поле
        str=(TMemoryStream*)rez-\>CreateBlobStream(rez-\>FieldByName("Icon"),bmRead);
        str-\>Position=0;
        bmp-\>LoadFromStream(str);
        //il-\>Add(bmp,0);   возвращает позицию?                                            //тип 1 иконки
        IcoData-\>LoadCollation(rez-\>FieldByName("RazdID")-\>Value,il-\>Add(bmp,0),true,1);   // добавить запись в массив сопоставления
        rez-\>Next();
        }
    }
delete str;
delete bmp;
delete rez;
}
</code>

@@TmForm::PCMouseDown@TObject *@TMouseButton@TShiftState@int@int
Description
Функция обработки нажатия мыши на TPageControl (на левом и
правом)
C++ Syntax
<code lang="c++">
void __fastcall TmForm::PCMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y)
{       // нажатие кнопки
TPageControl *PC=(TPageControl *)Sender;
DrawCloseTabBtn(PC,0,X,Y,-1,1);
TRect r;
r=PC-\>TabRect(PC-\>IndexOfTabAt(X,Y));
if (Button==mbLeft&amp;&amp;X\<r.Right-btns-\>Width-4)
    {
    if (PC-\>Tag!=1)
        {
        PC-\>BeginDrag(false);
        PC-\>Tag=1;
        }
    }
}
</code>
Note
Функция осуществляет отрисовку кнопки закрытия вкладки и
управляет режимом перетаскивания вкладок.
Type Parameters
Sender :  Указатель на объект, вызвавший функцию
Button :  Идентификатор нажатой кнопки.
Shift :   Состояние кнопок crtl, alt, shift
X :       Позиция курсора по оси X
Y :       Позиция курсора по оси Y

@@TmForm::PCMouseUp@TObject *@TMouseButton@TShiftState@int@int
Description
Функция обработки отпускания клавиши мыши на TPageControl (на
левом и правом)
C++ Syntax
<code>
void __fastcall TmForm::PCMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y)
{
//страбатывание кнопки
TPageControl *PC=(TPageControl *)Sender;
TRect btn=DrawCloseTabBtn(PC,0,X,Y,-1,0);
if (X\>=btn.Left&amp;&amp;X\<=btn.Right&amp;&amp;Y\>=btn.Top&amp;&amp;Y\<=btn.Bottom)  //проверить диапазон кнопки
    {
    TTabSheet *t=PC-\>Pages[PC-\>IndexOfTabAt(X,Y)];
    CloseTab(t);
    }
if (PC-\>Tag==1)
    {
    PC-\>EndDrag(false);
    PC-\>Tag=0;
    }
}
</code>
Note
Функция осуществляет отрисовку кнопки закрытия вкладки и
управляет режимом перетаскивания вкладок.
Type Parameters
Sender :  Указатель на объект, вызвавший функцию
Button :  Идентификатор нажатой кнопки.
Shift :   Состояние кнопок crtl, alt, shift
X :       Позиция указателя мыши по оси X
Y :       Позиция указателя мыши по оси Y

@@TmForm::PCDrawTab@TCustomTabControl *@int@TRect &@bool
Description
Функция отрисовки закладки вкладки. Прорисовка кнопки
закрытия вкладки.
C++ Syntax
<code lang="c++">
void __fastcall TmForm::PCDrawTab(TCustomTabControl *Control, int TabIndex, const TRect &amp;Rect,
          bool Active)
{
TPageControl *PC=(TPageControl *)Control;
//размеры и рисовка табы
/*PC-\>TabWidth=
PC-\>TabHeight=   */
TPoint txt;
if (PC-\>Pages[TabIndex]-\>ImageIndex\>=0)
    {
    txt.X=Rect.Left+Img-\>Width+4;
    txt.Y=Rect.Top+2;
    }else
    {
    if (PC-\>Pages[TabIndex]-\>Showing)
        {
        txt.X=Rect.Left+6;
        txt.Y=Rect.Top+3;
        }else
        {
        txt.X=Rect.Left+3;
        txt.Y=Rect.Top+3;
        }
    }
//чистка
PC-\>Canvas-\>FillRect(Rect);
//вывести текст
if (!PC-\>Pages[TabIndex]-\>Tag)
    {
    PC-\>Canvas-\>TextOutW(txt.X,txt.Y,(PC-\>Pages[TabIndex]-\>Caption).Trim());
    PC-\>Pages[TabIndex]-\>Tag=0;
    }
//кнупочка
DrawCloseTabBtn(PC,&amp;Rect,0,0,TabIndex,0);
//нарисовать иконку
TPoint ico;
ico.X=Rect.Left+2;
ico.Y=Rect.Top+2;
Graphics::TBitmap *b=new Graphics::TBitmap();
if (Img-\>GetBitmap(PC-\>Pages[TabIndex]-\>ImageIndex,b))
    {
    PC-\>Canvas-\>Draw(ico.X,ico.Y,b);
    }
delete b;
}
</code>

Type Parameters
Control :   Указатель на контейнер для отображения вкладок.
TabIndex :  Номер отрисовываемой вкладки.
Rect :      Область отрисовки вкладки.
Active :    Триггер разрешения к действию.

@@TmForm::PCMouseLeave@TObject *
Description
Обработчик события покидания указателем мыши зоны отрисовки.
C++ Syntax
<code lang="c++">
void __fastcall TmForm::PCMouseLeave(TObject *Sender)
{
((TPageControl *)Sender)-\>Repaint();
}
</code>
Note
Функция заставляет отрисовать заново покидаемый мышкой
компонент.
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TmForm::PCMouseMove@TObject *@TShiftState@int@int
Description
Функция обработки события перемещения указателя мыши.
C++ Syntax
<code>
void __fastcall TmForm::PCMouseMove(TObject *Sender, TShiftState Shift, int X,
          int Y)
{
//страбатывание кнопки
TPageControl *PC=(TPageControl *)Sender;
TRect btn=DrawCloseTabBtn(PC,0,X,Y,-1,2);
/*static TRect btnOld;     // отключена перерисовка крестина на предыдущей табе
if (btn!=btnOld&amp;&amp;(btnOld.top||btnOld.Bottom||btnOld.Left||btnOld.Right))
    {
    TPoint s;
    s.X=btnOld.Left+5;
    s.Y=btnOld.Top+5;
    s=PC-\>ParentToClient(s,PC-\>Parent);
    DrawCloseTabBtn(PC,0,s.x,s.y,-1,0);     //привести координаты к нужному виду
    }
btnOld=btn; */
}
</code>

Type Parameters
Sender :  Указатель на объект, вызвавший функцию
Shift :   Состояние кнопок crtl, alt, shift
X :       Позиция курсора по оси X
Y :       Позиция курсора по оси Y

@@TmForm::PCDragOver@TObject *@TObject *@int@int@TDragState@bool &
Description
Функция - обработчик события протаскивания компонента над
объектом
C++ Syntax
<code lang="c++">
void __fastcall TmForm::PCDragOver(TObject *Sender, TObject *Source, int X, int Y,
          TDragState State, bool &amp;Accept)
{
Accept=Source-\>ClassNameIs("TPageControl");
}
</code>

Type Parameters
Sender :  Указатель на объект, вызвавший функцию (место куда
          осуществляется перетаскивание)
Source :  Указатель на объект \- источник данных (место откуда
          осуществляется перетаскивание)
X :       Позиция указателя мыши по оси X
Y :       Позиция указателя мыши по оси Y
State :   Состояния перетаскивания
Accept :  Триггер разрешения к действию перетаскивания.

@@TmForm::PCDragDrop@TObject *@TObject *@int@int
Description
Функция - обработчик "сбрасывания" перетаскиваемого
компонента.
C++ Syntax
<code lang="c++">
 void __fastcall TmForm::PCDragDrop(TObject *Sender, TObject *Source, int X, int Y)
{
if (Source-\>ClassNameIs("TPageControl"))
    {
    TPageControl *from=(TPageControl *)Source;
    TPageControl *to=(TPageControl *)Sender;
    TTabSheet *tab=from-\>ActivePage;
    if (from!=to)
        {
        tab-\>PageControl=to;
        }
    tab-\>PageIndex=to-\>IndexOfTabAt(X,Y);
    from-\>Tag=0;
    to-\>Tag=0;
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию (место куда
          осуществляется перетаскивание)
Source :  Указатель на объект \- источник данных (место откуда
          осуществляется перетаскивание)
X :       Позиция указателя мыши по оси X
Y :       Позиция указателя мыши по оси Y

@@TmForm::FormDragOver@TObject *@TObject *@int@int@TDragState@bool &
Description
Функция - обработчик события протаскивания компонента над
формой (позиция в зоне PageControl)
C++ Syntax
<code>
void __fastcall TmForm::FormDragOver(TObject *Sender, TObject *Source, int X, int Y,
          TDragState State, bool &amp;Accept)
{
//сорс -\>ссылка на паратаскиваемый контрол
//сендер сама форма
// сравнить координаты х и у с параметрами размещения контролов если в зоне их нахождения то все норм
if (Source-\>ClassNameIs("TPageControl"))
    {
    if (X\>=LeftPC-\>Left&amp;&amp;X\<=LeftPC-\>Left+LeftPC-\>Width&amp;&amp;Y\>=LeftPC-\>Top&amp;&amp;Y\<=LeftPC-\>Top+LeftPC-\>Height)
        {
        Accept=true;
        }
    if (X\>=RightPC-\>Left&amp;&amp;X\<=RightPC-\>Left+RightPC-\>Width&amp;&amp;Y\>=RightPC-\>Top&amp;&amp;Y\<=RightPC-\>Top+RightPC-\>Height)
        {
        Accept=true;
        }
    return;
    }
Accept=false;
}
</code>

Type Parameters
Sender :  Указатель на объект, вызвавший функцию (место куда
          осуществляется перетаскивание, но в этом обработчике
          идет перехват направления перетаскивания)
Source :  Указатель на объект \- источник данных (место откуда
          осуществляется перетаскивание)
X :       Позиция указателя мыши по оси X
Y :       Позиция указателя мыши по оси Y
State :   Состояния перетаскивания
Accept :  Триггер разрешения к действию перетаскивания.

@@TmForm::FormDragDrop@TObject *@TObject *@int@int
Description
Функция - обработчик "сбрасывания" перетаскиваемого
компонента над формой при отсутствии вкладок.
C++ Syntax
<code>
void __fastcall TmForm::FormDragDrop(TObject *Sender, TObject *Source, int X, int Y)
{
if (Source-\>ClassNameIs("TPageControl"))
    {
    TPageControl *from=(TPageControl *)Source;
    TPageControl *to=0;
    if (X\>=LeftPC-\>Left&amp;&amp;X\<=LeftPC-\>Left+LeftPC-\>Width&amp;&amp;Y\>=LeftPC-\>Top&amp;&amp;Y\<=LeftPC-\>Top+LeftPC-\>Height)
        {
        to=LeftPC;
        }
    if (X\>=RightPC-\>Left&amp;&amp;X\<=RightPC-\>Left+RightPC-\>Width&amp;&amp;Y\>=RightPC-\>Top&amp;&amp;Y\<=RightPC-\>Top+RightPC-\>Height)
        {
        to=RightPC;
        }
    TTabSheet *tab=from-\>ActivePage;
    if (from!=to)
        {
        tab-\>PageControl=to;
        }
    tab-\>PageIndex=to-\>PageCount-1;
    from-\>Tag=0;
    to-\>Tag=0;
    }
}
</code>

Type Parameters
Sender :  Указатель на объект, вызвавший функцию (место куда
          осуществляется перетаскивание, но в этом обработчике
          идет перехват направления перетаскивания)
Source :  Указатель на объект \- источник данных (место откуда
          осуществляется перетаскивание)
X :       Позиция указателя мыши по оси X
Y :       Позиция указателя мыши по оси Y

@@TmForm::DrawCloseTabBtn@TPageControl *@TRect *@int@int@int@char
Description
Функция отрисовки кнопки закрытия вкладки.
C++ Syntax
<code lang="c++">
TRect TmForm::DrawCloseTabBtn(TPageControl *PC,const TRect *Rect,int X,int Y,int TabNo,char type)
{
TRect r;
static int oldi;
int i;
if (TabNo\>=0)
    {
    i=TabNo;
    }else
    {
    i=PC-\>IndexOfTabAt(X,Y);
    }
if (i\<0) {return r;}
if (Rect)
    {
    r=*Rect;
    }else
    {
    r=PC-\>TabRect(i);
    }

TRect btn;
int vofset,gofset;
if (!Rect)
    {
    if (PC-\>Pages[i]-\>Showing)
        {
        vofset=2;
        gofset=2;
        }else
        {
        vofset=4;
        gofset=6;
        }
    }else
    {
    if (Rect&amp;&amp;X&amp;&amp;Y)
        {
        if (i==oldi){return btn;}
        vofset=0;
        gofset=0;
        }else
        {
        vofset=4;
        gofset=4;
        }
    }
oldi=i;
btn.Right=r.Right-gofset;
btn.Top=r.Top+vofset;
btn.Left=btn.Right-btns-\>Width;
btn.Bottom=btn.Top+btns-\>Height;
Graphics::TBitmap *b=new Graphics::TBitmap();
char img;
bool CanDraw=false;
switch (type)
    {
    case 0:{img=0;CanDraw=true;break;}
    case 1:    {
            img=1;
            if (X\>=btn.Left&amp;&amp;X\<=btn.Right&amp;&amp;Y\>=btn.Top&amp;&amp;Y\<=btn.Bottom)
                {
                CanDraw=true;
                }else
                {
                CanDraw=false;
                }
            break;
            }
    case 2:    {
            int k=GetKeyState(VK_LBUTTON);
            if (X\>=btn.Left&amp;&amp;X\<=btn.Right&amp;&amp;Y\>=btn.Top&amp;&amp;Y\<=btn.Bottom&amp;&amp;k\<0)  //проверить диапазон кнопки
                {
                img=1;
                }else
                {
                img=0;
                }
            CanDraw=true;
            break;
            }
    default:break;
    }
if (btns-\>GetBitmap(img,b)&amp;&amp;CanDraw)
    {
    PC-\>Canvas-\>Draw(btn.Left,btn.top,b);
    }
delete b;
return btn;
}
</code>

Type Parameters
PC :     Указатель на контейнер и место отображения вкладок
Rect :   Указатель на зону\-прямоугольник
X :      Координата мышки по оси Х
Y :      Координата мышки по оси Y
TabNo :  Номер вкладки
type :   Тип выполняемого действия

@@TmForm::PCChange@TObject *
Description
Функция обработчик действия- переключения между вкладками.
C++ Syntax
<code lang="c++">
void __fastcall TmForm::PCChange(TObject *Sender)
{
TPageControl *pc=(TPageControl *)Sender;
SetLastTab(pc-\>ActivePage);
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию


@@TmForm::GetTab@TTabSheet *
Description
Функция получения указателя на базовый контейнер для вкладок
и модулей
C++ Syntax
<code>
Tab*            TmForm::GetTab         (TTabSheet *tab)
{
if (Tabs.size())
    {
    for (vector \<Tab*\>::iterator i=Tabs.begin(); i\<Tabs.end(); i++)
        {
        if ((*i)-\>tab==tab)
            {
            return *i;
            }
        }
    }
return 0;
}
</code>
Type Parameters
tab :  Указатель на вкладку

@@TmForm::SetLastTab@TTabSheet *
Description
Функция установки флага "последняя активная вкладка" для
каждого вида вкладок
C++ Syntax
<code lang="c++">
void  TmForm::SetLastTab    (TTabSheet *tab)
{
Tab *t=GetTab(tab);
if (t&amp;&amp;Tabs.size())
    {
    for (vector \<Tab*\>::iterator i=Tabs.begin(); i\<Tabs.end(); i++)
        {
        if ((*i)-\>TrueClassName()==t-\>TrueClassName())
            {
            if ((*i)!=t)
                {
                (*i)-\>last_tab=false;
                }
            }

        }
    t-\>last_tab=true;
    }
}
</code>
Type Parameters
tab :  Указатель на вкладку

@@TmForm::CloseTab@TTabSheet *
Description
Функция удаления вкладки и всего ее содержимого
C++ Syntax
<code lang="c++">
void     TmForm::CloseTab (TTabSheet *tab)
{
if (tab==InfoTab)
    {
    tab-\>Hide();
    tab-\>PageControl=0;
    }else
    {
    Tab *t=GetTab(tab);
    if (t&amp;&amp;Tabs.size())
        {
        for (vector \<Tab*\>::iterator i=Tabs.begin(); i\<Tabs.end(); i++)
            {
            if ((*i)==t)
                {
                Tabs.erase(i);
                }
            }
        delete t;
        }
    }
}
</code>
Type Parameters
tab :  Указатель на вкладку

@@TmForm::TechnologicBTNClick@TObject *
Description
Обработчик нажатия кнопки добавления окна редактирования
технологии.
C++ Syntax
<code lang="c++">
void __fastcall TmForm::TechnologicBTNClick(TObject *Sender)
{
AddTexTab(RightPC,0);
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TmForm::TechnologicVievBTNClick@TObject *
Description
Функция обработчик нажатия кнопки добавления вкладки
просмотра технологии
C++ Syntax
<code lang="c++">
void __fastcall TmForm::TechnologicVievBTNClick(TObject *Sender)
{
AddTexViewTab(RightPC,0);
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TmForm::ShowInfoClick@TObject *
Description
Обработчик нажатия кнопки добавления вкладки с информацией
C++ Syntax
<code lang="c++">
void __fastcall TmForm::ShowInfoClick(TObject *Sender)
{
if (!InfoTab-\>PageControl)
    {
    InfoTab-\>PageControl=RightPC;
    };
InfoTab-\>Show();
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию.

@@TmForm::SearchBTNClick@TObject *
Description
Функция обработчик нажатия кнопки добавления вкладки поиска
C++ Syntax
<code lang="c++">
void __fastcall TmForm::SearchBTNClick(TObject *Sender)
{
AddSearch(RightPC);
}
</code>

@@_ShowTree@Obd *
Description
Функция-команда загрузки дерева спецификации
C++ Syntax
<code lang="c++">
void     _ShowTree                (const Obd *Det)
{
if (Det)
    {
    Obd *tmp=new Obd(*Det);
    Tab *t=mForm-\>GetTab(mForm-\>GetLastTab(0));
    if (t)
        {
        ((ClassConnector*)(((TreeTab*)t)-\>module))-\>Load_sel(tmp);
        return;
        }else
        {
        mForm-\>AddTree(mForm-\>LeftPC,tmp,mForm-\>Info);
        return;
        }
    }
}
</code>
Type Parameters
Det :  Указатель на объект данных для загрузки

@@TmForm::TreeBTNClick@TObject *
Description
Обработчик нажатия на кнопку добавления вкладки дерева
спецификаций.
C++ Syntax
<code lang="c++">
void __fastcall TmForm::TreeBTNClick(TObject *Sender)
{
AddTree(LeftPC,0,Info);
}
</code>

@@_LoadTexToCurrTab@Obd *
Description
Функция-команда для загрузки технологии в текущую вкладку.
C++ Syntax
<code lang="c++">
void     _LoadTexToCurrTab        (const Obd *Det)
{
if (Det)
    {
    Obd *tmp=new Obd(*Det);
    mForm-\>LoadTexToCurrTab(tmp);
    }
}
</code>

@@_AddTexTab@Obd *
Description
Функция-команда для загрузки технологии в новую вкладку.
C++ Syntax
<code lang="c++">
void     _AddTexTab                (const Obd *Det)
{
if (Det)
    {
    Obd *tmp=new Obd(*Det);
    mForm-\>AddTexTab(mForm-\>RightPC,tmp);
    }
}
</code>

@@_LoadexViewToCurrTab@Obd *
Description
Функция - команда для загрузки технологии в существующую
вкладку просмотра
C++ Syntax
<code lang="c++">
void     _LoadexViewToCurrTab    (const Obd *Det)
{
if (Det)
    {
    Obd *tmp=new Obd(*Det);
    mForm-\>LoadexViewToCurrTab(tmp);
    }
}
</code>

@@_AddTexViewTab@Obd *
Description
Функция - команда для загрузки технологии в новую вкладку
просмотра
C++ Syntax
<code lang="c++">
void     _AddTexViewTab            (const Obd *Det)
{
if (Det)
    {
    Obd *tmp=new Obd(*Det);
    mForm-\>AddTexViewTab(mForm-\>RightPC,tmp);
    }
}
</code>

@@TmForm::AddTree@TPageControl *@Obd *@TMemo *
Description
Функция добавления вкладки дерева спецификации.
C++ Syntax
<code lang="c++">
void    TmForm::AddTree(TPageControl *Page,Obd *det,TMemo *memo)
{
TSpTree *SpTree=0;
TTabSheet *tab;
TreeTab *t=new TreeTab();
tab=new TTabSheet(this);//создание щита
tab-\>ImageIndex=0;
tab-\>PageControl=Page;//прикрепление щита
//создание дерева //прикрепление дерева
SpTree=new TSpTree(this,tab,DB,UserID,memo,IcoData,&amp;_AddTexTab,&amp;_LoadTexToCurrTab,&amp;_AddTexViewTab,&amp;_LoadexViewToCurrTab);

//регистрация щита и дерева
t-\>tab=tab;
t-\>module=SpTree;
t-\>last_tab=false;
Tabs.push_back((Tab*)t);
SetLastTab(tab);
tab-\>Show();
//занесение первичных данных в дерево
if (det)
    {
    ((ClassConnector*)SpTree)-\>Load_sel(det);
    }
}
</code>
Type Parameters
Page :  Указатель на место расположение вкладки
det :   Указатель на объект данных загружаемой детали/узла
memo :  Указатель на объект для отображения информации

@@TmForm::GetLastTab@char
Description
Функция для получения указателя на последнюю активную вкладку
заданного типа.
C++ Syntax
<code lang="c++">
TTabSheet *     TmForm::GetLastTab(char type)
{
String ClassType="";
switch (type)
    {
    case 0:    {//поиск среди спецификаций
            ClassType="TreeTab";
            break;
            }
    case 1:    {//поиск среди технологий
            ClassType="TechTab";
            break;
            }
    case 2:    {//поиск среди просмотров технологий
            ClassType="TechViewTab";
            break;
            }
    case 3:    {//поиск среди поисков
            ClassType="SearchTab";
            break;
            }
    default:ClassType="";break;
    }
if (Tabs.size())
    {
    for (vector \<Tab*\>::iterator i=Tabs.begin(); i\<Tabs.end(); i++)
        {
        if ((*i)-\>TrueClassName()==ClassType&amp;&amp;(*i)-\>last_tab)
            {
            return (*i)-\>tab;
            }
        }
    }
return 0;
}
</code>

Type Parameters
type :  Тип содержимого вкладки.

@@TmForm::AddSearch@TPageControl *
Description
Функция добавления вкладки для поиска деталей.
C++ Syntax
<code lang="c++">
void    TmForm::AddSearch            (TPageControl *Page)
{
TSearch *Search=0;
TTabSheet *tab;
SearchTab *t=new SearchTab();
tab=new TTabSheet(this);//создание щита
tab-\>PageControl=Page;//прикрепление щита
//создание эелемента //прикрепление дерева
Search=new TSearch(this,tab,UserID,DB,IcoData,&amp;_ShowTree);
tab-\>ImageIndex=3;
//регистрация щита и дерева
t-\>tab=tab;
t-\>module=Search;
t-\>last_tab=false;
Tabs.push_back((Tab*)t);
SetLastTab(tab);
tab-\>Show();
}
</code>
Type Parameters
Page :  Указатель на компонент для размещения вкладки

@@TmForm::SpTreeClick@TObject *
Description
Функция переключения вкладки между панелями. (вкладка дерева
спецификации)
C++ Syntax
<code lang="c++">
void __fastcall TmForm::SpTreeClick(TObject *Sender)
{
// если нет ни одного дерева то создать
TPageControl *pc;
TMenuItem *curr=(TMenuItem *)Sender;
if (curr!=N24&amp;&amp;curr!=N29) {return;}
switch (curr-\>Tag)
    {
    case     1:{pc=RightPC;break;}
    case   -1:{pc=LeftPC;break;}
    default:return;
    }
if (Tabs.size())
    {
    TTabSheet *t=GetLastTab(0);
    if (t)
        {
        t-\>PageControl=pc;    //если есть хоть одно показать последнее выбранное
        }else
        {
        AddTree(pc,0,Info);
        }
    }else
    {
    AddTree(pc,0,Info);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TmForm::InfoClick@TObject *
Description
Функция переключения вкладки между панелями. (вкладка панели
информации)
C++ Syntax
<code lang="c++">
void __fastcall TmForm::InfoClick(TObject *Sender)
{
TPageControl *pc;
TMenuItem *curr=(TMenuItem *)Sender;
if (curr!=N5&amp;&amp;curr!=N32) {return;}
switch (curr-\>Tag)
    {
    case     1:{pc=RightPC;break;}
    case   -1:{pc=LeftPC;break;}
    default:return;
    }
    InfoTab-\>PageControl=pc;   //переключение-включение
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавшего функцию

@@TmForm::TechClick@TObject *
Description
Функция переключения вкладки между панелями. (вкладка
редактора технологии)
C++ Syntax
<code lang="c++">
void __fastcall TmForm::TechClick(TObject *Sender)
{
TPageControl *pc;
TMenuItem *curr=(TMenuItem *)Sender;
if (curr!=N6&amp;&amp;curr!=N30) {return;}
switch (curr-\>Tag)
    {
    case     1:{pc=RightPC;break;}
    case   -1:{pc=LeftPC;break;}
    default:return;
    }
if (Tabs.size())
    {
    TTabSheet *t=GetLastTab(1);
    if (t)
        {
        t-\>PageControl=pc;    //если есть хоть одно показать последнее выбранное
        }else
        {
        AddTexTab(pc,0);
        }
    }else
    {
    AddTexTab(pc,0);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вазвавший функцию

@@TmForm::TechViewClick@TObject *
Description
Функция переключения вкладки между панелями. (вкладка
просмотра технологии)
C++ Syntax
<code lang="c++">
void __fastcall TmForm::TechViewClick(TObject *Sender)
{
TPageControl *pc;
TMenuItem *curr=(TMenuItem *)Sender;
if (curr!=N26&amp;&amp;curr!=N27) {return;}
switch (curr-\>Tag)
    {
    case     1:{pc=RightPC;break;}
    case   -1:{pc=LeftPC;break;}
    default:return;
    }
if (Tabs.size())
    {
    TTabSheet *t=GetLastTab(2);
    if (t)
        {
        t-\>PageControl=pc;    //если есть хоть одно показать последнее выбранное
        }else
        {
        AddTexViewTab(pc,0);
        }
    }else
    {
    AddTexViewTab(pc,0);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TmForm::SearchClick@TObject *
Description
Функция переключения вкладки между панелями. (вкладка поиска)
C++ Syntax
<code lang="c++">
void __fastcall TmForm::SearchClick(TObject *Sender)
{
TPageControl *pc;
TMenuItem *curr=(TMenuItem *)Sender;
if (curr!=N23&amp;&amp;curr!=N31) {return;}
switch (curr-\>Tag)
    {
    case     1:{pc=RightPC;break;}
    case   -1:{pc=LeftPC;break;}
    default:return;
    }
if (Tabs.size())
    {
    TTabSheet *t=GetLastTab(3);
    if (t)
        {
        t-\>PageControl=pc;    //если есть хоть одно показать последнее выбранное
        }else
        {
        AddSearch(pc);
        }
    }else
    {
    AddSearch(pc);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию.



@@PerexRow::Copy_subline@int@int
Description
Функция для копирования элементов цепочки.
C++ Syntax
<code lang="c++">
PerexRow *  PerexRow::Copy_subline    (int pos,int _count)
{    //копировать только элементы без пометки del
    //проверка позиции
int cnt=this-\>Count();
if (cnt\>pos)
    {
    PerexRow * node=this-\>operator [](pos);
    PerexRow * ret=new PerexRow(node-\>DB,*node-\>OpID,node-\>action,node-\>row,node-\>Text,0);
    for (int i=1; i\<_count&amp;&amp;node-\>next; i++)
        {
        node=node-\>next;
        if (node-\>action!="del")
            {
            ret=new PerexRow(node-\>DB,*node-\>OpID,node-\>action,node-\>row,node-\>Text,ret);
            }
        }
    return ret-\>Get_First();
    }else{return 0;};
}
</code>
Type Parameters
pos :     Позиция элемена с которого начнется копирование
          цепочки
_count :  Количество элементов для копирования
Note
Копируются только элементы не помеченные меткой "del".



Создается новая цепочка с пометкой на вставку "ins" и данными
из базовой цепочки.

@@PerexRow::Insert_line@int@PerexRow *
Description
Функция для вставки одной цепочки в другую. Возвращает
указатель на новый начальный узел цепочки.
C++ Syntax
<code lang="c++">

</code>
Type Parameters
pos :        Позиция
line_item :  Указатель на вставляемую цепочку данных
Note
Вставляются только элементы цепочки не помеченные меткой
"del"

При вставке цепочки происходит замена идентификатора операции
и обновление метки дейяствияч на "ins"

@@PerexRow::Get_Last
Description
Функция возваращает указатель на последний элемент цепочки
C++ Syntax
<code lang="c++">
PerexRow *     PerexRow::Get_Last    (void)
{
PerexRow * t=this;
while (t-\>next)
    {
    t=t-\>next;
    }
return t;
}
</code>
Note
Функция циклична, потому есть опасность зацыкливания в
бесконечный поток при замкнутой цепочке.

@@PerexRow::Get_First
Description
Функция возваращает указатель на первый элемент цепочки
C++ Syntax
<code>
PerexRow *     PerexRow::Get_First    (void)
{
PerexRow * t=this;
while (t-\>prev)
    {
    t=t-\>prev;
    }
return t;
}
</code>
Note
Функция циклична, потому есть опасность зацыкливания в
бесконечный поток при замкнутой цепочке.

@@PerexRow::Get_Next
Description
Функция доступа для получения указателя на следующее звено
цепочки.
C++ Syntax
<code lang="c++">
PerexRow *     Get_Next    (void) {return next;};
</code>

@@PerexRow::Get_Prev
Description
Функция доступа для получения указателя на предыдущее звено
цепочки.
C++ Syntax
<code>
PerexRow *     Get_Prev    (void) {return prev;};
</code>

@@PerexRow::Get_Text
Description
Функция для доступа для получения текста для заполнения
текста переходов
C++ Syntax
<code lang="c++">
String         Get_Text    (void)    {if (action=="del"){return "";}else{return Text;}};
</code>

@@PerexRow::Count
Description
Функция для возврата количества звеньев в цепочке
C++ Syntax
<code lang="c++">
int  PerexRow::Count (void)
{
PerexRow *curr=this;
while (curr-\>next)
    {
    curr=curr-\>next;
    }
return curr-\>ofset+1;
}
</code>
Note
Функция опасна при замкнутой цепочке, т.к. приведет к
бесконечному цыклу.

@@PerexRow::Del_subline@int@int
Description
Функция для удаления части цепочки в том числе и из базы.
C++ Syntax
<code lang="c++">

</code>
Type Parameters
pos :     Позиция с которой начнется удаление
_count :  Количество удаляемых звеньев цепочки

@@PerexRow::SetValues@String &
Description
Функция для обновления переменных класса данных
C++ Syntax
<code lang="c++">
void PerexRow::SetValues (const String &amp;_Text)
{
if (action=="del"){return;}
if (_Text!="")
    {//замены
    if (Text!=_Text||ofset+1!=row)
        {
        if (action!="ins"){action="upd";}
        Text=_Text;
        }
    }else
    {//удаления
    if (action=="ins")
        {
        delete this;
        }else
        {
        action="del";
        Push_Back_Deleted();
        }
    }
}
</code>
Type Parameters
_Text :  Текст перехода

@@PerexRow::Upd_Ofset@bool
Description
Фукция коррекции порядкового номера
C++ Syntax
<code lang="c++">

</code>
Type Parameters
onward :  Триггер определяющий направление коррекции позиции

@@PerexRow::Move_items@int@int@int
Description
Функция для перемещения строк внутри массива
C++ Syntax
<code lang="c++">
void        PerexRow::Move_items    (int pos,int _count,int new_pos)
{
if (_count\>0&amp;&amp;pos!=new_pos)
    {
    // получить указатель на гловной хвостовой элементы элемент
    lnk first_move_item=this-\>operator [](pos);
    lnk last_move_item=this-\>operator [](pos+_count-1);
    // получить указатель на итем перед позицией вставки с учетом количества перемещаемых объектов
    // сравнить текущую позицию с требуемой, и при необходимости провести коррекцию реальной позиции для вставки
    int real_ins_pos;
    if (new_pos\>pos)
        {
        real_ins_pos=new_pos+_count;
        }else
        {//нет нужды к корректировке позиции...
        real_ins_pos=new_pos;
        }
    //коррекция реальной позиции переноса
    if (real_ins_pos\<0)
        {
        real_ins_pos=0;
        }
    int count=Count();
    if (real_ins_pos\>count)
        {
        real_ins_pos=count;
        }
    lnk section=this-\>operator [](real_ins_pos);
    //проверка на перемещения конца цепочки в коонец цепочки
    if (section!=last_move_item)
        {
            //сцепка цепочек
            // сшить образовавшуюся дыру
        if (first_move_item-\>prev)
            {
            first_move_item-\>prev-\>next=last_move_item-\>next;
            }
        if (last_move_item-\>next)
            {
            last_move_item-\>next-\>prev=first_move_item-\>prev;
            }
        lnk before=0;
        lnk after=0;
        // выбор границ вставки
        if (count!=real_ins_pos)
            {  //сцепка перед указанным узлом
            before=section-\>prev;
            after=section;
            }else
            {  //сцепка после указанного узла
            before=section;
            after=section-\>next;
            }
        // вставить объекты
        first_move_item-\>prev=before;
        if (before)
            {
            before-\>next=first_move_item;
            }
        last_move_item-\>next=after;
        if (after)
            {
            after-\>prev=last_move_item;
            }
        //переписывание позиций массива
        Get_First()-\>Upd_Ofset();
        }
    }
}
</code>
Type Parameters
pos :      Позиция первого перемещаемого элемента.
_count :   Количество перемещаемых элементов.
new_pos :  новая позиция перемещаемого блока.

@@PerexRow::SaveData
Description
Функция для сохранения цепочки данных в базу
C++ Syntax
<code lang="c++">
bool PerexRow::SaveData    (lnk &amp;r)
{

bool effect=true;
String del="",ins="";
//удаление строк
//сбор данных
for (lnk   t=Get_Last();t&amp;&amp;t-\>action=="del";t=t-\>prev)
    {// собрать коллекцию для del потом коллекциюя для insвтромым пробегом запустить все upd
    del=del+"('"+String(t-\>OpID)+"','"+String(t-\>row)+"'),";
    }
if (del!="")
    {
    del.Delete(del.Length(),1);
    del="("+del+")";
    effect=r-\>DB-\>SendCommand("delete from technologic.perexod where (OpUUID,strk) in "+del);
    //установка отметки и удалениеиз цепочки удаленных строк
    if (effect)
        {
        lnk t=r-\>Get_First();
        while (t)
            {
            if (t-\>action=="del")
                {
                if (t-\>prev)
                    {
                    t=t-\>prev;
                    if (t-\>next==r) {r=t;}
                    delete t-\>next;
                    t=t-\>next;
                    }else
                    {
                    if (t-\>next)
                        {
                        t=t-\>next;
                        if (t-\>prev==r) {r=t;}
                        delete t-\>prev;
                        }else
                        {
                        delete t;
                        r=0;return effect;
                        }
                    }
                }else
                {
                t=t-\>next;
                }
            }
        }else
        {
        return effect;//ошибка в запросе удаления
        }
    }
//обновление строк  // и установка отметки выполнения
for (lnk  t=r-\>Get_First();t;t=t-\>next)
    {// собрать коллекцию для del потом коллекциюя для insвтромым пробегом запустить все upd
    if (t-\>action=="upd")
        {
        effect=r-\>DB-\>SendCommand("update technologic.perexod set strk='"+String(t-\>ofset+1)+"',tpe='"+
t-\>Text+"',base='mysql' where OpUUID='"+String(t-\>OpID)+"' and strk='"+String(t-\>row)+"' limit 1");
        if (effect){t-\>row=t-\>ofset+1;t-\>action="no";}else{return effect;} // ошибка выполнения запроса на изменение
        }
    }
//вставка строк
//сбор данных
for (lnk   t=r-\>Get_First();t;t=t-\>next)
    {// собрать коллекцию для del потом коллекциюя для insвтромым пробегом запустить все upd
    if (t-\>action=="ins"){ins=ins+"('"+String(t-\>OpID)+"','"+String(t-\>ofset+1)+"','"+t-\>Text+"'),";}
    }
if (ins!="")
    {
    ins.Delete(ins.Length(),1);
    effect=r-\>DB-\>SendCommand("insert into technologic.perexod (OpUUID,strk,tpe)values"+ins);
    if (effect)
        { //отметка выполнения встави
        for (lnk  t=r-\>Get_First();t;t=t-\>next)
            {
            if (t-\>action=="ins"){t-\>row=t-\>ofset+1;t-\>action="no";}
            }
        }else
        {
        return effect;
        }
    }
return effect;
}
</code>

Type Parameters
r :  Ссылка на указатель на цепочку в родительском классе

@@PerexRow::~PerexRow
Description
Деструктор.
C++ Syntax
<code lang="c++">
     PerexRow::~PerexRow()
{
if (prev)
    {
    prev-\>next=next;
    }
if (next)
    {
    next-\>prev=prev;
    next-\>Upd_Ofset();
    }
count--;
}
</code>


@@PerexRow::PerexRow@PerexRow &
Description
Конструктор копировщик, предназначен для копирования всей
цепочки данных.
C++ Syntax
<code lang="c++">
     PerexRow::PerexRow(const PerexRow &amp;r):DB(r.DB),prev(0),next(0),ofset(0)

{// копировщик для копирования всей цепочки
count++;
//вычисление начала цепочки
const PerexRow * first=&amp;r;
while (first-\>prev)
    {
    first=first-\>prev;
    }
//копирование данных
OpID=first-\>OpID;
Text=first-\>Text;
action=first-\>action;
//обработка данных в зависимости от действия
if (action=="ins")
    {
    row=-1;
    }else
    {
    row=first-\>row;
    }
 //создан головной узел
ofset=0;
const PerexRow * t=first-\>next;
PerexRow * n=this;
while (t)
    {//цыкл воссоздания цепочки данных // репликация.
    n=new PerexRow(t-\>DB,*t-\>OpID,t-\>action,t-\>row,t-\>Text,n);
    t=t-\>next;
    }
}
</code>
Type Parameters
r :  Указатель на один из объектов копируемой цепочки.

@@PerexRow::action
Description
Переменная - индикатор действия с базой данных
Note
<table 20c%>
Индикатор   Действие со строкой
----------  ---------------------------------------------
ins         Команда на вставку новой строки в базу
upd         Команда на обновление строки в базе
no          Команда на бездействи (строка не изменялась)
del         Команда на удаление строки из базы
</table>

@@PerexRow::count
Description
Счетчик экземпляров класса

@@PerexRow::DB
Description
Указатель на класс для работы с базой данных

@@PerexRow::next
Description
Указатель на следующее звено цепи.

@@PerexRow::prev
Description
Указатель на предыдущее звено цепи.

@@PerexRow::OpID
Description
Идентификатор операции

@@PerexRow::row
Description
Строка перехода используется для идентификации источника
строки в базе

@@PerexRow::Text
Description
Сохраняемый текст строки


@@PerexRow::ofset
Description
Позиция строки в цепочке, заодно и новый идентификатор строки
в базе

@@PerexRow
Description
Класс - звено цепочки данных для переходов.




@@InstrumRow::~InstrumRow
Description
Деструктор.
C++ Syntax
<code lang="c++">
     InstrumRow::~InstrumRow()
{
if (prev)
    {
    prev-\>next=next;
    }
if (next)
    {
    next-\>prev=prev;
    next-\>Upd_Ofset(false);
    }
count--;
}
</code>

@@InstrumRow::InstrumRow@InstrumRow &
Description
Конструктор копировщик, предназначен для копирования всей
цепочки данных.
C++ Syntax
<code lang="c++">
     InstrumRow::InstrumRow(const InstrumRow &amp;r):DB(r.DB),prev(0),next(0),ofset(0)
{// копировщик для копирования всей цепочки
count++;
//вычисление начала цепочки
c_lnk first=&amp;r;
while (first-\>prev)
    {
    first=first-\>prev;
    }
//копирование данных
OpID=first-\>OpID;
Text=first-\>Text;
kod=first-\>kod;
action=first-\>action;
//обработка данных в зависимости от действия
if (action=="ins")
    {
    row=0;
    }else
    {
    row=first-\>row;
    }
//создан головной узел
ofset=0;
c_lnk  t=first-\>next;
lnk   n=this;
while (t)
    {//цыкл воссоздания цепочки данных // репликация.
    n=new InstrumRow(t-\>DB,t-\>OpID,t-\>action,t-\>row,t-\>kod,t-\>Text,n);
    t=t-\>next;
    }
}
</code>

Type Parameters
r :  Указатель на один из объектов копируемой цепочки

@@InstrumRow::Count
Description
Функция для возврата количества звеньев в цепочке
C++ Syntax
<code>
int          InstrumRow::Count             (void)
{
lnk  curr=this;
while (curr-\>next)
    {
    curr=curr-\>next;
    }
return curr-\>ofset+1;
}
</code>
Note
Функция опасна при замкнутой цепочке, т.к. приведет к
бесконечному цыклу.

@@InstrumRow::Get_First
Description
Функция возваращает указатель на первый элемент цепочки
C++ Syntax
<code>
InstrumRow *       InstrumRow::Get_First    (void)
{
lnk   t=this;
while (t-\>prev)
    {
    t=t-\>prev;
    }
return t;
}
</code>
Note
Функция циклична, потому есть опасность зацыкливания в
бесконечный поток при замкнутой цепочке.

@@InstrumRow::Get_Last
Description
Функция возваращает указатель на последний элемент цепочки
C++ Syntax
<code>
InstrumRow *       InstrumRow::Get_Last    (void)
{
lnk   t=this;
while (t-\>next)
    {
    t=t-\>next;
    }
return t;
}
</code>
Note
Функция циклична, потому есть опасность зацыкливания в
бесконечный поток при замкнутой цепочке.

@@InstrumRow::SetValues@String &@String &
Description
Функция для обновления переменных класса данных
C++ Syntax
<code>
bool InstrumRow::SetValues     (const String &amp;_Text,const String &amp;_kod)
{
if (action=="del"){return false;}
if (_Text!=""||_kod!="")
    {//замены
    if (Text!=_Text||kod!=_kod||ofset+1!=row)
        {
        if (action!="ins"){action="upd";}
        Text=_Text;
        kod=_kod;
        return true;
        }else
        {
        return false;
        }
    }else
    {//удаления
    if (action=="ins")
        {
        delete this;
        }else
        {
        action="del";
        Push_Back_Deleted();
        }
    return true;
    }
}
</code>

Type Parameters
_Text :  Название инструмента
_kod :   Код инструмента

@@InstrumRow::SaveData
Description
Функция для сохранения цепочки данных в базу
C++ Syntax
<code>
bool InstrumRow::SaveData    (lnk &amp;r)
{
bool effect=true;
String del="",ins="";
//удаление строк
//сбор данных
for (lnk   t=Get_Last();t&amp;&amp;t-\>action=="del";t=t-\>prev)
    {// собрать коллекцию для del потом коллекциюя для insвтромым пробегом запустить все upd
    if (del=="")
        {
        del="('0','0'),('"+String(t-\>OpID)+"','"+String(t-\>row)+"'),";
        }else
        {
        del=del+"('"+String(t-\>OpID)+"','"+String(t-\>row)+"'),";
        }
    }
if (del!="")
    {
    del.Delete(del.Length(),1);
    del="("+del+")";
    effect=r-\>DB-\>SendCommand("delete from technologic.instrum where (OpUUID,strk) in "+del);
    //установка отметки и удалениеиз цепочки удаленных строк
    if (effect)
        {
        lnk t=r-\>Get_First();
        while (t)
            {
            if (t-\>action=="del")
                {
                if (t-\>prev)
                    {
                    t=t-\>prev;
                    if (t-\>next==r) {r=t;}
                    delete t-\>next;
                    t=t-\>next;
                    }else
                    {
                    if (t-\>next)
                        {
                        t=t-\>next;
                        if (t-\>prev==r) {r=t;}
                        delete t-\>prev;
                        }else
                        {
                        delete t;
                        r=0;return effect;
                        }
                    }
                }else
                {
                t=t-\>next;
                }
            }
        }else
        {
        return effect;//ошибка в запросе удаления
        }
    }
//обновление строк  // и установка отметки выполнения
for (lnk  t=r-\>Get_First();t;t=t-\>next)
    {// собрать коллекцию для del потом коллекциюя для insвтромым пробегом запустить все upd
    if (t-\>action=="upd")
        {
        effect=r-\>DB-\>SendCommand("update technologic.instrum set strk='"+String(t-\>ofset+1)+"',nain='"+ekran(t-\>Text)+"', koin='"+t-\>kod+"',base='mysql' where OpUUID='"+String(t-\>OpID)+"' and strk='"+String(t-\>row)+"' limit 1");
        if (effect){t-\>row=t-\>ofset+1;t-\>action="no";}else{return effect;} // ошибка выполнения запроса на изменение
        }
    }
//вставка строк
//сбор данных
for (lnk   t=r-\>Get_First();t;t=t-\>next)
    {// собрать коллекцию для del потом коллекциюя для insвтромым пробегом запустить все upd
    if (t-\>action=="ins"){ins=ins+"('"+String(t-\>OpID)+"','"+String(t-\>ofset+1)+"','"+ekran(t-\>Text)+"','"+t-\>kod+"'),";}
    }
if (ins!="")
    {
    ins.Delete(ins.Length(),1);
    effect=r-\>DB-\>SendCommand("insert into technologic.instrum (OpUUID,strk,nain,koin)values"+ins);
    if (effect)
        { //отметка выполнения встави
        for (lnk  t=r-\>Get_First();t;t=t-\>next)
            {
            if (t-\>action=="ins"){t-\>row=t-\>ofset+1;t-\>action="no";}
            }
        }else
        {
        return effect;
        }
    }
return effect;
}
</code>
Type Parameters
r :  ссылка на указатель в родительстком классе

@@InstrumRow::Move_items@int@int@int
Description
Функция для перемещения строк внутри массива
C++ Syntax
<code>
void        InstrumRow::Move_items        (int pos,int _count,int new_pos)
{
if (_count\>0&amp;&amp;pos!=new_pos)
    {
    // получить указатель на гловной хвостовой элементы элемент
    lnk first_move_item=this-\>operator [](pos);
    lnk last_move_item=this-\>operator [](pos+_count-1);
    // получить указатель на итем перед позицией вставки с учетом количества перемещаемых объектов
    // сравнить текущую позицию с требуемой, и при необходимости провести коррекцию реальной позиции для вставки
    int real_ins_pos;
    if (new_pos\>pos)
        {
        real_ins_pos=new_pos+_count;
        }else
        {//нет нужды к корректировке позиции...
        real_ins_pos=new_pos;
        }
    //коррекция реальной позиции переноса
    if (real_ins_pos\<0)
        {
        real_ins_pos=0;
        }
    int count=Count();
    if (real_ins_pos\>count)
        {
        real_ins_pos=count;
        }
    lnk section=this-\>operator [](real_ins_pos);
    //проверка на перемещения конца цепочки в коонец цепочки
    if (section!=last_move_item)
        {
            //сцепка цепочек
            // сшить образовавшуюся дыру
        if (first_move_item-\>prev)
            {
            first_move_item-\>prev-\>next=last_move_item-\>next;
            }
        if (last_move_item-\>next)
            {
            last_move_item-\>next-\>prev=first_move_item-\>prev;
            }
        lnk before=0;
        lnk after=0;
        // выбор границ вставки
        if (count!=real_ins_pos)
            {  //сцепка перед указанным узлом
            before=section-\>prev;
            after=section;
            }else
            {  //сцепка после указанного узла
            before=section;
            after=section-\>next;
            }
        // вставить объекты
        first_move_item-\>prev=before;
        if (before)
            {
            before-\>next=first_move_item;
            }
        last_move_item-\>next=after;
        if (after)
            {
            after-\>prev=last_move_item;
            }
        //переписывание позиций массива
        Get_First()-\>Upd_Ofset();
        }
    }
}
</code>
Type Parameters
pos :      Позиция первого перемещаемого элемента.
_count :   Количество перемещаемых элементов.
new_pos :  новая позиция перемещаемого блока.

@@InstrumRow::Copy_subline@int@int
Description
Функция для копирования элементов цепочки.
C++ Syntax
<code>
InstrumRow *  InstrumRow::Copy_subline    (int pos,int _count)
{    //копировать только элементы без пометки del
    //проверка позиции
int cnt=this-\>Count();
if (cnt\>pos)
    {//поиск первого неудаляемого
    lnk node=this-\>operator [](pos);
    while (node&amp;&amp;node-\>action=="del"&amp;&amp;_count\>0)
        {
        pos++;
        _count--;
        node=node-\>next;
        }
        if (node&amp;&amp;_count\>0)//проверка начальных условий не нулевой узел и не вышедше за пределы количество копируемых
        {// создание первого узла цепочки
        lnk   ret=new InstrumRow(node-\>DB,node-\>OpID,node-\>action,node-\>row,node-\>kod,node-\>Text,0);
        for (int i=1; i\<_count&amp;&amp;node-\>next; i++)
            {//создание остальных узлов цепочки
            node=node-\>next;
            if (node-\>action!="del")
                {//копировать только в слечае если узел не предназначен для удаления
                ret=new InstrumRow(node-\>DB,node-\>OpID,node-\>action,node-\>row,node-\>kod,node-\>Text,ret);
                }
            }
        return ret-\>Get_First();
        }
    }
return 0;
}
</code>
Type Parameters
pos :     Позиция элемена с которого начнется копирование
          цепочки
_count :  Количество элементов для копирования
Note
Копируются только элементы не помеченные меткой "del".



Создается новая цепочка

@@InstrumRow::Get_Text
Description
Функция для доступа для получения текста для заполнения
текста переходов
C++ Syntax
<code>
String         Get_Text    (void)    {if (action=="del"){return "";}else{return Text;}};
</code>

@@InstrumRow::Get_kod
Description
Функция для доступа для получения текста для заполнения
текста переходов
C++ Syntax
<code>
    String         Get_kod     (void)    {if (action=="del"){return "";}else{return kod;}};
</code>



@@InstrumRow::action
Description
Переменная - индикатор действия с базой данных
Note
<table 20c%>
Индикатор   Действие со строкой
----------  ---------------------------------------------
ins         Команда на вставку новой строки в базу
upd         Команда на обновление строки в базе
no          Команда на бездействи (строка не изменялась)
del         Команда на удаление строки из базы
</table>

@@InstrumRow::DB
Description
Указатель на класс для работы с базой данных

@@InstrumRow::next
Description
Указатель на следующее звено цепи.

@@InstrumRow::ofset
Description
Позиция строки в цепочке, заодно и новый идентификатор строки
в базе

@@InstrumRow::OpID
Description
Идентификатор операции

@@InstrumRow::prev
Description
Указатель на предыдущее звено цепи.

@@InstrumRow::row
Description
Строка перехода используется для идентификации источника
строки в базе

@@InstrumRow::Text
Description
Название инструмента

@@InstrumRow::kod
Description
Код инструмента



@@InstrumRow
Description
Класс - звено цепочки данных для инструмента.

@@TSpTree::UnBlock@String &
Description
Функция для разблокирования помеченного узла/детали
(отключение режима эксклюзивного доступа)
C++ Syntax
<code lang="c++">
void              TSpTree::UnBlock(String &amp;ids)
{
String sql;
if (!MassAction)
    {
    sql="Call constructions.unblock('"+ids+"','"+String(LUser)+"')";
    } else
    {
    sql="Call constructions.unblockALL('"+ids+"','"+String(LUser)+"')";
    }
!DB-\>SendCommand(sql);
return;
}
</code>
Type Parameters
ids :  Список идентификаторов для разблокировки
Note
Рассмотреть возможноть вывода этой функции в отдельный
интерфейсный класс

@@TSpTree::Block@String &
Description
Функция для блокирования помеченного узла/детали (включение
режима эксклюзивного доступа)
C++ Syntax
<code>
void              TSpTree::Block(String &amp;ids)
{
String sql;
if (!MassAction)
    {
    sql="Call constructions.block('"+ids+"','"+String(LUser)+"')";
    } else
    {
    sql="Call constructions.blockALL('"+ids+"','"+String(LUser)+"')";
    }
DB-\>SendCommand(sql);
return;
}
</code>

Note
Рассмотреть возможноть вывода этой функции в отдельный
интерфейсный класс
Type Parameters
det :  Указатель на класс данных блокируемой детали/узла

@@TSearch::GetConditions@int
Description
Функция получения списка состояний, доступных пользователю
для редактирования
C++ Syntax
<code>
String          TSearch::GetConditions(int User_ID)
{
String result="'0',";
String sql="select a.idCond from administration.gtucond a inner join administration.conditions b on b.idsost=a.idCond inner join administration.logins c on c.Levelacss=a.IdGroup where c.LogID='"+String(User_ID)+"' and b.arhive=0";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    rez-\>First();
    while (!rez-\>Eof)
        {
        \result=result+"'"+rez-\>FieldByName("idcond")-\>Value+"',";
        rez-\>Next();
        }
    }
delete rez; rez=0;
\result.Delete(result.Length(),1);
return result;
}
</code>
Type Parameters
User_ID :  Идентификатор пользователя

@@TSpTree::SpDel@TObject *
Description
Фукнция отправки команды на удаление технологии из базы
C++ Syntax
<code>
void __fastcall TSpTree::SpDel(TObject *Sender)
{
if (!MessageDlg("Удаление безвозвратно уничтожит всю информацию. Продолжить?",mtWarning,TMsgDlgButtons()\<\<mbYes\<\<mbNo,0)==mrYes){return;}
TTreeView *TV=Tree;
String ids="",param;
Obd *det=0;
vector \<TTreeNode *\>nodes;
for (unsigned int i=0; i \< TV-\>SelectionCount; i++)
    {
    det=(Obd*)TV-\>Selections[i]-\>Data;
    if (det&amp;&amp;det-\>TrueClassName()=="TreeRow")
        {
        TreeRow *Row=(TreeRow *)det;
        Row-\>UpdateVal();
        if (Row-\>Get_Accept())
            {
            ids=ids+String(Row-\>Get_ID())+",";
            nodes.push_back(TV-\>Selections[i]);
            }
        }
    }
switch (((TMenuItem*)Sender)-\>Tag)
    {
    case 0:{param="sp_only";break;}
    case 1:{param="det";break;}
    case 2:{param="sp_and_all_det";break;}
    default:return;
    }
if (ids!="")
    {
    ids.Delete(ids.Length(),1);
    DB-\>SendCommand("Call constructions.SpDel('"+ids+"','"+param+"')");
    if (TV-\>Selected-\>Parent)
        {
        for (vector\<TTreeNode *\>::iterator i=nodes.begin(); i!=nodes.end(); i++)
            {
            UpdateInfo(*i);
            }
        }else
        {
        LoadTree(((Obd*)(TV-\>Selected-\>Data))-\>Get_ID());
        }
    }else
    {
    ShowMessage("Нет доступа ни к одному из элементов");
    }
}
</code>
Type Parameters
Sender :  Указатель на объект, вызвавший функцию

@@TSpTree::Load_sel@Obd *
Description
Интерфейсная функция - команда на загрузку узла/детали и
занесение в историю селектора
C++ Syntax
<code>
void  Load_sel(Obd *det){Selector-\>LoadDet(det);};
</code>
Type Parameters
det :  Указатель на загружаемую деталь

@@ClassConnector::Load_sel@Obd *
Description
Чистая виртуальная функция. Является интерфейсом для
возможности отослать команду на загрузку детали в модуль
через селектор установленный в модуле не зависимо от типа
модуля
Type Parameters
det :  Указатель на класс описания детали


@@TSpTree::N27
Description
Компонент - комaнда контекстного меню Удалить-\>Спецификацию
(кроме самих деталей)

@@TSpTree::N2
Description
Компонент - комaнда контекстного меню Удалить-\>Деталь и всю
информаци по ней

@@TSpTree::N28
Description
Компонент - комaнда контекстного меню Удалить-\>Спецификацию
и все свободные детали

@@TmForm::PCEnter@TObject *
Description
Функция обработки события переключения фокуса на панель.
Используется для указания последней активной вкладки в
процессе работы.
C++ Syntax
<code lang="c++">
void __fastcall TmForm::PCEnter(TObject *Sender)
{
TPageControl *PC=(TPageControl*)Sender;
if (PC)
    {
    SetLastTab(PC-\>ActivePage);
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSearch::Combo
Description
Комбо бокс для выбора состояния среди которого будет выполнен
поиск

@@TSearch::HideBtn
Description
Кнопка - сплиттер для скрывания/отображения параметров поиска


@@TSearch::IMG
Description
Место вывода изображения иконки состояния среди которого идет
поиск

@@TSearch::Label4
Description
Надпись "Отбор по текущему состоянию"

@@TSearch::HideBtnClick@TObject *
Description
Функция обработки нажатия кнопки - сплитера HideBtn
C++ Syntax
<code lang="c++">
void __fastcall TSearch::HideBtnClick(TObject *Sender)
{
TButton *btn=(TButton *)Sender;
if (btn)
    {
    if (btn-\>Tag)
        {
        Panel1-\>Height=148;
        btn-\>Tag=0;
        }else
        {
        Panel1-\>Height=36;
        btn-\>Tag=1;
        }
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@InstrumRow::[]@unsigned int &
Description
Функция получения указателя на один из элементов цепочки
C++ Syntax
<code>
InstrumRow *       InstrumRow::operator []    (const unsigned int &amp;r)
{
if (r==ofset)
    {
    return this;
    }else
    {
    if (r\<ofset)
        {
        if (prev)
            {
            return prev-\>operator [](r);
            }else
            {
            return this;
            }
        }else
        {
        if (next)
            {
            return next-\>operator [](r);
            }else
            {
            return this;
            }
        }
    }
}
</code>
Note
Функция вернет указатель на объект данных цепочки. Функция
может бысть вызвана из любого объекта цепочки. Нумерация
объектов цепочки осуществляется как в массиве с нуля.

Если число будет вне пределов то будет возвращено крайнее
значение.

Функция рекурсивна и имеет определенную опасность в
использовании при неверно замкнутой цепочке.

@@PerexRow::[]@unsigned int &
Description
Функция получения указателя на один из элементов цепочки
C++ Syntax
<code>
PerexRow *  PerexRow::operator [](const unsigned int &amp;r)
{
if (r==ofset)
    {
    return this;
    }else
    {
    if (r\<ofset)
        {
        if (prev)
            {
            return prev-\>operator [](r);
            }else
            {
            return this;
            }
        }else
        {
        if (next)
            {
            return next-\>operator [](r);
            }else
            {
            return this;
            }
        }
    }
}
</code>
Note
Функция вернет указатель на объект данных цепочки. Функция
может бысть вызвана из любого объекта цепочки. Нумерация
объектов цепочки осуществляется как в массиве с нуля.

Если число будет вне пределов то будет возвращено крайнее
значение.

Функция рекурсивна и имеет определенную опасность в
использовании при неверно замкнутой цепочке.

@@InstrumRow::InstrumRow@cSQL *@unsigned __int64 &@String &@int &@String &@String &@lnk
Description
Конструктор для создания класса из данных полученных извне.
C++ Syntax
<code>
     InstrumRow::InstrumRow(cSQL *db,const unsigned __int64 &amp;_OpID,const int &amp;_row,
                        const String &amp;_kod,
                        const String &amp;_Text,
                        lnk _prev):DB(db),prev(0),next(0),ofset(0)
{
count++;
OpID=_OpID;
row=_row;
kod=_kod;
Text=_Text;
//встраивание звена в цепь
if (_prev)
    {          //создается рядовой узел
    prev=_prev;
    // эффект встраивания в цепь
    next=prev-\>next;
    prev-\>next=this;
    if (next)
        {
        next-\>prev=this;
        }
    }
Upd_Ofset();
if (row!=ofset+1)
    {
    action="upd";
    }else
    {
    action="no";
    }
if (!row)
    {
    action="ins";
    }
}
</code>
Type Parameters
db :     Указатель на класс для рабоы с базой банных.
_OpID :  Ссылка на идентификатор операции.
_row :   Номер строки в базе данных
_kod :   Код инструмента
_Text :  Текст прехода
_prev :  Указатель на предыдущее звено цепочки

@@InstrumRow::InstrumRow@cSQL *@unsigned __int64 &@int &@String &@String &@lnk
Description
Конструктор для репликации и размножения цепочки
C++ Syntax
<code>
     InstrumRow::InstrumRow(cSQL *db,const unsigned __int64&amp; _OpID,const String &amp;_action, const int &amp;_row,
                        const String &amp;_kod,
                        const String &amp;_Text,
                        lnk  _prev):DB(db),prev(0),next(0),ofset(0)
{   //репликатор вставки
count++;
action=_action;
OpID=_OpID;
kod=_kod;
Text=_Text;
if (action=="ins")
    {
    row=0;
    }else
    {
    row=_row;
    }
//встраивание звена в цепь
if (_prev)
    {          //создается рядовой узел
    prev=_prev;
    // эффект встраивания в цепь
    next=prev-\>next;
    prev-\>next=this;
    if (next)
        {
        next-\>prev=this;
        }
    }
Upd_Ofset();
}
</code>

Type Parameters
db :       Указатель на класс для работы с базой данной
_OpID :    Ссылка на идентификатор операции
_action :  Ссылка на индикатор действия
_row :     Ссылка на позицию строки в базе
_kod :     Ссылка на код инструмента
_Text :    Ссылка на текст для сохранения в базу данных
_prev :    Указатель на предыдущее звено цепочки.

@@InstrumRow::Upd_Ofset
Description
Фукция коррекции порядкового номера
C++ Syntax
<code>
void         InstrumRow::Upd_Ofset        (void)
{
for (lnk  i=this; i; i=i-\>next)
    {
    if (i-\>prev)
        {
        i-\>ofset=i-\>prev-\>ofset+1;
        }else
        {
        i-\>ofset=0;
        }
    if (i-\>ofset+1!=i-\>row&amp;&amp;i-\>action!="ins"&amp;&amp;i-\>action!="del") {i-\>action="upd";}
    }
}
</code>


@@InstrumRow::Del_subline@lnk &@int@int
Description
Функция для удаления части цепочки в том числе и из базы.
C++ Syntax
<code>
void        InstrumRow::Del_subline     (lnk &amp;r,int pos,int _count)
{//удалять только с пометкой ins остальным пометку del
    //проверка позиции
int cnt=this-\>Count();
r=0;
if (cnt\>pos)
    {
    lnk node=this-\>operator [](pos);
    for (int i=0; i\<_count&amp;&amp;node; i++)
        {
         if (node-\>action=="ins")
            {
            if (node-\>next)
                {// рядовой механизм перехода
                node=node-\>next;
                delete node-\>prev;
                }else
                {
                if (node-\>prev)
                    {//нужен если цикл дойдет до последнего элемента который нужно удалить
                    node=node-\>prev;
                    delete node-\>next;
                    }else
                    {//если удаляется единственных элемент
                    delete node;
                    node=0;
                    r=0;
                    }
                }
            }else
            {
            r=node;
            node-\>action="del";
            node=node-\>next;
            }
        }
    if (node)
        {
        r=node-\>Get_First();
        }else
        {
        if (r)
            {
            r=r-\>Get_First();
            }
        } // установка связи с базовым классом для обновления указателя за который прицеплена цепь
    if (r){r-\>Push_Back_Deleted();}
    }
}
</code>
Type Parameters
r :       ссылка на указатель в базовом классе
pos :     позиция первой удаляемой строки
_count :  количество удаляемых строк

@@InstrumRow::Insert_line@int@lnk
Description
Функция для вставки одной цепочки в другую. Возвращает
указатель на новый начальный узел цепочки.
C++ Syntax
<code>
InstrumRow *  InstrumRow::Insert_line        (int pos,lnk  line_item)
{
lnk first_line_item=line_item-\>Get_First();  //получение указателя первого звена вставляемой цепочки
lnk first_item=Get_First();           //получение указателя первого звена текущей цепочки
if (first_line_item!=first_item)                 //проверка факта вставки цепочки самой в себя (закольцовывание). Чтобы исключить этот феномен
    {
    //выяснение позиции вставки
    int _count=this-\>Count();                 //получение количества звеньев в цепочке
    if (_count\<pos)                          //проверка выхода позиции за пределы цепочки.
        {
        pos=_count;                         //установка позиции на последний элемент цепочки (произойдет достраивание в конец цепочки)
        }
    if (pos\<0)                          //проверка выхода позиции за пределы цепочки.
        {
        pos=0;                         //установка позиции на первый элемент цепочки (произойдет встраивание в цепочку перед нулевым элементом)
        }
    lnk section=this-\>operator [](pos);
    lnk tmp=first_line_item;
    //сканирование и адаптация цепочки
    while (tmp)
        {
        if (tmp-\>action!="del")
            {
            tmp-\>OpID=section-\>OpID;
            tmp-\>action="ins";
            tmp-\>row=0;
            }else
            {
            delete tmp;
            }
        tmp=tmp-\>next;
        }
    lnk last_line_item=line_item-\>Get_Last();
    //сцепка цепочек
    if (_count!=pos)
        {  //сцепка к указанному узлу сзади
        first_line_item-\>prev=section-\>prev;
        if (section-\>prev)
            {
            section-\>prev-\>next=first_line_item;
            }
        section-\>prev=last_line_item;
        last_line_item-\>next=section;
        }else
        {  //сцепка к указанному узлу спереди
        last_line_item-\>next=section-\>next;
        if (section-\>next)
            {
            section-\>next-\>prev=last_line_item;
            }
        section-\>next=first_line_item;
        first_line_item-\>prev=section;
        }
    //переписывание позиций массива
    first_item=Get_First();
    first_item-\>Upd_Ofset();
    }
return first_item;
}
</code>
Type Parameters
pos :        Позиция
line_item :  Указатель на вставляемую цепочку данных
Note
Вставляются только элементы цепочки не помеченные меткой
"del"

При вставке цепочки происходит замена идентификатора операции
и обновление метки дейяствияч на "ins"

@@InstrumRow::Get_Next
Description
Функция доступа для получения указателя на следующее звено
цепочки.
C++ Syntax
<code>
    InstrumRow *     Get_Next    (void) {return next;};
</code>

@@InstrumRow::Get_Prev
Description
Функция доступа для получения указателя на предыдущее звено
цепочки.
C++ Syntax
<code>
    InstrumRow *     Get_Prev    (void) {return prev;};
</code>

@@InstrumRow::isUsed@const
Description
Функция для определения возможности использовать строку
C++ Syntax
<code lang="c++">
bool isUsed  (void)const{return  (action!="del")?true:false;};
</code>

@@InstrumRow::Set_Next@lnk
Description
Функция для управления указателями на соседние звенья цепочки
C++ Syntax
<code lang="c++">
lnk          Set_Next(lnk r){next=r;};
</code>

@@InstrumRow::Set_Prev@lnk
Description
Функция для управления указателями на соседние звенья цепочки
C++ Syntax
<code>
lnk          Set_Prev(lnk r){prev=r;};
</code>

@@InstrumRow::Push_Back_Deleted
Description
функция перемещения удаленных строк в конец цепочки
C++ Syntax
<code lang="c++">
void InstrumRow::Push_Back_Deleted (void)
{
int i=0,count=Count(),ps=count;
lnk item=Get_First();
while (i\<count)
    {// переход по номерам элементов для нахлждения
    lnk node=item-\>operator [](i);
    if (node-\>action=="del")
        {//метка найдена нужно определить их количество подрят
        int c=1;
        lnk snod=node;
        while (snod-\>next&amp;&amp;snod-\>next-\>action=="del")
            {
            snod=snod-\>next;
            c++;
            }
        node-\>Move_items(node-\>ofset,c,ps);
        count-=c;
        }else
        {
        i++;
        }
    }
}
</code>

@@InstrumRow::lnk
Description
Замена конкретного типа данных на универсальное обозначение
для типовой структуры функций класса
C++ Syntax
<code lang="c++">
typedef InstrumRow * lnk ;
</code>

@@InstrumRow::c_lnk
Description
Замена конкретного типа данных на универсальное обозначение
для типовой структуры функций класса
C++ Syntax
<code>
typedef const InstrumRow * c_lnk;
</code>

@@PerexRow::PerexRow@cSQL *@unsigned __int64 &@int &@String &@lnk
Description
Конструктор для создания класса из данных полученных извне.
C++ Syntax
<code>
     PerexRow::PerexRow(cSQL *db,const unsigned __int64 &amp;_OpID,const int &amp;_row,
                        const String &amp;_Text,lnk _prev):DB(db),prev(0),next(0),ofset(0)
{
count++;
OpID=_OpID;
row=_row;
Text=_Text;
//встраивание звена в цепь
if (_prev)
    {          //создается рядовой узел
    prev=_prev;
    // эффект встраивания в цепь
    next=prev-\>next;
    prev-\>next=this;
    if (next)
        {
        next-\>prev=this;
        }
    }
if (row!=ofset+1)
    {
    action="upd";
    }else
    {
    action="no";
    }
if (!row)
    {
    action="ins";
    }
Upd_Ofset();
}
</code>
Type Parameters
db :     Указатель на класс для рабоы с базой банных.
_OpID :  Ссылка на идентификатор операции.
_row :   Номер строки в базе данных
_Text :  Текст прехода
_prev :  Указатель на предыдущее звено цепочки

@@PerexRow::PerexRow@cSQL *@unsigned __int64 &@String &@int &@String &@lnk
Description
Конструктор для репликации и размножения цепочки
C++ Syntax
<code>
     PerexRow::PerexRow(cSQL *db,const unsigned __int64 &amp;_OpID,const String &amp;_action, const int &amp;_row,
                        const String &amp;_Text,
                        lnk _prev):DB(db),prev(0),next(0),ofset(0)
{   //репликатор вставки
count++;
action=_action;
OpID=_OpID;
Text=_Text;
if (action=="ins")
    {
    row=0;
    }else
    {
    row=_row;
    }
//встраивание звена в цепь
if (_prev)
    {          //создается рядовой узел
    prev=_prev;
    // эффект встраивания в цепь
    next=prev-\>next;
    prev-\>next=this;
    if (next)
        {
        next-\>prev=this;
        }
    }
Upd_Ofset();
}
</code>
Type Parameters
db :       Указатель на класс для работы с базой данной
_OpID :    Ссылка на идентификатор операции
_action :  Ссылка на индикатор действия
_row :     Ссылка на позицию строки в базе
_Text :    Ссылка на текст для сохранения в базу данных
_prev :    Указатель на предыдущее звено цепочки.

@@PerexRow::Upd_Ofset
Description
Фукция коррекции порядкового номера
C++ Syntax
<code lang="c++">
void         PerexRow::Upd_Ofset        (void)
{
for (lnk i=this; i; i=i-\>next)
    {
    if (i-\>prev)
        {
        i-\>ofset=i-\>prev-\>ofset+1;
        }else
        {
        i-\>ofset=0;
        }
    if (i-\>ofset+1!=i-\>row&amp;&amp;i-\>action!="ins"&amp;&amp;i-\>action!="del") {i-\>action="upd";}
    }
}
</code>

@@PerexRow::ChangeOpID@unsigned __int64 &@lnk &@bool
Description
Функция для замены идентификатора операции в цепочке
инструмента
C++ Syntax
<code lang="c++">
void PerexRow::ChangeOpID    (unsigned __int64 &amp;_OpID,lnk &amp;r,bool no_del)
{
lnk Item=Get_First();
lnk Last_Item=0;
while (Item)
    {
    Last_Item=Item;
    if (Item-\>action!="del")
        {//замена  ид
        if (Item-\>OpID!=_OpID)
            {
            Item-\>OpID=_OpID;
            Item-\>action="ins";
            }
        Item=Item-\>next;
        }else
        {//удаление помеченных на удаление
        if (no_del)
            {
            if (Item-\>next)
                {
                Item=Item-\>next;
                delete Item-\>prev;
                }else
                {
                if (Item-\>prev)
                    {
                    Item=Item-\>prev;
                    delete Item-\>next;
                    }else
                    {
                    delete Item;
                    Item=0;
                    Last_Item=0;
                    }
                }
            }
        }
    }
if (Last_Item)//возврат указателя на начало цепочки
    {
    r=Last_Item-\>Get_First();
    }
    else
    {
    r=0;
    }
}
</code>
Type Parameters
_OpID :   Новый идентификатор операции
r :       ссылка на указатель в базовом классе
no_del :  триггер для удаления строк помеченых на удаление

@@PerexRow::Del_subline@lnk &@int@int
Description
Функция для удаления части цепочки в том числе и из базы.
C++ Syntax
<code>
void        PerexRow::Del_subline     (lnk &amp;r,int pos,int _count)
{//удалять только с пометкой ins остальным пометку del
    //проверка позиции
int cnt=this-\>Count();
if (cnt\>pos)
    {
    lnk node=this-\>operator [](pos);
    for (int i=0; i\<_count&amp;&amp;node; i++)
        {
         if (node-\>action=="ins")
            {
            if (node-\>next)
                {// рядовой механизм перехода
                node=node-\>next;
                delete node-\>prev;
                }else
                {
                if (node-\>prev)
                    {//нужен если цикл дойдет до последнего элемента который нужно удалить
                    node=node-\>prev;
                    delete node-\>next;
                    }else
                    {//если удаляется единственных элемент
                    delete node;
                    r=0;
                    }
                }
            }else
            {
            node-\>action="del";
            node=node-\>next;
            }
        }
    r=node; // установка связи с базовым классом для обновления указателя за который прицеплена цепь
    if (r)
        {
        r-\>Push_Back_Deleted();
        }
    }
}
</code>
Type Parameters
r :       ссылка на указатель в базовом классе
pos :     позиция первой удаляемой строки
_count :  количество удаляемых строк

@@PerexRow::Insert_line@int@lnk
Description
Функция для вставки одной цепочки в другую. Возвращает
указатель на новый начальный узел цепочки.
C++ Syntax
<code>
PerexRow*     PerexRow::Insert_line    (int pos,lnk line_item)
{
lnk first_line_item=line_item-\>Get_First();  //получение указателя первого звена вставляемой цепочки
lnk first_item=Get_First();           //получение указателя первого звена текущей цепочки
if (first_line_item!=first_item)                 //проверка факта вставки цепочки самой в себя (закольцовывание). Чтобы исключить этот феномен
    {
    //выяснение позиции вставки
    int _count=this-\>Count();                 //получение количества звеньев в цепочке
    if (_count\<pos)                          //проверка выхода позиции за пределы цепочки.
        {
        pos=_count;                         //установка позиции на последний элемент цепочки (произойдет достраивание в конец цепочки)
        }
    if (pos\<0)                          //проверка выхода позиции за пределы цепочки.
        {
        pos=0;                         //установка позиции на первый элемент цепочки (произойдет встраивание в цепочку перед нулевым элементом)
        }
    lnk section=this-\>operator [](pos);
    lnk tmp=first_line_item;
    //сканирование и адаптация цепочки
    while (tmp)
        {
        if (tmp-\>action!="del")
            {
            tmp-\>OpID=section-\>OpID;
            tmp-\>action="ins";
            tmp-\>row=0;
            }else
            {
            delete tmp;
            }
        tmp=tmp-\>next;
        }
    lnk last_line_item=line_item-\>Get_Last();
    //сцепка цепочек
    if (_count!=pos)
        {  //сцепка к указанному узлу сзади
        first_line_item-\>prev=section-\>prev;
        if (section-\>prev)
            {
            section-\>prev-\>next=first_line_item;
            }
        section-\>prev=last_line_item;
        last_line_item-\>next=section;
        }else
        {  //сцепка к указанному узлу спереди
        last_line_item-\>next=section-\>next;
        if (section-\>next)
            {
            section-\>next-\>prev=last_line_item;
            }
        section-\>next=first_line_item;
        first_line_item-\>prev=section;
        }
    //переписывание позиций массива
    first_item=Get_First();
    first_item-\>Upd_Ofset();
    }
return first_item;
}
</code>
Type Parameters
pos :        Позиция
line_item :  Указатель на вставляемую цепочку данных
Note
Вставляются только элементы цепочки не помеченные меткой
"del"

При вставке цепочки

@@PerexRow::isUsed@const
Description
Функция для определения возможности использовать строку
C++ Syntax
<code>
bool isUsed  (void)const{return  (action!="del")?true:false;};
</code>

@@PerexRow::Push_Back_Deleted
Description
функция перемещения удаленных строк в конец цепочки
C++ Syntax
<code>
void PerexRow::Push_Back_Deleted (void)
{
int i=0,count=Count(),ps=count;
lnk item=Get_First();
while (i\<count)
    {// переход по номерам элементов для нахлждения
    lnk node=item-\>operator [](i);
    if (node-\>action=="del")
        {//метка найдена нужно определить их количество подрят
        int c=1;
        lnk snod=node;
        while (snod-\>next&amp;&amp;snod-\>next-\>action=="del")
            {
            snod=snod-\>next;
            c++;
            }
        node-\>Move_items(node-\>ofset,c,ps);
        count-=c;
        }else
        {
        i++;
        }
    }
}
</code>

@@PerexRow::Set_Next@lnk
Description
Функция для управления указателями на соседние звенья цепочки
C++ Syntax
<code>
lnk          Set_Next(lnk r){next=r;};
</code>

@@PerexRow::Set_Prev@lnk
Description
Функция для управления указателями на соседние звенья цепочки
C++ Syntax
<code>
lnk          Set_Prev(lnk r){prev=r;};
</code>

@@PerexRow::c_lnk
Description
Замена конкретного типа данных на универсальное обозначение
для типовой структуры функций класса
C++ Syntax
<code>
typedef const InstrumRow * c_lnk;
</code>

@@PerexRow::lnk
Description
Замена конкретного типа данных на универсальное обозначение
для типовой структуры функций класса
C++ Syntax
<code>
typedef InstrumRow * lnk ;
</code>

@@Replace@String@String@String@int@int
Description
Функция замены одной комбинации символов на другую ()
C++ Syntax
<code>
String Replace (String st,String Old,String New,int pos,int count)
{
int i,cnt=0;
String sub;
for (i=pos; i \<=st.Length()&amp;&amp;cnt\<count; i++)
    {
    sub=st.SubString(i,Old.Length());
    if (sub==Old)
        {
        st.Delete(i,Old.Length());
        st.Insert(New,i);
        i+=New.Length()-1;
        cnt++;
        }
    }
return st;
}
</code>

Type Parameters
st :     Исходная строка
Old :    старая комбинация символов
New :    новая комбанация символов
pos :    позиция начала поиска
count :  количество допустимых замен

@@TSearch::ImageList1
Description
Контейнер с иконками для контекстного меню

@@TSearch::PAB
\ \ 
Description
контекстное меню

@@TSearch::N2
Description
Команда вызова дерева спецификации

@@TSearch::N17
Description
Подменю "технология"

@@TSearch::N1
Description
Команда для открытия технологии в новой вкладке

@@TSearch::N25
Description
Команда для открытия техноголии для просмотра в текущей
вкладке просмотра

@@TSearch::N24
Description
Команда для открытия техноголии для редактирования в новой
вкладке

@@TSearch::N31
Description
Команда для открытия техноголии для редактирования в текущей
вкладке просмотра

@@TmForm::AddTexTab@TPageControl *@Obd *
Description
Функция добавления новой вкладки с технологией
C++ Syntax
<code lang="c++">
void     TmForm::AddTexTab            (TPageControl *Page,Obd *Det)
{
static i=0;
TTechWnd *TechWnd;
TTabSheet *tab;
TechTab *t=new TechTab();
tab=new TTabSheet(this);//создание щита
tab-\>ImageIndex=1;
tab-\>PageControl=Page;//прикрепление щита
//создание эелемента
 TechWnd=new TTechWnd(this,tab,"TechEdit"+String(++i),UserID,DB);
//регистрация щита и дерева
t-\>tab=tab;
t-\>module=TechWnd;
t-\>last_tab=false;
Tabs.push_back((Tab*)t);
SetLastTab(tab);
tab-\>Show();
//занесение первичных данных в технологию
if (Det)
    {
    ((ClassConnector*)TechWnd)-\>Load_sel(Det);
    }
}
</code>

Type Parameters
Page :  Указатель на место расположение вкладки
Det :   Указатель на объект данных загружаемой детали/узла

@@TmForm::LoadTexToCurrTab@Obd *
Description
Функция загрузки технологии в существующую вкладку
C++ Syntax
<code>
void     TmForm::LoadTexToCurrTab    (Obd *Det)
{
Tab *t=GetTab(GetLastTab(1));
if (t)
    {//найдена последняя таба
    ((ClassConnector*)(((TechTab*)t)-\>module))-\>Load_sel(Det);
    t-\>tab-\>Show();
    }else
    {
    AddTexTab(RightPC,Det);
    }
// поиск последней табы с технологией и обращение к ней если нет табы то создать новую
}
</code>

Type Parameters
Det :  Указатель на объект данных загружаемой детали/узла


@@TSearch::AddTexTab
Description
Указатель на функцию открытия выбранного элемента в редакторе
технологий

@@TSearch::LoadTexToCurrTab
Description
Указатель на функцию открытия выбранного элемента в редакторе
технологий

@@TSearch::AddTexViewTab
Description
Указатель на функцию открытия выбранного элемента в просмотре
технологий

@@TSearch::LoadexViewToCurrTab
Description
Указатель на функцию открытия выбранного элемента в просмотре
технологий

@@TSearch::N2Click@TObject *
Description
Вызов функции открытия спецыфикации на выбранный элемент
C++ Syntax
<code lang="c++">
void __fastcall TSearch::N2Click(TObject *Sender)
{
TTreeView *tv=0;
if (MainTree-\>Focused()) {tv=MainTree;}
if (SupportTree-\>Focused()) {tv=SupportTree;}
if (tv)
    {
    if (tv-\>Selected)
        {
        Obd *data=(Obd *)tv-\>Selected-\>Data;
        if (data)
            {
            OpenTree(data);
            }
        }
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TSearch::TechAction@TObject *
Description
функция управления загрузки технологии из окна поиска
C++ Syntax
<code lang="c++">
void __fastcall TSearch::TechAction(TObject *Sender)
{
TTreeNode *node=0;
if (MainTree-\>Focused())
    {
    node=MainTree-\>Selected;
    }
if (SupportTree-\>Focused())
    {
    node=SupportTree-\>Selected;
    }
if (node)
    {
    //объект
    TMenuItem *m=(TMenuItem *)Sender;
    Obd *bag=(Obd*)node-\>Data;
    Obd *det=new Obd(*bag);
    switch (m-\>Tag)
        {
        case 1:{AddTexTab(det);break;}     //редактировать новая вкладка
        case 0:{LoadTexToCurrTab(det);break;}           //редактировать текущая вкладка
        case 3:{AddTexViewTab(det);break;}//просмотр новая вкладка
        case 2:{LoadexViewToCurrTab(det);break;}        //просмотр текущая вкладка
        default:break;
        }
    bag-\>UpdateVal();
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию

@@TechTab::CanClose
Description
Функция, сообщающая можно уничтожать вкладку или нет

@@TechViewTab::CanClose
Description
Функция, сообщающая можно уничтожать 

@@TreeTab::CanClose
Description
Функция, сообщающая можно уничтожать 

@@SearchTab::CanClose
Description
Функция, сообщающая можно уничтожать 

@@Tab::CanClose
Description
Функция, сообщающая можно уничтожать 

@@TSpTree::SpMaster@TObject *
Description
Функция для вызова модуля управдения спецификацией.
Обработчик нажатия команды меню
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::SpMaster(TObject *Sender)
{
/*    switch (m-\>Tag)
{
case 0:{break;}     //добавить
case 1:{break;}     //редактировать
case 2:{break;}        //просмотр
default:break;
} */
bool start=false;
TMenuItem *m=(TMenuItem *)Sender;
String obd="";
if (Tree-\>Selected)
    {
    Obd *row=(Obd*)Tree-\>Selected-\>Data;
    if (row)
        {
        obd=row-\>Get_Obd(false);
        start=true;
        }
    }
if (!m-\>Tag)
    {
    start=true;
    }
if (start)
    {
    TSPEditor *wnd=new TSPEditor(this,DB,LUser,m-\>Tag,obd);
    wnd-\>ShowModal();
    delete wnd;
    }
}
</code>
Type Parameters
Sender :  Указатель на объект вызвавший функцию



@@TSearch::TSearch@TComponent*@TWinControl *@int &@cSQL *@IconsData *@int &@void *@void*@void*@void*@void*
Description
Конструктор
C++ Syntax
<code>
__fastcall TSearch::TSearch(TComponent* Owner,TWinControl *_p, int &amp;_LUser,cSQL *db,IconsData *_IcoData,int &amp;_selected,void *_OpenTree,void* _AddTexTab,
    void* _LoadTexToCurrTab,void* _AddTexViewTab,void* _LoadexViewToCurrTab)
    \: TFrame(Owner),LUser(_LUser),selected(_selected);
{
if (count==0)
    {
    DB=db;
    IcoData=_IcoData;
    }
count++;
// расположение
Align=alClient;
Parent=_p;
Name=Name+String(count);
//инициализация
Combo-\>Items-\>Clear();
String sql="select idsost,name from administration.conditions order by idsost";
TADOQuery *rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    Combo-\>Items-\>AddObject("Все",(TObject *)-1);
    for (rez-\>First(); !rez-\>Eof; rez-\>Next())
        {
        Combo-\>Items-\>AddObject(rez-\>FieldByName("name")-\>Value,(TObject *)rez-\>FieldByName("idsost")-\>Value.operator int());
        }
    }
Combo-\>ItemIndex=0;
//деревья
MainTree-\>Images=IcoData-\>GetImgList();
MainTree-\>StateImages=IcoData-\>GetStateList();
SupportTree-\>Images=IcoData-\>GetImgList();
SupportTree-\>StateImages=IcoData-\>GetStateList();
//функция возврата
OpenTree=(void (*)(Obd *det))_OpenTree;
//функции указатели
AddTexTab=Tech(_AddTexTab);
AddTexViewTab=Tech(_AddTexViewTab);
LoadTexToCurrTab=Tech(_LoadTexToCurrTab);
LoadexViewToCurrTab=Tech(_LoadexViewToCurrTab);
if (Parent-\>ClassNameIs("TTabSheet"))
    {
    ((TTabSheet*)Parent)-\>Caption="Поиск     ";
    }
//инициализация в меню
delete rez;
sql="SELECT a.SpView,a.TehRead,a.TehEdit,a.NormEdit FROM administration.privileges a inner join administration.logins b on b.LogID='"+String(LUser)+"' and b.Levelacss=a.GroupID";
rez=DB-\>SendSQL(sql);
if (rez&amp;&amp;rez-\>RecordCount)
    {
    SpView=rez-\>FieldByName("SpView")-\>Value.operator bool();
    TehRead=rez-\>FieldByName("TehRead")-\>Value.operator bool();
    TehEdit=rez-\>FieldByName("TehEdit")-\>Value.operator bool();
    NormEdit=rez-\>FieldByName("NormEdit")-\>Value.operator bool();
    //
    N2-\>Enabled=SpView;
    //
    N25-\>Enabled=false;//TehRead;
    N1-\>Enabled=false;//TehRead;
    //
    N31-\>Enabled=TehEdit+NormEdit+TehRead;
    N24-\>Enabled=TehEdit+NormEdit+TehRead;
    }
delete rez;

}
</code>
Type Parameters
Owner :                 Указатель на компонент создавший
                        экземпляр класса
_p :                    Указатель на контейнер для отображения
                        модуля.
_LUser :                Ссылка на идентификатор пользователя,
                        работающего с программой
db :                    Указатель на класс для работы с базой
                        данных
_IcoData :              Указатель на класс для работы с
                        изображениями
_selected :             Ссылка на переменную с текущим
                        выбраным элементом
_OpenTree :             Ссылка на функцию для отправки команды
                        на загрузку спецификации в дерево
_AddTexTab :            Ссылка на функцию для отправки команды
                        на загрузку технологии в новой вкладке
_LoadTexToCurrTab :     Ссылка на функцию для отправки команды
                        на загрузку технологии в текущей
                        вкладке
_AddTexViewTab :        Ссылка на функцию для отправки команды
                        на загрузку технологии для просмотра в
                        новой вкладке
_LoadexViewToCurrTab :  Ссылка на функцию для отправки команды
                        на загрузку технологии для просмотра в
                        текущей вкладке

@@TSpTree::TSpTree@TComponent*@TWinControl *@cSQL *@int &@TMemo *@IconsData *@int &@void*@void*@void*@void*
Description
Конструктор.
C++ Syntax
<code>
__fastcall         TSpTree::TSpTree(TComponent* Owner,TWinControl *_p,cSQL *db,const int &amp;_LUser,TMemo *m,IconsData *_IcoData,int &amp;_selected,void* _AddTexTab,
    void* _LoadTexToCurrTab,void* _AddTexViewTab,void* _LoadexViewToCurrTab)
    \: TFrame(Owner),LUser(_LUser),selected(_selected)
{
// получить список доступных компонентов и сделать не активными не доступные

if (count==0)
    {
    DB=db;
    IcoData=_IcoData;
    }
Selector=new TObdSelector(this,(ClassConnector*)this,Panel3,db);
//функции указатели
AddTexTab=Tech(_AddTexTab);
AddTexViewTab=Tech(_AddTexViewTab);
LoadTexToCurrTab=Tech(_LoadTexToCurrTab);
LoadexViewToCurrTab=Tech(_LoadexViewToCurrTab);
// расположение
Align=alClient;
Parent=_p;
Name=Name+String(count);
memo=m;
Init();
Tree-\>Images=IcoData-\>GetImgList();
Tree-\>StateImages=IcoData-\>GetStateList();
count++;
MassAction=false;
N10-\>Checked=!MassAction;
N9-\>Checked=MassAction;
if (Parent-\>ClassNameIs("TTabSheet"))
    {
    ((TTabSheet*)Parent)-\>Caption="Спецификация     ";
    }
}
</code>

Type Parameters
Owner :                 Указатель на компонент хозяни для
                        данного компонена
_p :                    Указатель на объект в составе которого
                        отображается компонент
db :                    Указатель на класс для раюоты с базой
                        данных
_LUser :                Ссылка на идентификатор пользователя
m :                     Указатель на объект класса TMemo для
                        вывода детальной информации по
                        выделенному узлу/детали
_IcoData :              Указатель на класс для работы с
                        контейнерами изображений
_selected :             Ссылка на идентификатор выделенного
                        узла
_AddTexTab :            Ссылка на функцию\-команду загрузки
                        технологии. (редактирование в новой
                        вкладке)
_LoadTexToCurrTab :     Ссылка на функцию\-команду загрузки
                        технологии. (редактирование в текущей
                        вкладке)
_AddTexViewTab :        Ссылка на функцию\-команду загрузки
                        технологии. (просмотр в новой вкладке)
_LoadexViewToCurrTab :  Ссылка на функцию\-команду загрузки
                        технологии.(просмотр в текущей
                        вкладке)

@@TSpTree::TreeClick@TObject *
Description
Обработчик клика в обрасти дерева. Отправляет в переменную
выбора идентификатор выбранного узла
C++ Syntax
<code lang="c++">
void __fastcall TSpTree::TreeClick(TObject *Sender)
{
TTreeView *tv=(TTreeView *)Sender;
if (tv&amp;&amp;tv-\>Selected)
    {
    Obd *det=(Obd *)tv-\>Selected-\>Data;
    if (det&amp;&amp;det-\>CanUse())
        {
        selected=det-\>Get_ID();
        }
    }
}
</code>
Type Parameters
Sender :  Указатель на обект вызвавший функцию

@@TSearch::TreeClick@TObject *
Description
Обработчик клика в обрасти дерева. Отправляет в переменную
выбора идентификатор выбранного узла
C++ Syntax
<code>
void __fastcall TSearch::TreeClick(TObject *Sender)
{
TTreeView *tv=(TTreeView *)Sender;
if (tv&amp;&amp;tv-\>Selected)
    {
    Obd *det=(Obd *)tv-\>Selected-\>Data;
    if (det&amp;&amp;det-\>CanUse())
        {
        selected=det-\>Get_ID();
        }
    }
}
</code>
Type Parameters
Sender :  Указатель на обект вызвавший функцию

@@cExcel
Description
Класс для управления оле функциями для работы с екселем

@@cExcel::cExcel
Description
Конструктор
C++ Syntax
<code lang="c++">
        cExcel::cExcel            ()
{
}
</code>

@@cExcel::~cExcel
Description
Деструктор
C++ Syntax
<code lang="c++">
        cExcel::~cExcel            ()
{
}
</code>

@@cExcel::App
Description
Variant - переменная для управления экземпляром Excel

@@cExcel::Book
Description
Variant - переменная для управления одной из открытых книг

@@cExcel::Books
Description
Variant - переменная массив открытых книг

@@cExcel::Sheet
Description
Variant - переменная для управления одним из листов книги

@@cExcel::Sheets
Description
Variant - переменная массив листов открытой книги

@@cExcel::Book_Close@Variant
Description
Закрывает указанную книгу
C++ Syntax
<code lang="c++">
bool     cExcel::Book_Close      (Variant Book)
{
if (!Book.intVal){return false;}
try
    {
    Books.OleProcedure("Close");
    return true;
    } catch (...)
    {
    return false;
    }
}
</code>
Type Parameters
Book :  переменная для управления книгой

@@cExcel::Books_New
Description
Создание новой книги.
C++ Syntax
<code lang="c++">
Variant cExcel::Books_New         (void)
{
if (!App.intVal){return 0;}
try
    {
    App.OlePropertyGet("WorkBooks").OleProcedure("Add");
    return App.OlePropertyGet("Workbooks");
    }
catch (...)
    {
    return 0;
    }
}
</code>

@@cExcel::Books_Open@AnsiString
Description
Открытие существующей книги
C++ Syntax
<code lang="c++">
Variant cExcel::Books_Open        (AnsiString url)
{
if (!App.intVal){return 0;}
try
    {
    App.OlePropertyGet("WorkBooks").OleProcedure("Open",url.c_str());    //уточнить  с c_str
    return App.OlePropertyGet("Workbooks");
    }
catch (...)
    {
    return 0;
    }
}
</code>
Type Parameters
url :  Адрес открываемого файла

@@cExcel::GetBook@int
Description
Соединение с книгой по ее номеру в массиве books
C++ Syntax
<code lang="c++">
Variant cExcel::GetBook            (int number)
{
if (!Books.intVal){return 0;}
try
    {
    return Books.OlePropertyGet("Item",number);
    } catch (...)
    {
    return 0;
    }
}
</code>

@@cExcel::Connect
Description
Подключение к серверу приложения Excel
C++ Syntax
<code lang="c++">
bool     cExcel::Connect            (void)
{
try
    {
    App=Variant::CreateObject("Excel.Application");
    return true;
    }
catch (...)
    {
    return false;
    }
}
</code>

@@cExcel::Disconnect
Description
Отключение от сервера приложения Excel
C++ Syntax
<code lang="c++">
bool      cExcel::Disconnect      (void)
{
if (!App.intVal){return false;}
try
    {
    App.OleProcedure("Quit");
    return true;
    }
catch (...)
    {
    return false;
    }
}
</code>

@@cExcel::GetSheets
Description
Получение массива листов книги
C++ Syntax
<code lang="c++">
Variant cExcel::GetSheets        (void)
{
if (!Book.intVal) {return 0;}
try
    {
    return Book.OlePropertyGet("Worksheets");
    } catch (...)
    {
    return 0;
    }
}
</code>

@@cExcel::GetSheetsCount
Description
Получение количества листов в массиве
C++ Syntax
<code lang="c++">
int     cExcel::GetSheetsCount    (void)
{
if (!Sheets.intVal) {return 0;}
try
    {
    return Sheets.OlePropertyGet("Count");
    } catch (...)
    {
    return 0;
    }
}
</code>

@@cExcel::GetSheet@int
Description
Функция для получения контроля над листом книги
C++ Syntax
<code lang="c++">
Variant cExcel::GetSheet        (int number)
{
if (!Sheets.intVal) {return 0;}
try
    {
    return Sheets.OlePropertyGet("Item",number);
    } catch (...)
    {
    return 0;
    }
}
</code>

Type Parameters
number :  номер листа в книге

@@cExcel::Sheet_activate
Description
Функция для активации базовой страницы
C++ Syntax
<code lang="c++">
void     cExcel::Sheet_activate    (void)
{
Sheet_activate    (Sheet);
}
</code>

@@cExcel::Sheet_activate@Variant
Description
Функция для активации страницы подконтрольной входящей
переменной
C++ Syntax
<code lang="c++">
void     cExcel::Sheet_activate    (Variant sheet)
{
if (!Sheets.intVal||!sheet.intVal) {return;}
try
    {
    sheet.OleProcedure("Activate");
    }
catch (...)
    {
    return;
    }
}
</code>
Type Parameters
sheet :  переменная для управления страницей

@@cExcel::Sheet_Copy@Variant@Variant@Variant
Description
Функция для копирования листа
C++ Syntax
<code lang="c++">
void     cExcel::Sheet_Copy        (Variant sheet,Variant before,Variant after)
{
if (!Sheets.intVal||(!before.intVal&amp;&amp;!after.intVal&amp;&amp;!sheet.intVal)) {return;}
try
    {
    Sheet_activate(sheet);
    sheet.OleProcedure("Copy",before,after);
    }
catch (...)
    {
    return;
    }
}
</code>
Type Parameters
sheet :   переменная контроля копируемого листа
before :  переменная контроля листа перед которым нужно
          поместить лист
after :   переменная контроля листа после которого нужно
          поместить лист

@@cExcel::Sheet_Add@Variant@Variant@Variant
Description
функция для создания новых листов в массиве
C++ Syntax
<code lang="c++">
void     cExcel::Sheet_Add        (Variant sheets,Variant before,Variant after)
{
if (!Sheets.intVal||(!before.intVal&amp;&amp;!after.intVal&amp;&amp;!sheets.intVal)) {return;}
try
    {
    sheets.OleProcedure("Add",before,after);
    }
catch (...)
    {
    return;
    }
}
</code>
Type Parameters
sheets :  переменная контроля массива
before :  переменная контроля листа перед которым нужно
          поместить новый лист
after :   переменная контроля листа после которого нужно
          поместить новый лист

@@cExcel::Set_Sheet_Name@Variant@String
Description
Функция для переименования листа.
C++ Syntax
<code lang="c++">
void     cExcel::Set_Sheet_Name    (Variant sheet,String name)
{
if (!Sheets.intVal||!sheet.intVal) {return;}
try
    {
    Sheet_activate(sheet);
    sheet.OlePropertySet("Name",WideString(name));
    }
catch (...)
    {
    return;
    }
}
</code>
Type Parameters
sheet :  переменная управления листом
name :   ноовое название для листа

@@cExcel::Sheet_Del@Variant
Description
функция удаления листа
C++ Syntax
<code lang="c++">
void     cExcel::Sheet_Del        (Variant sheet)
{
if (!sheet.intVal) {return;}
try
    {
    sheet.OleProcedure("Delete");
    }
catch (...)
    {
    return;
    }
}
</code>
Type Parameters
sheet :  переменная управления листом

@@cExcel::DisplayAlerts@bool
Description
Функция для включения/отклюения сообщений пользователю от
Excel
C++ Syntax
<code lang="c++">
void     cExcel::DisplayAlerts    (bool r)
{
if (!App.intVal){return;}
App.OlePropertySet("DisplayAlerts",r);
}
</code>
Type Parameters
r :  логическая переменная для управления поведением функции

@@cExcel::Visible@bool
Description
Функция для управления видимостью пользовалюлю приложения
Excel
C++ Syntax
<code lang="c++">
void     cExcel::Visible            (bool r)
{
if (!App.intVal){return;}
App.OlePropertySet("Visible",r);
}
</code>
Type Parameters
r :  логическая переменная для управления функцией

@@cExcel::toCells@int@int@AnsiString
Description
Функция вывода данных в ячееку
C++ Syntax
<code lang="c++">
void     cExcel::toCells            (int Row,int Col,AnsiString data)         //уточнить  с c_str
{
if (!Sheet.intVal){return;}
Variant cur=Sheet.OlePropertyGet("Cells",Row,Col);
cur.OlePropertySet("Value",data.c_str());
}
</code>
Type Parameters
Row :   Сторока
Col :   Столбец
data :  Данные для вывода

@@cExcel::fromCells@int@int
Description
Функция чтения данных из ячейки
C++ Syntax
<code lang="c++">
Variant cExcel::fromCells        (int Row,int Col)
{
if (!Sheet.intVal){return 0;}
Variant cur=Sheet.OlePropertyGet("Cells",Row,Col);
return cur.OlePropertyGet("Value");
}
</code>
Type Parameters
Row :  строка
Col :  столбец

@@cExcel::GetRange@int@int@int@int
Description
Функция для определения диапазона ячеек для последующих
операций с ними
C++ Syntax
<code lang="c++">
Variant cExcel::GetRange        (int StartRow,int StartCol,int EndRow,int EndCol)
{
if (!Sheet.intVal){return 0;}
return Sheet.OlePropertyGet("Range",Sheet.OlePropertyGet("Cells",StartRow,StartCol),Sheet.OlePropertyGet("Cells",EndRow,EndCol));
}
</code>
Type Parameters
StartRow :  начальная строка
StartCol :  начальный столбец
EndRow :    конечная строка
EndCol :    конечный столбец

@@cExcel::GetColumn@int
Description
Получение контроля над столбцом данных
C++ Syntax
<code lang="c++">
Variant cExcel::GetColumn        (int Col)
{
if (!Sheet.intVal){return 0;}
return Sheet.OlePropertyGet("Columns",Col);
}
</code>
Type Parameters
Col :  номер столбца

@@cExcel::GetRows@int@int
Description
Функция для получения диапазона ячеек путем выбора диапазона
строк в текущем активном листе
C++ Syntax
Variant cExcel::GetRows            (int StartRow,int EndRow)
{
return GetRows(Sheet,StartRow,EndRow);
}
Type Parameters
StartRow :  начальная строка
EndRow :    конечная строка

@@cExcel::GetRows@Variant@int@int
Description
Функция для получения диапазона ячеек путем выбора диапазона
строк в указанном листе


C++ Syntax
<code lang="c++">
Variant cExcel::GetRows            (Variant sheet,int StartRow,int EndRow)
{
if (!sheet.intVal){return 0;}
Sheet_activate(sheet);
Variant rez=sheet.OlePropertyGet("Rows",WideString(IntToStr(StartRow)+":"+IntToStr(EndRow)));
Sheet_activate();
return  rez;
}
</code>
Type Parameters
sheet :     переменная управления листом
StartRow :  Строка начала выделения
EndRow :    Строка окончания выделения

@@cExcel::Range_Merge@Variant
Description
Функция объединения ячеек
C++ Syntax
<code lang="c++">
void     cExcel::Range_Merge        (Variant Range)
{
if (!Range.intVal){return;}
Range.OleProcedure("Merge");
}
</code>

Type Parameters
Range :  диапазон ячеек

@@cExcel::Range_Select@Variant
Description
Функция выделения указанного диапазона ячеек
C++ Syntax
<code lang="c++">
void     cExcel::Range_Select    (Variant Range)
{
if (!Range.intVal){return;}
Range.OleProcedure("Select");
}
</code>

Type Parameters
Range :  диапазон ячеек

@@cExcel::Range_Copy@Variant
Description
Функция копирования указанного диапазона ячеек
C++ Syntax
<code lang="c++">
void     cExcel::Range_Copy      (Variant Range)
{
if (!Range.intVal){return;}
Range.OleProcedure("Copy");
}
</code>

Type Parameters
Range :  диапазон ячеек

@@cExcel::Range_Paste@Variant
Description
Функция вставки указанного диапазона ячеек
C++ Syntax
<code lang="c++">
void     cExcel::Range_Paste     (Variant Range)
{
if (!Range.intVal){return;}
Range_Select(Range);
Sheet.OleProcedure("Paste");
}
</code>
Type Parameters
Range :  диапзон ячеек

@@cExcel::Range_Border@Variant@int@int@int@int
Description
Функция управления видом рамки вокруг ячеек
C++ Syntax
<code lang="c++">
void     cExcel::Range_Border    (Variant Range,int type,int LineStyle,int Weight,int ColorIndex)
{
/*Константы, определяющие где проводить линию:   type
xlInsideHorizontal 12
xlInsideVertical 11
xlDiagonalDown 5
xlDiagonalUp 6
xlEdgeBottom 9
xlEdgeLeft 7
xlEdgeRight 10
xlEdgeTop 8
все внутренние линии 1
все правые линии 2  */

/*Константы стиля линии      LineStyle
xlContinuous 1
xlDash -4115
xlDashDot 4
xlDashDotDot 5
xlDot -4118
xlDouble -4119
xlSlantDashDot 13
xlLineStyleNone -4142  */
/*Толщина линии  int Weight
xlHairline 1
xlMedium -4138
xlThick 4
xlThin 2  */


if (!Range.intVal) {return;}
Range.OlePropertyGet("Borders",type).OlePropertySet("LineStyle",LineStyle);
Range.OlePropertyGet("Borders",type).OlePropertySet("Weight",Weight);
Range.OlePropertyGet("Borders",type).OlePropertySet("ColorIndex",ColorIndex);
}
</code>
Type Parameters
Range :       диапазон ячеек
type :        тип линии (горизонтальная, вертикальная....)
LineStyle :   Стиль линии
Weight :      толщина линии
ColorIndex :  цвет линии

@@cExcel::Range_ColWidth@Variant@int
Description
Функция для управления шириной столбцов указанного диапазонаа
C++ Syntax
<code lang="c++">
void     cExcel::Range_ColWidth    (Variant Range,int width)
{
if (!Range.intVal) {return;}
Range.OlePropertySet("ColumnWidth",width);
}
</code>
Type Parameters
Range :  диапазон ячеек
width :  ширина столбца

@@cExcel::Range_RowHeight@Variant@int
Description
Функция для указания выстоты строки в указанном диапазоне
C++ Syntax
<code lang="c++">
void    cExcel::Range_RowHeight    (Variant Range,int height)
{
if (!Range.intVal) {return;}
Range.OlePropertySet("RowHeight", height);
}
</code>
Type Parameters
Range :   диапазон ячеек
height :  высота строки

@@cExcel::Set_format@Variant@String
Description
Функция для указания формата данных в ячейке
C++ Syntax
\ \ 
Type Parameters
Range :   диапазон ячеек
format :  формат

@@cExcel::HorizontalAlignment@Variant@int
Description
Функция для выравнивания текста по горизонтали
C++ Syntax
<code lang="c++">
void     cExcel::HorizontalAlignment (Variant Range,int type)
{
if (!Range.intVal) {return;}
Range.OlePropertySet("HorizontalAlignment",type);
/*Выравнивание текста - горизонтальное - Константы
xlVAlignBottom = -4107
xlVAlignCenter = -4108
xlVAlignDistributed = -4117
xlVAlignJustify = -4130
xlVAlignTop = -4160 */
}
</code>
Type Parameters
Range :  диапазон ячеек
type :   тип выравнивания

@@cExcel::VerticalAlignment@Variant@int
Description
Функция для вертикального выравнивания текста в ячейках
C++ Syntax
<code lang="c++">
void     cExcel::VerticalAlignment     (Variant Range,int type)
{
if (!Range.intVal) {return;}
Range.OlePropertySet("VerticalAlignment",type);
/*
Выравнивание текста - вертикальное - Константы
xlHAlignCenter -4108
xlHAlignCenterAcrossSelection 7
xlHAlignDistributed -4117
xlHAlignFill 5
xlHAlignGeneral 1
xlHAlignJustify -4130
xlHAlignLeft -4131
xlHAlignRight -4152   */
}
</code>
Type Parameters
Range :  Диапазон ячеек
type :   тип выравнивания

@@cExcel::GetActiveSheet
Description
Функция для передачи контроля над активным листом приложению
C++ Syntax
<code lang="c++">
Variant GetActiveSheet        (void)            {return Sheet;};
</code>

@@cExcel::GetConnection
Description
Функция для передачи контроля над подключенным экземпляром
Excel приложению
C++ Syntax
<code lang="c++">
Variant GetConnection        (void){return App;};
</code>

@@cExcel::GetFirstBook
Description
Передача контроля приложению над первой открытой книгой
C++ Syntax
<code lang="c++">
Variant GetFirstBook        (void)            {return GetBook(1);}
</code>

@@cExcel::GetFirstSheet
Description
Передача контроля приложению над первым листом книги
C++ Syntax
<code>
Variant GetFirstSheet        (void)            {return GetSheet(1);};
</code>

@@cExcel::SetActiveBook@Variant
Description
Функция для указания классу новой книги с которой будут
работать функции по умолчанию
C++ Syntax
<code lang="c++">
void     SetActiveBook        (Variant r){Book=r;};
</code>

@@cExcel::SetActiveBooks@Variant
Description
Функция для указания нового мабора книг с которыми будут
работать функции по умолчанию
C++ Syntax
<code lang="c++">
void     SetActiveBooks        (Variant r){Books=r;};
</code>

@@cExcel::SetActiveConnection@Variant
\ \ 
Description
Указание нового подключения с которым будут работать функции
по умолчанию
C++ Syntax
<code lang="c++">
void     SetActiveConnection    (Variant excel){App=excel;};
</code>

@@cSQL
Description
Класс для работы с базами данных, содержит типичные функции
для работы с базой служит для упрощения кода.

@@cSQL::~cSQL
Description
Деструктор
C++ Syntax
<code lang="c++">
cSQL::~cSQL()
{
delete cmd;
}
</code>

@@cSQL::cSQL@TADOConnection *
Description
Конструктор по умолчанию
C++ Syntax
<code lang="c++">
cSQL::cSQL(TADOConnection * Connection):url(Connection),ReconnectCount(5),cmd(0)
{
//if (cmd) {delete cmd; cmd=0;}
cmd=new TADOCommand(url-\>Owner);
cmd-\>Connection=url;
cmd-\>ParamCheck=false;
try{url-\>Connected=true;} catch (...){}
tables.clear();
}
</code>
Type Parameters
Connection :  указатель на соединение с базой данных

@@cSQL::cSQL@cSQL *
Description
Конструктор копировщик
C++ Syntax
<code lang="c++">
cSQL::cSQL(cSQL * r):url(r-\>GetConnect()),ReconnectCount(r-\>GetReconnectCount())
{
if (cmd) {delete cmd; cmd=0;}
cmd=new TADOCommand(url-\>Owner);
cmd-\>Connection=url;
cmd-\>ParamCheck=false;
tables.clear();
}
</code>
Type Parameters
r :  указатель на другой объект класса

@@cSQL::cmd
Description
Указатель на объект TADOCommand для отправки команд серверу

@@cSQL::ReconnectCount
Description
Максимальное количество попыток переподключения к серверу

@@cSQL::url
Description
Указатель на объект подключения к базе

@@cSQL::tables
\ \ 
Description
Вектор с указателями на тиблицы привязанные к классу

@@cSQL::AddTable@TADOTable *
Description
Функция для подключения таблиц к классу
C++ Syntax
<code lang="c++">
void cSQL::AddTable(TADOTable *table)
{
tables.push_back(table);
}
</code>
Type Parameters
table :  Указатель на таблицу

@@cSQL::DelTable@TADOTable *
Description
Функция для отключения таблиц от класса
C++ Syntax
<code lang="c++">
void cSQL::DelTable(TADOTable *table)
{
for (int i = 0; i \<tables.size(); i++)
    {
    if (tables[i]==table)
        {
        tables.erase(tables.begin()+i);
        }
    }
}
</code>
Type Parameters
table :  указатель на таблицу

@@cSQL::Connect
Description
Функция подключения к базе данных
C++ Syntax
<code lang="c++">
bool cSQL::Connect()
{
if (cmd) {delete cmd; cmd=0;}
if (!url-\>Connected)
    {
    TComponent *tmp=url-\>Owner;
    delete url;
    url=new TADOConnection(tmp);
    url-\>LoginPrompt=false;
    }
cmd=new TADOCommand(url-\>Owner);
cmd-\>Connection=url;
cmd-\>ParamCheck=false;
try{url-\>Connected=true;} catch (...){}
try
{
for (int i = 0; i \<tables.size(); i++)
    {
    tables[i]-\>Active=false;
    tables[i]-\>Connection=url;
    tables[i]-\>Active=true;
    }
}
catch(...){}
return TestConnectoin();
}
</code>

@@cSQL::TestConnectoin@const
Description
Функция для тестирования соединения с базой данных
C++ Syntax
<code lang="c++">
bool cSQL::TestConnectoin() const
{
TADOQuery *test;
test= new TADOQuery(url-\>Owner);
test-\>Connection=url;
try
    {
    test-\>Active=false;
    test-\>SQL-\>Clear();
    test-\>SQL-\>Add("select 1");
    test-\>Active=true;
    delete test;
    return true;
    }
catch (...) {delete test;url-\>Connected=false;return false;}
}
</code>

@@cSQL::CheckConnection
Description
Функция для проверки соединения и попытки переподключения
C++ Syntax
<code lang="c++">
bool cSQL::CheckConnection()
{
if(!TestConnectoin())
    {
    for (int i=0; i\<=ReconnectCount; i++)
        {
        if (Connect()){return true;}
        }
    return false;
    }
return true;
}
</code>

@@cSQL::SendSQL@String &
Description
Функция для выполнения Query запросов в базе данных.
C++ Syntax
<code lang="c++">
TADOQuery * cSQL::SendSQL(const String &amp;request)
{
TADOQuery *query=0;
//if (!CheckConnection()) {delete query;return 0;}   //fox pro не дружит с select 1
/*try
    {  */
    log.push_back(Time().TimeString()+"---"+request);
    query=new TADOQuery(url-\>Owner);
    query-\>ParamCheck=false;
    query-\>Connection=url;
    query-\>Active=false;
    query-\>SQL-\>Clear();
    query-\>SQL-\>Add(request);
    query-\>Active=true;
    return query;
  /*    }
catch (...){delete query;return 0;}     */
}
</code>
Type Parameters
request :  текст запроса

@@cSQL::SendCommand@String &
Description
Функция для выполнения команд базой данных
C++ Syntax
<code lang="c++">
bool cSQL::SendCommand(const String &amp;request)
{
/*if (!CheckConnection())
{return false;}
try
   {     */
    log.push_back(Time().TimeString()+"---"+request);
    cmd-\>CommandText=request;
    cmd-\>Execute();
    return true;
   /*}
catch (...){return false;}*/
}
</code>
Type Parameters
request :  текст команды

@@cSQL::Get_log
Description
Функция для получения списка запросов и команд отправленных
серверу
C++ Syntax
<code lang="c++">
vector \<String\> Get_log(void){return log;};
</code>

@@cSQL::GetConnect@const
Description
Функция для получения указателя на подключение к базе
C++ Syntax
<code lang="c++">
TADOConnection* GetConnect()const {return url;};
</code>

@@cSQL::GetReconnectCount
Description
Функция для получения количества допустимых попыток
переподключения
C++ Syntax
<code lang="c++">
int GetReconnectCount(){return ReconnectCount;};
</code>

@@cSQL::SetConnection@TADOConnection *
Description
Функция для задания указателя на подключение к базе данных
C++ Syntax
<code lang="c++">
void SetConnection (TADOConnection * Connection){url=Connection;};
</code>

@@cSQL::SetReconnectCount@int
Description
Функция для задания количества попыток переподключения к базе
при разрыве соединения
C++ Syntax
<code lang="c++">
void SetReconnectCount(int count){ReconnectCount=count;};
</code>

@@DtInfo
Description
Класс данных, содержащий всю информацию о детали. головной
класс струкруты классов при загрузке технологии

@@DtInfo::~DtInfo
Description
Деструктор
C++ Syntax
<code lang="c++">
     DtInfo::~DtInfo()
{
// удаление связанных цепочек
if (operations)
    {
    operations=operations-\>Get_Last();//движемся с конца к началу цепочки чтобы деструктор не инициализировал пересчет позиций
    while (operations)
        {
        if (operations-\>Get_Next())
            {
            delete operations-\>Get_Next();
            operations-\>Set_Next(0);
            }
        operations=operations-\>Get_Prev();
        }
    }
count--;
}
</code>

@@DtInfo::DtInfo@cSQL *@int@int &
Description
Базовый конструктор
C++ Syntax
<code lang="c++">
     DtInfo::DtInfo(cSQL *db, int _id,const int &amp;_User):DB(db),LUserID(&amp;_User)
{
count++;
//проверка уровня доступа пользователя
TADOQuery *rez=DB-\>SendSQL("Call administration.GetUserAccess('"+(String)*LUserID+"','"+(String)_id+"')");
if (rez&amp;&amp;rez-\>RecordCount)
    {
    LUser=rez-\>FieldByName("UserName")-\>Value;
    access=rez-\>FieldByName("access")-\>Value;
    LoadData(_id);
    }else
    {
    access=false;
    }
delete rez;
}
</code>
Type Parameters
db :     Указатель на класс дл яраты с базой данных
_id :    идентификатор детали
_User :  идентификатор пользователя

@@DtInfo::DtInfo@DtInfo &
Description
Конструктор копировщик
C++ Syntax
<code lang="c++">
     DtInfo::DtInfo(const DtInfo &amp;isx):DB(isx.DB),LUserID(isx.LUserID)
{
count++;
// проверить ниже
id=isx.id;
obm=isx.obm;
ei=isx.ei;
eiName=isx.eiName;
vz=isx.vz;
kdz=isx.kdz;
masd=isx.masd;
masz=isx.masz;
nrm=isx.nrm;
razz=isx.razz;
pm=isx.pm;
napr=isx.napr;
CreateUser=isx.CreateUser;
ChangeUser=isx.ChangeUser;
CreateDate=isx.CreateDate;
ChangeDate=isx.ChangeDate;
operations=new OperRow(*isx.operations);
action=isx.action;
access=false;
LUser=isx.LUser;
}
</code>
Type Parameters
r :  ссылка на другой объект класса

@@DtInfo::LoadData@int
Description
Функция для загрузки данных по детали
C++ Syntax
<code lang="c++">
void DtInfo::LoadData(int _id)
{
TADOQuery *rez=DB-\>SendSQL("Call technologic.GetDetInfo("+String(_id)+")");
if (rez&amp;&amp;rez-\>RecordCount)
    {
    id=rez-\>FieldByName("id")-\>Value;
    ei=rez-\>FieldByName("ei")-\>Value;
    eiName=rez-\>FieldByName("eiName")-\>Value;
    masd=rez-\>FieldByName("masd")-\>Value;
    obm=VinToGost(rez-\>FieldByName("obm")-\>Value);
    obmid=rez-\>FieldByName("obmid")-\>Value;
    vz=rez-\>FieldByName("vz")-\>Value;
    vzName=rez-\>FieldByName("vzName")-\>Value;
    kdz=rez-\>FieldByName("kdz")-\>Value;
    masz=rez-\>FieldByName("masz")-\>Value;
    nrm=rez-\>FieldByName("nrm")-\>Value;
    razz=rez-\>FieldByName("razz")-\>Value;
    pm=rez-\>FieldByName("pm")-\>Value;
    napr=rez-\>FieldByName("napr")-\>Value;
    CreateUser=rez-\>FieldByName("CreateUser")-\>Value;
    ChangeUser=rez-\>FieldByName("ChangeUser")-\>Value;
    CreateDate=rez-\>FieldByName("CreateDate")-\>Value.operator TDateTime();
    ChangeDate=rez-\>FieldByName("ChangeDate")-\>Value.operator TDateTime();
    action="no";
     }else
    {
    id=_id;
    ei=0;
    eiName="";
    masd=0;
    obm="";
    obmid=0;
    vz=0;
    vzName="";
    kdz=0;
    masz=0;
    nrm=0;
    razz="";
    pm="";
    napr="";
    CreateUser="";
    ChangeUser="";
    CreateDate=0;
    ChangeDate=0;
    action="ins";
    }
delete rez;
rez=DB-\>SendSQL("call technologic.GetOperations('"+(String)id+"')");
if (rez&amp;&amp;rez-\>RecordCount)
    {
    OperRow *t=0;
    for (rez-\>First(); !rez-\>Eof; rez-\>Next())
        {
        t=new OperRow(    DB,LUser,
                        rez-\>FieldByName("OpUUID")-\>Value.operator __int64(),
                        "no",
                        rez-\>FieldByName("id")-\>Value.operator int(),
                        rez-\>FieldByName("ktar")-\>Value.operator int(),
                        rez-\>FieldByName("ok69")-\>Value.operator int(),
                        rez-\>FieldByName("cex")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("utch")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("opr")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("oboID")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("OboName")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("OprName")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("OprCode")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("stro")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("tara")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("control")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("ioht")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("CreateUser")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("UpdateUser")-\>Value.operator UnicodeString(),
                        rez-\>FieldByName("CreateDate")-\>Value.operator TDateTime(),
                        rez-\>FieldByName("UpdateDate")-\>Value.operator TDateTime(),
                        t);
        }
    if (t) {operations=t-\>Get_First();}
    }else
    {
    operations=0;
    }
delete rez;
}
</code>
Type Parameters
_id :  Идентификатор детали

@@DtInfo::SaveData
Description
Функция сохранения данных в базе
C++ Syntax
<code lang="c++">
bool DtInfo::SaveData(void)
{
if (!access){return false;}
Get_pm();
bool effect=true;
String sql="",tei=(String)ei,tvz=(String)vz;
while (tei.Length()\<3)
    {
    tei="0"+tei;
    }
while (tvz.Length()\<3)
    {
    tvz="0"+tvz;
    }
if (action=="ins")
    {
    sql="insert into technologic.det_info (id,ei,masd,obmid,vz,kdz,masz,nrm,razz,pm,napr,CreateUser,CreateDate,ChangeUser,ChangeDate)values('"+(String)id+"','"+tei+"','"+Replace((String)masd,",",".")+"','"+(String)obmid+"','"+tvz+"','"+(String)kdz+"','"+Replace((String)masz,",",".")+"','"+Replace((String)nrm,",",".")+"','"+razz+"','"+pm+"','"+napr+"','"+LUser+"',CURRENT_TIMESTAMP(),'"+LUser+"',CURRENT_TIMESTAMP())";
    }
if (action=="upd")
    {
    sql="update technologic.det_info set ei='"+tei+"',masd='"+Replace((String)masd,",",".")+"',obmid='"+(String)obmid+"',vz='"+tvz+"',kdz='"+(String)kdz+"',masz='"+Replace((String)masz,",",".")+"',nrm='"+Replace((String)nrm,",",".")+"',razz='"+razz+"',pm='"+pm+"',napr='"+napr+"',ChangeUser='"+LUser+"',ChangeDate=CURRENT_TIMESTAMP(),base='mysql' where id='"+(String)id+"'";
    }
if (sql!="")
    {
    effect=DB-\>SendCommand(sql);
    if (effect)
        {
        action="no";
        }
    }
if (operations)
    {
    effect=effect*operations-\>SaveData(operations);
    }
if (action!="no")
    {
    effect=false;
    }
return effect;
}
</code>

@@DtInfo::Get_pm
Description
Функция для получения расцеховки
C++ Syntax
<code lang="c++">
String     DtInfo::Get_pm(void)
{
String tmp="";
if (operations)
    {
    for (OperRow *i=operations-\>Get_First(); i; i=i-\>Get_Next())
        {
        if (i-\>isUsed()&amp;&amp;tmp.SubString(tmp.Length()-4,5).Trim()!=i-\>Get_ceh()+i-\>Get_uch())
            {
            tmp=tmp.Trim()+" "+i-\>Get_ceh()+i-\>Get_uch();
            }
        }
    }
if (tmp!=pm)
    {
    if (action=="no")
        {
        action="upd";
        }
    pm=tmp;
    }
return pm;
}
</code>

@@DtInfo::Set_ei@int
Description
Функция для замены едениц измерения
C++ Syntax
<code lang="c++">
void     DtInfo::Set_ei(int r)
{
if (!r)
    {
    ei=0;
    eiName="";
    }
if (ei!=r)
    {
    String kod=(String)r;
    while (kod.Length()\<3)
        {
        kod="0"+kod;
        }
    TADOQuery * rez=DB-\>SendSQL("Call catalogs.Get_eiName('"+kod+"')");
    if (rez&amp;&amp;rez-\>RecordCount)
        {
        ei=r;
        eiName=rez-\>FieldByName("eiName")-\>Value;
        if (action=="no")
            {
            action="upd";
            }
        }
    delete rez;
    }
}
</code>
Type Parameters
r :  новый код едениц измерения

@@DtInfo::Set_vz@int
Description
Функция для изменения вида заготовки
C++ Syntax
<code lang="c++">
void     DtInfo::Set_vz(int r)
{
if (vz!=r)
    {
    String kod=(String)r;
    while (kod.Length()\<3)
        {
        kod="0"+kod;
        }
    TADOQuery * rez=DB-\>SendSQL("Call billets.Get_vzName('"+kod+"')");
    if (rez&amp;&amp;rez-\>RecordCount)
        {
        vz=r;
        vzName=rez-\>FieldByName("vzName")-\>Value;
        if (action=="no")
            {
            action="upd";
            }
        }
    delete rez;
    }
}
</code>
Type Parameters
r :  Код вида заготовки

@@DtInfo::Set_obm@String
Description
Функция для смены обозначения материала
C++ Syntax
<code lang="c++">
void     DtInfo::Set_obm(String r)
{
if (obm!=r)
    {
    TADOQuery *rez=DB-\>SendSQL("Call constructions.Get_id('"+GostToVin(r)+"')");
    if (rez&amp;&amp;rez-\>RecordCount)
        {
        obmid=rez-\>FieldByName("id")-\>Value;
        obm=VinToGost(rez-\>FieldByName("obd")-\>Value);
        if(action=="no")
            {
            action="upd";
            }
        }
    delete rez;
    }
}
</code>
Type Parameters
r :  новое обозначение материала

@@DtInfo::Need_Save
Description
Функция для определения необходимости сохранения
C++ Syntax
<code lang="c++">
bool     DtInfo::Need_Save(void)
{
bool Need_save=action!="no"?true:false;
if (!Need_save&amp;&amp;operations)
    {
    Need_save=operations-\>Need_Save();
    }
return Need_save;
}
</code>

@@DtInfo::Can_Save@String &
Description
Функция проверяющая структуры данных технологии на предмет
ошибок
C++ Syntax
<code lang="c++">
bool    DtInfo::Can_Save(String &amp;msg)
{
bool result=true;
msg="Недостаточно данных.";
if (!vz)
    {
    \result=result*false;
    msg=msg+"\\nНеуказан код заготовки";
    }
if (!ei)
    {
    \result=result*false;
    msg=msg+"\\nНеуказаны еденицы измерения";
    }
if (!obmid)
    {
    \result=result*false;
    msg=msg+"\\nНеуказан материал";
    }
if (operations)
    {
    \result=result*operations-\>Can_Save(msg);
    }
return result;
}
</code>
Type Parameters
msg :  ссылка на накопительную переменную с текстом ошибок

@@DtInfo::Get_id@const
Description
Функция возвращающая идентификатор детали
C++ Syntax
<code lang="c++">
int     Get_id(void)const{return id;};
</code>

@@DtInfo::Get_ei@const
Description
Функция возвращающая код едениц измерения
C++ Syntax
<code>
int     Get_ei(void)const{return ei;};
</code>

@@DtInfo::Get_vz@const
Description
Функция возвращающая код вида заготовки
C++ Syntax
<code>
int     Get_vz(void)const{return vz;};
</code>

@@DtInfo::Get_kdz@const
Description
Функция возвращающая количество деталей в заготовке
C++ Syntax
<code>
int     Get_kdz(void)const{return kdz;};
</code>

@@DtInfo::Get_masd@const
Description
Функция возвращающая массу детали
C++ Syntax
<code>
double     Get_masd(void)const{return masd;};
</code>

@@DtInfo::Get_masz@const
Description
Функция возвращающая массу заготовки
C++ Syntax
<code>
double     Get_masz(void)const{return masz;};
</code>

@@DtInfo::Get_nrm@const
Description
Функция возвращающая норму расхода материала
C++ Syntax
<code lang="c++">
double     Get_nrm(void)const{return nrm;};
</code>

@@DtInfo::Get_eiName@const
Description
Функция возвращающая название едениц измерения
C++ Syntax
<code>
String     Get_eiName(void)const{return eiName;};
</code>

@@DtInfo::Get_vzName@const
Description
Функция возвращающая название вида заготовки
C++ Syntax
<code lang="c++">
String     Get_vzName(void)const{return vzName;};
</code>

@@DtInfo::Get_obm@const
Description
Функция для получения обозначения материала
C++ Syntax
<code lang="c++">
String     Get_obm(void)const{return obm;};
</code>

@@DtInfo::Get_razz@const
Description
Функция для получения размеров заготовки
C++ Syntax
<code lang="c++">
String     Get_razz(void)const{return razz;};
</code>


@@DtInfo::Get_napr@const
Description
функция для получения направления
C++ Syntax
<code>
String     Get_napr(void)const{return napr;};
</code>

@@DtInfo::Get_CreateUser@const
Description
функция для получения имени пользователя, создавшего запись
информации в базе
C++ Syntax
<code lang="c++">
String     Get_CreateUser(void)const{return CreateUser;};
</code>

@@DtInfo::Get_ChangeUser@const
Description
Функция возвращающая имя пользователя последним изменившего
запись информации о детали в базе
C++ Syntax
<code lang="c++">
String     Get_ChangeUser(void)const{return ChangeUser;};
</code>

@@DtInfo::Get_LUser
Description
Функция для получения имени пользователя, загрузившего
технологию
C++ Syntax
<code lang="c++">
String&amp; Get_LUser(void){return LUser;}
</code>

@@DtInfo::Get_CreateDate@const
Description
Функция для получения даты создания информации о детали
C++ Syntax
<code lang="c++">
TDateTime Get_CreateDate(void)const{return CreateDate;};
</code>

@@DtInfo::Get_ChangeDate@const
Description
Функция получения даты последнего изменения данных в
свойствах детали
C++ Syntax
<code lang="c++">
TDateTime Get_ChangeDate(void)const{return ChangeDate;};
</code>

@@DtInfo::Get_Operations@const
Description
Функция получения указателя на список операций
C++ Syntax
<code lang="c++">
OperRow * Get_Operations(void)const{return operations;};
</code>

@@DtInfo::Set_Operations@OperRow *
Description
Фукнция изменения указателя на список операций
C++ Syntax
<code lang="c++">
void       Set_Operations(OperRow *r){if (r){operations=r-\>Get_First();}else{operations=r;}};
</code>
Type Parameters
r :  указатель на операцию


@@DtInfo::Set_kdz@int
Description
Функция для обновления количества деталей в заготовке
C++ Syntax
<code lang="c++">
void Set_kdz(int r){if (kdz!=r){kdz=r;if (action=="no"){action="upd";}}};
</code>

@@DtInfo::Set_masd@double
Description
Функция для обновления массы детали
C++ Syntax
<code lang="c++">
void Set_masd(double r){if (masd!=r){masd=r;if (action=="no"){action="upd";}}};
</code>

@@DtInfo::Set_masz@double
Description
Функция для обновления массы заготовки
C++ Syntax
<code lang="c++">
void Set_masz(double r){if (masz!=r){masz=r;if (action=="no"){action="upd";}}};
</code>

@@DtInfo::Set_napr@String
Description
Функция для обновления направления
C++ Syntax
<code lang="c++">
void Set_napr(String r){if (napr!=r){napr=r;if (action=="no"){action="upd";}}};
</code>

@@DtInfo::Set_nrm@double
Description
функция для обновления нормы расхода
C++ Syntax
<code lang="c++">
void Set_nrm(double r){if (nrm!=r){nrm=r;if (action=="no"){action="upd";}}};
</code>

@@DtInfo::Set_razz@String
Description
Функция для обновления размеров заготовки
C++ Syntax
<code lang="c++">
void Set_razz(String r){if (razz!=r){razz=r;if (action=="no"){action="upd";}}};
</code>

@@DtInfo::Get_Access@const
Description
Функция для получения данных о доступности детали
C++ Syntax
<code lang="c++">
bool     Get_Access(void)const{return access;}
</code>

@@DtInfo::LUserID
Description
Идентификатор пользователя, запустившего модуль

@@DtInfo::LUser
Description
имя пользователя, запустившего модуль

@@DtInfo::access
Description
метка доступности загруженной детали

@@DtInfo::id
Description
идентификатор детали

@@DtInfo::vz
Description
вид заготовки

@@DtInfo::kdz
Description
количество деталей в заготовке

@@DtInfo::ei
Description
еденицы измерения (код)

@@DtInfo::obmid
Description
идентификатор материала

@@DtInfo::masd
Description
масса детали

@@DtInfo::masz
Description
масса заготовки

@@DtInfo::nrm
Description
норма расхода

@@DtInfo::eiName
Description
еденицы измерения (текст)

@@DtInfo::vzName
Description
вид заготовки (текст)

@@DtInfo::obm
Description
Обозначение материала

@@DtInfo::razz
Description
размер заготовки

@@DtInfo::pm
Description
расцеховка

@@DtInfo::napr
Description
направление

@@DtInfo::CreateUser
Description
имя создавшего пользователя

@@DtInfo::ChangeUser
Description
имя обновившего пользователя

@@DtInfo::CreateDate
Description
дата создания

@@DtInfo::ChangeDate
Description
дата последней модификации

@@DtInfo::operations
Description
указатель на цепочку операций

@@DtInfo::action
Description
действие, производимое с данными
Note
<table 20c%>
Индикатор   Действие со строкой
----------  ---------------------------------------------
ins         Команда на вставку новой строки в базу
upd         Команда на обновление строки в базе
no          Команда на бездействи (строка не изменялась)
del         Команда на удаление строки из базы
</table>

@@DtInfo::DB
Description
указатель на класс управления работой с базами данных

@@DtInfo::count
\ \ 
Description
количество одновременно существующих экземпляров класса

@@InstrumRow::ChangeOpID@unsigned __int64@lnk &@bool
Description
Функция для замены идентификатора операции в цепочке
инструмента


C++ Syntax
<code>
void InstrumRow::ChangeOpID    (unsigned __int64 _OpID,lnk &amp;r,bool no_del)
{
lnk Item=Get_First();
lnk Last_Item=0;
while (Item)
    {
    Last_Item=Item;
    if (Item-\>action!="del")
        {//замена  ид
        if (Item-\>OpID!=_OpID)
            {
            Item-\>OpID=_OpID;
            Item-\>action="ins";
            }
        Item=Item-\>next;
        }else
        {//удаление помеченных на удаление
        if (no_del)
            {
            if (Item-\>next)
                {
                Item=Item-\>next;
                delete Item-\>prev;
                }else
                {
                if (Item-\>prev)
                    {
                    Item=Item-\>prev;
                    delete Item-\>next;
                    }else
                    {
                    delete Item;
                    Item=0;
                    Last_Item=0;
                    }
                }
            }
        }
    }
if (Last_Item)//возврат указателя на начало цепочки
    {
    r=Last_Item-\>Get_First();
    }
    else
    {
    r=0;
    }
}
</code>

Type Parameters
_OpID :   Идентификатор операции
r :       ссылка на указатель
no_del :  _nt_

@@InstrumRow::Need_Save
Description
Функция проверки необходимости в сохранении данных
C++ Syntax
<code lang="c++">
bool InstrumRow::Need_Save(void)
{
bool Need_Save=false;
for (lnk i=Get_First(); i&amp;&amp;!Need_Save; i=i-\>Get_Next())
    {
    if (i-\>action!="no")
        {
        Need_Save=true;
        }
    }
return Need_Save;
}
</code>

@@InstrumRow::Get_action@const
Description
Функция для получения информации о текущем действии которое
будет произведено со сстрокой
C++ Syntax
<code lang="c++">
String        Get_action(void)const{return action;}
</code>

@@IspData::IspData
Description
Конструктор по умолчанию
C++ Syntax
<code lang="c++">
    IspData::IspData()
{
id=0;
main_isp=false;
selected=false;
O_V_Obd="";
G_Obd="";
V_Obd="";
}
</code>

@@IspData::Set_Obd@String &
Description
Функция обновления обозначения исполнения
C++ Syntax
<code lang="c++">
void         IspData::Set_Obd         (const String &amp;r)
{
V_Obd=GostToVin(r);
G_Obd=VinToGost(r);
if (O_V_Obd=="")
    {
    O_V_Obd=V_Obd;
    }
}
</code>
Type Parameters
r :  новое обозначение исполнения

@@IspData::Get_Obd@bool@const
Description
Функция плучения обозначения в заданном формате
C++ Syntax
<code lang="c++">
String  Get_Obd(bool gost)const{return gost?G_Obd:V_Obd;};
</code>

@@IspData::Get_O_V_Obd@const
Description
Функция получения первоначального обозначения исполнения в
формате vin
C++ Syntax
<code lang="c++">
String    Get_O_V_Obd(void) const{return O_V_Obd;}
</code>

@@IspData::id
Description
Идентификатор исполнения

@@IspData::main_isp
Description
Метка, показывающая главное это исполнение или нет

@@IspData::selected
Description
метка, показывающая было ли выбрано исполнение для действия
или нет

@@IspData::V_Obd
Обозначение исполнения в формате vin

@@IspData::G_Obd
\ \ 
Description
Обозначение исполнения в формате ГОСТ

@@IspData::O_V_Obd
Description
Первоначальное обозначения исполнения в формате vin

@@IspData
Description
Класс данных для управления исполнениями в редакторе
спецификаций

@@Less
Description
Функтор для функции sort

@@Less::()@IspData@IspData
Description
Перегруженный оператор() для std::sort
C++ Syntax
<code lang="c++">
inline bool operator()(IspData a1, IspData a2)
    {
    return a1.Get_Obd(false)\<a2.Get_Obd(false);
    }
</code>
